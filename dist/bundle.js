/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./dist/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./dist/index.js":
/*!***********************!*\
  !*** ./dist/index.js ***!
  \***********************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst HostedMoneroAPIClient_Base_1 = __importDefault(__webpack_require__(/*! ../libs/mymonero-app-js/local_modules/HostedMoneroAPIClient/HostedMoneroAPIClient_Base */ \"./libs/mymonero-app-js/local_modules/HostedMoneroAPIClient/HostedMoneroAPIClient_Base.js\"));\r\nconst BackgroundResponseParser_web_1 = __importDefault(__webpack_require__(/*! ../libs/mymonero-app-js/local_modules/HostedMoneroAPIClient/BackgroundResponseParser.web */ \"./libs/mymonero-app-js/local_modules/HostedMoneroAPIClient/BackgroundResponseParser.web.js\"));\r\nconst index_1 = __webpack_require__(/*! ../libs/mymonero-app-js/local_modules/mymonero_core_js/index */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/index.js\");\r\nconst request_1 = __importDefault(__webpack_require__(/*! request */ \"./node_modules/xhr/index.js\"));\r\nconst bignumber_js_1 = __webpack_require__(/*! bignumber.js */ \"./node_modules/bignumber.js/bignumber.js\");\r\nconst DEBUG = true;\r\n/**\r\n * Caches the asynchronous loaded monero_utils object.\r\n *\r\n * @remarks\r\n * The monero_utils import is a promise but has synchronous methods\r\n * that we want to use without forcing whole call chains into async/awaits.\r\n */\r\nclass MoneroUtilLoader {\r\n    static get util() {\r\n        if (!this._util) {\r\n            throw new Error(\"MoneroUtilLoader has not been loaded.\");\r\n        }\r\n        return this._util;\r\n    }\r\n    static load() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._util) {\r\n                this._util = yield index_1.monero_utils_promise;\r\n            }\r\n        });\r\n    }\r\n}\r\n/**\r\n * A promise-based class for interacting with the MyMonero API.\r\n *\r\n * @remarks\r\n * Uses helper methods from the mymonero web app which does all\r\n * the client-side heavy lifting required for constructing\r\n * transactions from possible-unspent outputs and key image processing\r\n * for determining the account's transaction history.\r\n *\r\n */\r\nclass MoneroWallet {\r\n    get addressKeys() {\r\n        return this._addressKeys;\r\n    }\r\n    constructor(walletData) {\r\n        this._addressKeys = walletData;\r\n        // Define options required by the MyMonero API client.\r\n        let apiClientOptions = {\r\n            appUserAgent_product: 'blockstack-monero',\r\n            appUserAgent_version: '0.0.1',\r\n            request_conformant_module: request_1.default\r\n        };\r\n        // Define the context object with the response parser required by the client.\r\n        let apiClientContext = {\r\n            backgroundAPIResponseParser: new BackgroundResponseParser_web_1.default()\r\n        };\r\n        // Instantiate an instance of the MyMonero API client.\r\n        this._apiClient = new HostedMoneroAPIClient_Base_1.default(apiClientOptions, apiClientContext);\r\n    }\r\n    /** Gets the network type value expected by monero_utils. */\r\n    static getNetworkID(testnet) {\r\n        if (testnet) {\r\n            return index_1.nettype_utils.network_type.TESTNET;\r\n        }\r\n        else {\r\n            return index_1.nettype_utils.network_type.MAINNET;\r\n        }\r\n    }\r\n    /** Generates a new set of account keys. */\r\n    static createNewAddress(localeLanguageCode = \"en-US\", testnet = false) {\r\n        const networkType = this.getNetworkID(testnet);\r\n        let keys = MoneroUtilLoader.util.newly_created_wallet(localeLanguageCode, networkType);\r\n        let result = {\r\n            mnemonic: keys.mnemonic_string,\r\n            mnemonicLanguage: keys.mnemonic_language,\r\n            publicAddress: keys.address_string,\r\n            privateKeys: {\r\n                spend: keys.sec_spendKey_string,\r\n                view: keys.sec_viewKey_string,\r\n            },\r\n            publicKeys: {\r\n                spend: keys.pub_spendKey_string,\r\n                view: keys.pub_viewKey_string\r\n            }\r\n        };\r\n        return result;\r\n    }\r\n    static createAddressKeysFromMnemonic(mnemonic, wordSetLanguage = \"English\", testnet = false) {\r\n        const networkType = this.getNetworkID(testnet);\r\n        // Create keys from mnemonic\r\n        const keys = MoneroUtilLoader.util.seed_and_keys_from_mnemonic(mnemonic, networkType);\r\n        let result = {\r\n            mnemonic: mnemonic,\r\n            mnemonicLanguage: keys.mnemonic_language,\r\n            publicAddress: keys.address_string,\r\n            privateKeys: {\r\n                spend: keys.sec_spendKey_string,\r\n                view: keys.sec_viewKey_string,\r\n            },\r\n            publicKeys: {\r\n                spend: keys.pub_spendKey_string,\r\n                view: keys.pub_viewKey_string\r\n            }\r\n        };\r\n        return result;\r\n    }\r\n    static createAddressKeysFromPrivateKey(privateKey, wordSetLanguage = \"English\", testnet = false) {\r\n        // Create mnemonic from the given private key.\r\n        const mnemonic = MoneroUtilLoader.util.mnemonic_from_seed(privateKey, wordSetLanguage);\r\n        return this.createAddressKeysFromMnemonic(mnemonic, wordSetLanguage, testnet);\r\n    }\r\n    getBalanceInfo() {\r\n        // Wrap the client callback oriented function in a Promise.\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n                this._apiClient.AddressInfo_returningRequestHandle(this._addressKeys.publicAddress, this._addressKeys.privateKeys.view, this._addressKeys.publicKeys.spend, this._addressKeys.privateKeys.spend, (err, ...result) => {\r\n                    if (err) {\r\n                        reject(err);\r\n                    }\r\n                    // The MyMonero API client returns all this data in the form of callback args, oh my.\r\n                    // Whip this argument list into a manageable object.\r\n                    let info = {\r\n                        // These amount values are in integer (small units / piconero), convert to human readable string.\r\n                        totalReceived: index_1.monero_amount_format_utils.formatMoney(result[0]),\r\n                        lockedBalance: index_1.monero_amount_format_utils.formatMoney(result[1]),\r\n                        totalSent: index_1.monero_amount_format_utils.formatMoney(result[2]),\r\n                        spentOutputs: result[3],\r\n                        accountScannedTxHeight: result[4],\r\n                        accountScannedBlockHeight: result[5],\r\n                        accountScanStartHeight: result[6],\r\n                        transactionHeight: result[7],\r\n                        blockchainHeight: result[8],\r\n                        ratesBySymbol: result[9]\r\n                    };\r\n                    resolve(info);\r\n                });\r\n            }\r\n            catch (err) {\r\n                // Internal error.\r\n                reject(err);\r\n            }\r\n        });\r\n    }\r\n    getTransactions() {\r\n        // Wrap the client callback oriented function in a Promise.\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n                this._apiClient.AddressTransactions_returningRequestHandle(this._addressKeys.publicAddress, this._addressKeys.privateKeys.view, this._addressKeys.publicKeys.spend, this._addressKeys.privateKeys.spend, (err, ...result) => {\r\n                    if (err) {\r\n                        reject(err);\r\n                    }\r\n                    // Convert some properties on the transaction objects to be more useful for us.\r\n                    let resultTxs = result[5];\r\n                    let txs = resultTxs.map(tx => ({\r\n                        amount: new bignumber_js_1.BigNumber(tx.amount.toString()),\r\n                        totalReceived: new bignumber_js_1.BigNumber(tx.total_received.toString()),\r\n                        totalSent: new bignumber_js_1.BigNumber(tx.total_sent.toString()),\r\n                        coinbase: tx.coinbase,\r\n                        hash: tx.hash,\r\n                        height: tx.height,\r\n                        id: tx.id,\r\n                        mempool: tx.mempool,\r\n                        mixin: tx.mixin,\r\n                        timestamp: tx.timestamp,\r\n                        unlockTime: tx.unlock_time\r\n                    }));\r\n                    // Turn these unruly callback function args into an object. \r\n                    let txResult = {\r\n                        accountScannedTxHeight: result[0],\r\n                        accountScannedBlockHeight: result[1],\r\n                        accountScanStartHeight: result[2],\r\n                        transactionHeight: result[3],\r\n                        blockchainHeight: result[4],\r\n                        transactions: txs\r\n                    };\r\n                    resolve(txResult);\r\n                });\r\n            }\r\n            catch (err) {\r\n                // Internal error.\r\n                reject(err);\r\n            }\r\n        });\r\n    }\r\n    sendFunds(toAddress, amount, testnet = false) {\r\n        // Wrap the client callback oriented function in a Promise.\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n                // Convert the BigNumber to a string.\r\n                let amountString = amount.toString();\r\n                const networkType = MoneroWallet.getNetworkID(testnet);\r\n                // Some hardcoded options (that not specifiable in GUI yet..)\r\n                const txPriority = 1; // normal priority\r\n                const paymentId = null;\r\n                const isSweep = false;\r\n                index_1.monero_sendingFunds_utils.SendFunds(toAddress, networkType, amountString, isSweep, this._addressKeys.publicAddress, this._addressKeys.privateKeys, this._addressKeys.publicKeys, this._apiClient, paymentId, txPriority, code => {\r\n                    // Intermediate status callback..\r\n                    console.log(\"Send funds step \" + code + \": \" + index_1.monero_sendingFunds_utils.SendFunds_ProcessStep_MessageSuffix[code]);\r\n                }, (...result) => {\r\n                    // Transaction successful callback..\r\n                    resolve({\r\n                        toAddress: result[0],\r\n                        sentAmount: result[1],\r\n                        paymentId: result[2],\r\n                        txHash: result[3],\r\n                        txFee: result[4],\r\n                        txKey: result[5],\r\n                        mixin: result[6]\r\n                    });\r\n                }, err => {\r\n                    // Transaction problem callback..\r\n                    reject(err);\r\n                });\r\n            }\r\n            catch (err) {\r\n                // Internal error.\r\n                reject(err);\r\n            }\r\n        });\r\n    }\r\n}\r\nfunction tests() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        yield MoneroUtilLoader.load();\r\n        let keys = MoneroWallet.createAddressKeysFromMnemonic(\"input betting five balding update licks hive february dogs peaches ongoing digit five\");\r\n        let moneroWallet = new MoneroWallet(keys);\r\n        let txs = yield moneroWallet.getTransactions();\r\n        console.log(txs);\r\n        let walletInfo = yield moneroWallet.getBalanceInfo();\r\n        console.log(walletInfo);\r\n        let toAddress = \"43Pzz5GFHzG4VSvoR1zievZmQ3ABZppFagWsQkdpLwV2JMmu2LLU5GgHmSbVqc7dBMAYi49BHXD3cTLWX3D4LX8k4q1AXQf\";\r\n        let sendResult = yield moneroWallet.sendFunds(toAddress, new bignumber_js_1.BigNumber(\"0.00001\"));\r\n        console.log(sendResult);\r\n    });\r\n}\r\ntests().then(result => {\r\n    console.log(result);\r\n})\r\n    .catch(err => {\r\n    console.log(err);\r\n});\r\n/*\r\n GUI TODO\r\n\r\n * Show list of transactions (link to a block explorer).\r\n * Show address/key details modal.\r\n * Send transaction modal.\r\n * Manual refresh button.\r\n * Refresh every 30s.\r\n *\r\n *\r\n\r\n Experiment:\r\n * Porting monero js code for the features (unspent output processing, tx key image process) to C# and in Blazor.\r\n\r\n */\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9kaXN0L2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZGlzdC9pbmRleC5qcz80OWI0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEhvc3RlZE1vbmVyb0FQSUNsaWVudF9CYXNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2xpYnMvbXltb25lcm8tYXBwLWpzL2xvY2FsX21vZHVsZXMvSG9zdGVkTW9uZXJvQVBJQ2xpZW50L0hvc3RlZE1vbmVyb0FQSUNsaWVudF9CYXNlXCIpKTtcclxuY29uc3QgQmFja2dyb3VuZFJlc3BvbnNlUGFyc2VyX3dlYl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL0hvc3RlZE1vbmVyb0FQSUNsaWVudC9CYWNrZ3JvdW5kUmVzcG9uc2VQYXJzZXIud2ViXCIpKTtcclxuY29uc3QgaW5kZXhfMSA9IHJlcXVpcmUoXCIuLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvaW5kZXhcIik7XHJcbmNvbnN0IHJlcXVlc3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicmVxdWVzdFwiKSk7XHJcbmNvbnN0IGJpZ251bWJlcl9qc18xID0gcmVxdWlyZShcImJpZ251bWJlci5qc1wiKTtcclxuY29uc3QgREVCVUcgPSB0cnVlO1xyXG4vKipcclxuICogQ2FjaGVzIHRoZSBhc3luY2hyb25vdXMgbG9hZGVkIG1vbmVyb191dGlscyBvYmplY3QuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFRoZSBtb25lcm9fdXRpbHMgaW1wb3J0IGlzIGEgcHJvbWlzZSBidXQgaGFzIHN5bmNocm9ub3VzIG1ldGhvZHNcclxuICogdGhhdCB3ZSB3YW50IHRvIHVzZSB3aXRob3V0IGZvcmNpbmcgd2hvbGUgY2FsbCBjaGFpbnMgaW50byBhc3luYy9hd2FpdHMuXHJcbiAqL1xyXG5jbGFzcyBNb25lcm9VdGlsTG9hZGVyIHtcclxuICAgIHN0YXRpYyBnZXQgdXRpbCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3V0aWwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTW9uZXJvVXRpbExvYWRlciBoYXMgbm90IGJlZW4gbG9hZGVkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3V0aWw7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbG9hZCgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3V0aWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3V0aWwgPSB5aWVsZCBpbmRleF8xLm1vbmVyb191dGlsc19wcm9taXNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgcHJvbWlzZS1iYXNlZCBjbGFzcyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgTXlNb25lcm8gQVBJLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBVc2VzIGhlbHBlciBtZXRob2RzIGZyb20gdGhlIG15bW9uZXJvIHdlYiBhcHAgd2hpY2ggZG9lcyBhbGxcclxuICogdGhlIGNsaWVudC1zaWRlIGhlYXZ5IGxpZnRpbmcgcmVxdWlyZWQgZm9yIGNvbnN0cnVjdGluZ1xyXG4gKiB0cmFuc2FjdGlvbnMgZnJvbSBwb3NzaWJsZS11bnNwZW50IG91dHB1dHMgYW5kIGtleSBpbWFnZSBwcm9jZXNzaW5nXHJcbiAqIGZvciBkZXRlcm1pbmluZyB0aGUgYWNjb3VudCdzIHRyYW5zYWN0aW9uIGhpc3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5jbGFzcyBNb25lcm9XYWxsZXQge1xyXG4gICAgZ2V0IGFkZHJlc3NLZXlzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRyZXNzS2V5cztcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKHdhbGxldERhdGEpIHtcclxuICAgICAgICB0aGlzLl9hZGRyZXNzS2V5cyA9IHdhbGxldERhdGE7XHJcbiAgICAgICAgLy8gRGVmaW5lIG9wdGlvbnMgcmVxdWlyZWQgYnkgdGhlIE15TW9uZXJvIEFQSSBjbGllbnQuXHJcbiAgICAgICAgbGV0IGFwaUNsaWVudE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGFwcFVzZXJBZ2VudF9wcm9kdWN0OiAnYmxvY2tzdGFjay1tb25lcm8nLFxyXG4gICAgICAgICAgICBhcHBVc2VyQWdlbnRfdmVyc2lvbjogJzAuMC4xJyxcclxuICAgICAgICAgICAgcmVxdWVzdF9jb25mb3JtYW50X21vZHVsZTogcmVxdWVzdF8xLmRlZmF1bHRcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIERlZmluZSB0aGUgY29udGV4dCBvYmplY3Qgd2l0aCB0aGUgcmVzcG9uc2UgcGFyc2VyIHJlcXVpcmVkIGJ5IHRoZSBjbGllbnQuXHJcbiAgICAgICAgbGV0IGFwaUNsaWVudENvbnRleHQgPSB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRBUElSZXNwb25zZVBhcnNlcjogbmV3IEJhY2tncm91bmRSZXNwb25zZVBhcnNlcl93ZWJfMS5kZWZhdWx0KClcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEluc3RhbnRpYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBNeU1vbmVybyBBUEkgY2xpZW50LlxyXG4gICAgICAgIHRoaXMuX2FwaUNsaWVudCA9IG5ldyBIb3N0ZWRNb25lcm9BUElDbGllbnRfQmFzZV8xLmRlZmF1bHQoYXBpQ2xpZW50T3B0aW9ucywgYXBpQ2xpZW50Q29udGV4dCk7XHJcbiAgICB9XHJcbiAgICAvKiogR2V0cyB0aGUgbmV0d29yayB0eXBlIHZhbHVlIGV4cGVjdGVkIGJ5IG1vbmVyb191dGlscy4gKi9cclxuICAgIHN0YXRpYyBnZXROZXR3b3JrSUQodGVzdG5ldCkge1xyXG4gICAgICAgIGlmICh0ZXN0bmV0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleF8xLm5ldHR5cGVfdXRpbHMubmV0d29ya190eXBlLlRFU1RORVQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXhfMS5uZXR0eXBlX3V0aWxzLm5ldHdvcmtfdHlwZS5NQUlOTkVUO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBHZW5lcmF0ZXMgYSBuZXcgc2V0IG9mIGFjY291bnQga2V5cy4gKi9cclxuICAgIHN0YXRpYyBjcmVhdGVOZXdBZGRyZXNzKGxvY2FsZUxhbmd1YWdlQ29kZSA9IFwiZW4tVVNcIiwgdGVzdG5ldCA9IGZhbHNlKSB7XHJcbiAgICAgICAgY29uc3QgbmV0d29ya1R5cGUgPSB0aGlzLmdldE5ldHdvcmtJRCh0ZXN0bmV0KTtcclxuICAgICAgICBsZXQga2V5cyA9IE1vbmVyb1V0aWxMb2FkZXIudXRpbC5uZXdseV9jcmVhdGVkX3dhbGxldChsb2NhbGVMYW5ndWFnZUNvZGUsIG5ldHdvcmtUeXBlKTtcclxuICAgICAgICBsZXQgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICBtbmVtb25pYzoga2V5cy5tbmVtb25pY19zdHJpbmcsXHJcbiAgICAgICAgICAgIG1uZW1vbmljTGFuZ3VhZ2U6IGtleXMubW5lbW9uaWNfbGFuZ3VhZ2UsXHJcbiAgICAgICAgICAgIHB1YmxpY0FkZHJlc3M6IGtleXMuYWRkcmVzc19zdHJpbmcsXHJcbiAgICAgICAgICAgIHByaXZhdGVLZXlzOiB7XHJcbiAgICAgICAgICAgICAgICBzcGVuZDoga2V5cy5zZWNfc3BlbmRLZXlfc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgdmlldzoga2V5cy5zZWNfdmlld0tleV9zdHJpbmcsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHB1YmxpY0tleXM6IHtcclxuICAgICAgICAgICAgICAgIHNwZW5kOiBrZXlzLnB1Yl9zcGVuZEtleV9zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICB2aWV3OiBrZXlzLnB1Yl92aWV3S2V5X3N0cmluZ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWF0ZUFkZHJlc3NLZXlzRnJvbU1uZW1vbmljKG1uZW1vbmljLCB3b3JkU2V0TGFuZ3VhZ2UgPSBcIkVuZ2xpc2hcIiwgdGVzdG5ldCA9IGZhbHNlKSB7XHJcbiAgICAgICAgY29uc3QgbmV0d29ya1R5cGUgPSB0aGlzLmdldE5ldHdvcmtJRCh0ZXN0bmV0KTtcclxuICAgICAgICAvLyBDcmVhdGUga2V5cyBmcm9tIG1uZW1vbmljXHJcbiAgICAgICAgY29uc3Qga2V5cyA9IE1vbmVyb1V0aWxMb2FkZXIudXRpbC5zZWVkX2FuZF9rZXlzX2Zyb21fbW5lbW9uaWMobW5lbW9uaWMsIG5ldHdvcmtUeXBlKTtcclxuICAgICAgICBsZXQgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICBtbmVtb25pYzogbW5lbW9uaWMsXHJcbiAgICAgICAgICAgIG1uZW1vbmljTGFuZ3VhZ2U6IGtleXMubW5lbW9uaWNfbGFuZ3VhZ2UsXHJcbiAgICAgICAgICAgIHB1YmxpY0FkZHJlc3M6IGtleXMuYWRkcmVzc19zdHJpbmcsXHJcbiAgICAgICAgICAgIHByaXZhdGVLZXlzOiB7XHJcbiAgICAgICAgICAgICAgICBzcGVuZDoga2V5cy5zZWNfc3BlbmRLZXlfc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgdmlldzoga2V5cy5zZWNfdmlld0tleV9zdHJpbmcsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHB1YmxpY0tleXM6IHtcclxuICAgICAgICAgICAgICAgIHNwZW5kOiBrZXlzLnB1Yl9zcGVuZEtleV9zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICB2aWV3OiBrZXlzLnB1Yl92aWV3S2V5X3N0cmluZ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWF0ZUFkZHJlc3NLZXlzRnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSwgd29yZFNldExhbmd1YWdlID0gXCJFbmdsaXNoXCIsIHRlc3RuZXQgPSBmYWxzZSkge1xyXG4gICAgICAgIC8vIENyZWF0ZSBtbmVtb25pYyBmcm9tIHRoZSBnaXZlbiBwcml2YXRlIGtleS5cclxuICAgICAgICBjb25zdCBtbmVtb25pYyA9IE1vbmVyb1V0aWxMb2FkZXIudXRpbC5tbmVtb25pY19mcm9tX3NlZWQocHJpdmF0ZUtleSwgd29yZFNldExhbmd1YWdlKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVBZGRyZXNzS2V5c0Zyb21NbmVtb25pYyhtbmVtb25pYywgd29yZFNldExhbmd1YWdlLCB0ZXN0bmV0KTtcclxuICAgIH1cclxuICAgIGdldEJhbGFuY2VJbmZvKCkge1xyXG4gICAgICAgIC8vIFdyYXAgdGhlIGNsaWVudCBjYWxsYmFjayBvcmllbnRlZCBmdW5jdGlvbiBpbiBhIFByb21pc2UuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwaUNsaWVudC5BZGRyZXNzSW5mb19yZXR1cm5pbmdSZXF1ZXN0SGFuZGxlKHRoaXMuX2FkZHJlc3NLZXlzLnB1YmxpY0FkZHJlc3MsIHRoaXMuX2FkZHJlc3NLZXlzLnByaXZhdGVLZXlzLnZpZXcsIHRoaXMuX2FkZHJlc3NLZXlzLnB1YmxpY0tleXMuc3BlbmQsIHRoaXMuX2FkZHJlc3NLZXlzLnByaXZhdGVLZXlzLnNwZW5kLCAoZXJyLCAuLi5yZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgTXlNb25lcm8gQVBJIGNsaWVudCByZXR1cm5zIGFsbCB0aGlzIGRhdGEgaW4gdGhlIGZvcm0gb2YgY2FsbGJhY2sgYXJncywgb2ggbXkuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hpcCB0aGlzIGFyZ3VtZW50IGxpc3QgaW50byBhIG1hbmFnZWFibGUgb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBhbW91bnQgdmFsdWVzIGFyZSBpbiBpbnRlZ2VyIChzbWFsbCB1bml0cyAvIHBpY29uZXJvKSwgY29udmVydCB0byBodW1hbiByZWFkYWJsZSBzdHJpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsUmVjZWl2ZWQ6IGluZGV4XzEubW9uZXJvX2Ftb3VudF9mb3JtYXRfdXRpbHMuZm9ybWF0TW9uZXkocmVzdWx0WzBdKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9ja2VkQmFsYW5jZTogaW5kZXhfMS5tb25lcm9fYW1vdW50X2Zvcm1hdF91dGlscy5mb3JtYXRNb25leShyZXN1bHRbMV0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFNlbnQ6IGluZGV4XzEubW9uZXJvX2Ftb3VudF9mb3JtYXRfdXRpbHMuZm9ybWF0TW9uZXkocmVzdWx0WzJdKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3BlbnRPdXRwdXRzOiByZXN1bHRbM10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRTY2FubmVkVHhIZWlnaHQ6IHJlc3VsdFs0XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudFNjYW5uZWRCbG9ja0hlaWdodDogcmVzdWx0WzVdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50U2NhblN0YXJ0SGVpZ2h0OiByZXN1bHRbNl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGVpZ2h0OiByZXN1bHRbN10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrY2hhaW5IZWlnaHQ6IHJlc3VsdFs4XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmF0ZXNCeVN5bWJvbDogcmVzdWx0WzldXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGluZm8pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgLy8gSW50ZXJuYWwgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0VHJhbnNhY3Rpb25zKCkge1xyXG4gICAgICAgIC8vIFdyYXAgdGhlIGNsaWVudCBjYWxsYmFjayBvcmllbnRlZCBmdW5jdGlvbiBpbiBhIFByb21pc2UuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwaUNsaWVudC5BZGRyZXNzVHJhbnNhY3Rpb25zX3JldHVybmluZ1JlcXVlc3RIYW5kbGUodGhpcy5fYWRkcmVzc0tleXMucHVibGljQWRkcmVzcywgdGhpcy5fYWRkcmVzc0tleXMucHJpdmF0ZUtleXMudmlldywgdGhpcy5fYWRkcmVzc0tleXMucHVibGljS2V5cy5zcGVuZCwgdGhpcy5fYWRkcmVzc0tleXMucHJpdmF0ZUtleXMuc3BlbmQsIChlcnIsIC4uLnJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgc29tZSBwcm9wZXJ0aWVzIG9uIHRoZSB0cmFuc2FjdGlvbiBvYmplY3RzIHRvIGJlIG1vcmUgdXNlZnVsIGZvciB1cy5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0VHhzID0gcmVzdWx0WzVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0eHMgPSByZXN1bHRUeHMubWFwKHR4ID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudDogbmV3IGJpZ251bWJlcl9qc18xLkJpZ051bWJlcih0eC5hbW91bnQudG9TdHJpbmcoKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsUmVjZWl2ZWQ6IG5ldyBiaWdudW1iZXJfanNfMS5CaWdOdW1iZXIodHgudG90YWxfcmVjZWl2ZWQudG9TdHJpbmcoKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsU2VudDogbmV3IGJpZ251bWJlcl9qc18xLkJpZ051bWJlcih0eC50b3RhbF9zZW50LnRvU3RyaW5nKCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2luYmFzZTogdHguY29pbmJhc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6IHR4Lmhhc2gsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdHguaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdHguaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbXBvb2w6IHR4Lm1lbXBvb2wsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1peGluOiB0eC5taXhpbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiB0eC50aW1lc3RhbXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVubG9ja1RpbWU6IHR4LnVubG9ja190aW1lXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFR1cm4gdGhlc2UgdW5ydWx5IGNhbGxiYWNrIGZ1bmN0aW9uIGFyZ3MgaW50byBhbiBvYmplY3QuIFxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0eFJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudFNjYW5uZWRUeEhlaWdodDogcmVzdWx0WzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50U2Nhbm5lZEJsb2NrSGVpZ2h0OiByZXN1bHRbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRTY2FuU3RhcnRIZWlnaHQ6IHJlc3VsdFsyXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25IZWlnaHQ6IHJlc3VsdFszXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tjaGFpbkhlaWdodDogcmVzdWx0WzRdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IHR4c1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0eFJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJbnRlcm5hbCBlcnJvci5cclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzZW5kRnVuZHModG9BZGRyZXNzLCBhbW91bnQsIHRlc3RuZXQgPSBmYWxzZSkge1xyXG4gICAgICAgIC8vIFdyYXAgdGhlIGNsaWVudCBjYWxsYmFjayBvcmllbnRlZCBmdW5jdGlvbiBpbiBhIFByb21pc2UuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIEJpZ051bWJlciB0byBhIHN0cmluZy5cclxuICAgICAgICAgICAgICAgIGxldCBhbW91bnRTdHJpbmcgPSBhbW91bnQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ldHdvcmtUeXBlID0gTW9uZXJvV2FsbGV0LmdldE5ldHdvcmtJRCh0ZXN0bmV0KTtcclxuICAgICAgICAgICAgICAgIC8vIFNvbWUgaGFyZGNvZGVkIG9wdGlvbnMgKHRoYXQgbm90IHNwZWNpZmlhYmxlIGluIEdVSSB5ZXQuLilcclxuICAgICAgICAgICAgICAgIGNvbnN0IHR4UHJpb3JpdHkgPSAxOyAvLyBub3JtYWwgcHJpb3JpdHlcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBheW1lbnRJZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc1N3ZWVwID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpbmRleF8xLm1vbmVyb19zZW5kaW5nRnVuZHNfdXRpbHMuU2VuZEZ1bmRzKHRvQWRkcmVzcywgbmV0d29ya1R5cGUsIGFtb3VudFN0cmluZywgaXNTd2VlcCwgdGhpcy5fYWRkcmVzc0tleXMucHVibGljQWRkcmVzcywgdGhpcy5fYWRkcmVzc0tleXMucHJpdmF0ZUtleXMsIHRoaXMuX2FkZHJlc3NLZXlzLnB1YmxpY0tleXMsIHRoaXMuX2FwaUNsaWVudCwgcGF5bWVudElkLCB0eFByaW9yaXR5LCBjb2RlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgc3RhdHVzIGNhbGxiYWNrLi5cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNlbmQgZnVuZHMgc3RlcCBcIiArIGNvZGUgKyBcIjogXCIgKyBpbmRleF8xLm1vbmVyb19zZW5kaW5nRnVuZHNfdXRpbHMuU2VuZEZ1bmRzX1Byb2Nlc3NTdGVwX01lc3NhZ2VTdWZmaXhbY29kZV0pO1xyXG4gICAgICAgICAgICAgICAgfSwgKC4uLnJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zYWN0aW9uIHN1Y2Nlc3NmdWwgY2FsbGJhY2suLlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b0FkZHJlc3M6IHJlc3VsdFswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VudEFtb3VudDogcmVzdWx0WzFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXltZW50SWQ6IHJlc3VsdFsyXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHhIYXNoOiByZXN1bHRbM10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4RmVlOiByZXN1bHRbNF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4S2V5OiByZXN1bHRbNV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1peGluOiByZXN1bHRbNl1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sIGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNhY3Rpb24gcHJvYmxlbSBjYWxsYmFjay4uXHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJbnRlcm5hbCBlcnJvci5cclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdGVzdHMoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHlpZWxkIE1vbmVyb1V0aWxMb2FkZXIubG9hZCgpO1xyXG4gICAgICAgIGxldCBrZXlzID0gTW9uZXJvV2FsbGV0LmNyZWF0ZUFkZHJlc3NLZXlzRnJvbU1uZW1vbmljKFwiaW5wdXQgYmV0dGluZyBmaXZlIGJhbGRpbmcgdXBkYXRlIGxpY2tzIGhpdmUgZmVicnVhcnkgZG9ncyBwZWFjaGVzIG9uZ29pbmcgZGlnaXQgZml2ZVwiKTtcclxuICAgICAgICBsZXQgbW9uZXJvV2FsbGV0ID0gbmV3IE1vbmVyb1dhbGxldChrZXlzKTtcclxuICAgICAgICBsZXQgdHhzID0geWllbGQgbW9uZXJvV2FsbGV0LmdldFRyYW5zYWN0aW9ucygpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHR4cyk7XHJcbiAgICAgICAgbGV0IHdhbGxldEluZm8gPSB5aWVsZCBtb25lcm9XYWxsZXQuZ2V0QmFsYW5jZUluZm8oKTtcclxuICAgICAgICBjb25zb2xlLmxvZyh3YWxsZXRJbmZvKTtcclxuICAgICAgICBsZXQgdG9BZGRyZXNzID0gXCI0M1B6ejVHRkh6RzRWU3ZvUjF6aWV2Wm1RM0FCWnBwRmFnV3NRa2RwTHdWMkpNbXUyTExVNUdnSG1TYlZxYzdkQk1BWWk0OUJIWEQzY1RMV1gzRDRMWDhrNHExQVhRZlwiO1xyXG4gICAgICAgIGxldCBzZW5kUmVzdWx0ID0geWllbGQgbW9uZXJvV2FsbGV0LnNlbmRGdW5kcyh0b0FkZHJlc3MsIG5ldyBiaWdudW1iZXJfanNfMS5CaWdOdW1iZXIoXCIwLjAwMDAxXCIpKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhzZW5kUmVzdWx0KTtcclxuICAgIH0pO1xyXG59XHJcbnRlc3RzKCkudGhlbihyZXN1bHQgPT4ge1xyXG4gICAgY29uc29sZS5sb2cocmVzdWx0KTtcclxufSlcclxuICAgIC5jYXRjaChlcnIgPT4ge1xyXG4gICAgY29uc29sZS5sb2coZXJyKTtcclxufSk7XHJcbi8qXHJcbiBHVUkgVE9ET1xyXG5cclxuICogU2hvdyBsaXN0IG9mIHRyYW5zYWN0aW9ucyAobGluayB0byBhIGJsb2NrIGV4cGxvcmVyKS5cclxuICogU2hvdyBhZGRyZXNzL2tleSBkZXRhaWxzIG1vZGFsLlxyXG4gKiBTZW5kIHRyYW5zYWN0aW9uIG1vZGFsLlxyXG4gKiBNYW51YWwgcmVmcmVzaCBidXR0b24uXHJcbiAqIFJlZnJlc2ggZXZlcnkgMzBzLlxyXG4gKlxyXG4gKlxyXG5cclxuIEV4cGVyaW1lbnQ6XHJcbiAqIFBvcnRpbmcgbW9uZXJvIGpzIGNvZGUgZm9yIHRoZSBmZWF0dXJlcyAodW5zcGVudCBvdXRwdXQgcHJvY2Vzc2luZywgdHgga2V5IGltYWdlIHByb2Nlc3MpIHRvIEMjIGFuZCBpbiBCbGF6b3IuXHJcblxyXG4gKi9cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./dist/index.js\n");

/***/ }),

/***/ "./libs/mymonero-app-js/local_modules/HostedMoneroAPIClient/BackgroundResponseParser.web.js":
/*!**************************************************************************************************!*\
  !*** ./libs/mymonero-app-js/local_modules/HostedMoneroAPIClient/BackgroundResponseParser.web.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(setImmediate) {// Copyright (c) 2014-2018, MyMonero.com\r\n//\r\n// All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without modification, are\r\n// permitted provided that the following conditions are met:\r\n//\r\n// 1. Redistributions of source code must retain the above copyright notice, this list of\r\n//\tconditions and the following disclaimer.\r\n//\r\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list\r\n//\tof conditions and the following disclaimer in the documentation and/or other\r\n//\tmaterials provided with the distribution.\r\n//\r\n// 3. Neither the name of the copyright holder nor the names of its contributors may be\r\n//\tused to endorse or promote products derived from this software without specific\r\n//\tprior written permission.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\r\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\r\n// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\r\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n//\r\n\r\n//\r\n// In the future this could implement web workers\r\nconst response_parser_utils = __webpack_require__(/*! ../mymonero_core_js/hostAPI/response_parser_utils */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/hostAPI/response_parser_utils.js\")\r\nconst monero_keyImage_cache_utils = __webpack_require__(/*! ../mymonero_core_js/monero_utils/monero_keyImage_cache_utils */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_keyImage_cache_utils.js\")\r\nconst monero_utils_promise = __webpack_require__(/*! ../mymonero_core_js/monero_utils/monero_utils */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_utils.js\")({})\r\n//\r\nclass BackgroundResponseParser\r\n{\r\n\tconstructor(options, context)\r\n\t{\r\n\t}\r\n\t//\r\n\t// Runtime - Accessors - Interface\r\n\t//\r\n\tParsed_AddressInfo(\r\n\t\tdata,\r\n\t\taddress,\r\n\t\tview_key__private,\r\n\t\tspend_key__public,\r\n\t\tspend_key__private,\r\n\t\tfn //: (err?, returnValuesByKey?) -> Void\r\n\t) {\r\n\t\tmonero_utils_promise.then(function(monero_utils)\r\n\t\t{\r\n\t\t\tresponse_parser_utils.Parsed_AddressInfo__keyImageManaged(\r\n\t\t\t\tdata,\r\n\t\t\t\taddress,\r\n\t\t\t\tview_key__private,\r\n\t\t\t\tspend_key__public,\r\n\t\t\t\tspend_key__private,\r\n\t\t\t\tmonero_utils,\r\n\t\t\t\tfunction(err, returnValuesByKey)\r\n\t\t\t\t{\r\n\t\t\t\t\tfn(err, returnValuesByKey)\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t})\r\n\t}\r\n\tParsed_AddressTransactions(\r\n\t\tdata,\r\n\t\taddress,\r\n\t\tview_key__private,\r\n\t\tspend_key__public,\r\n\t\tspend_key__private,\r\n\t\tfn //: (err?, returnValuesByKey?) -> Void\r\n\t) {\r\n\t\tmonero_utils_promise.then(function(monero_utils)\r\n\t\t{\r\n\t\t\tresponse_parser_utils.Parsed_AddressTransactions__keyImageManaged(\r\n\t\t\t\tdata,\r\n\t\t\t\taddress,\r\n\t\t\t\tview_key__private,\r\n\t\t\t\tspend_key__public,\r\n\t\t\t\tspend_key__private,\r\n\t\t\t\tmonero_utils,\r\n\t\t\t\tfunction(err, returnValuesByKey)\r\n\t\t\t\t{\r\n\t\t\t\t\tfn(err, returnValuesByKey)\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t})\r\n\t}\r\n\tParsed_UnspentOuts(\r\n\t\tdata,\r\n\t\taddress,\r\n\t\tview_key__private,\r\n\t\tspend_key__public,\r\n\t\tspend_key__private,\r\n\t\tfn //: (err?, returnValuesByKey?) -> Void\r\n\t) {\r\n\t\tmonero_utils_promise.then(function(monero_utils)\r\n\t\t{\r\n\t\t\tresponse_parser_utils.Parsed_UnspentOuts__keyImageManaged(\r\n\t\t\t\tdata,\r\n\t\t\t\taddress,\r\n\t\t\t\tview_key__private,\r\n\t\t\t\tspend_key__public,\r\n\t\t\t\tspend_key__private,\r\n\t\t\t\tmonero_utils,\r\n\t\t\t\tfunction(err, returnValuesByKey)\r\n\t\t\t\t{\r\n\t\t\t\t\tfn(err, returnValuesByKey)\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t})\r\n\t}\r\n\t//\r\n\tDeleteManagedKeyImagesForWalletWith(\r\n\t\taddress,\r\n\t\tfn // ((err) -> Void)? \r\n\t) {\r\n\t\tmonero_keyImage_cache_utils.DeleteManagedKeyImagesForWalletWith(address)\r\n\t\tif (fn) {\r\n\t\t\tsetImmediate(fn)\r\n\t\t}\r\n\t}\r\n}\r\nmodule.exports = BackgroundResponseParser\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL0hvc3RlZE1vbmVyb0FQSUNsaWVudC9CYWNrZ3JvdW5kUmVzcG9uc2VQYXJzZXIud2ViLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGlicy9teW1vbmVyby1hcHAtanMvbG9jYWxfbW9kdWxlcy9Ib3N0ZWRNb25lcm9BUElDbGllbnQvQmFja2dyb3VuZFJlc3BvbnNlUGFyc2VyLndlYi5qcz9iNjMzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNC0yMDE4LCBNeU1vbmVyby5jb21cclxuLy9cclxuLy8gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy9cclxuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlXHJcbi8vIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4vL1xyXG4vLyAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZlxyXG4vL1x0Y29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4vL1xyXG4vLyAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdFxyXG4vL1x0b2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlclxyXG4vL1x0bWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuLy9cclxuLy8gMy4gTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgY29weXJpZ2h0IGhvbGRlciBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlXHJcbi8vXHR1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljXHJcbi8vXHRwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcbi8vXHJcbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORCBBTllcclxuLy8gRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GXHJcbi8vIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMXHJcbi8vIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxyXG4vLyBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXHJcbi8vIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xyXG4vLyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCxcclxuLy8gU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXHJcbi8vIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuLy9cclxuXCJ1c2Ugc3RyaWN0XCJcclxuLy9cclxuLy8gSW4gdGhlIGZ1dHVyZSB0aGlzIGNvdWxkIGltcGxlbWVudCB3ZWIgd29ya2Vyc1xyXG5jb25zdCByZXNwb25zZV9wYXJzZXJfdXRpbHMgPSByZXF1aXJlKCcuLi9teW1vbmVyb19jb3JlX2pzL2hvc3RBUEkvcmVzcG9uc2VfcGFyc2VyX3V0aWxzJylcclxuY29uc3QgbW9uZXJvX2tleUltYWdlX2NhY2hlX3V0aWxzID0gcmVxdWlyZSgnLi4vbXltb25lcm9fY29yZV9qcy9tb25lcm9fdXRpbHMvbW9uZXJvX2tleUltYWdlX2NhY2hlX3V0aWxzJylcclxuY29uc3QgbW9uZXJvX3V0aWxzX3Byb21pc2UgPSByZXF1aXJlKCcuLi9teW1vbmVyb19jb3JlX2pzL21vbmVyb191dGlscy9tb25lcm9fdXRpbHMnKSh7fSlcclxuLy9cclxuY2xhc3MgQmFja2dyb3VuZFJlc3BvbnNlUGFyc2VyXHJcbntcclxuXHRjb25zdHJ1Y3RvcihvcHRpb25zLCBjb250ZXh0KVxyXG5cdHtcclxuXHR9XHJcblx0Ly9cclxuXHQvLyBSdW50aW1lIC0gQWNjZXNzb3JzIC0gSW50ZXJmYWNlXHJcblx0Ly9cclxuXHRQYXJzZWRfQWRkcmVzc0luZm8oXHJcblx0XHRkYXRhLFxyXG5cdFx0YWRkcmVzcyxcclxuXHRcdHZpZXdfa2V5X19wcml2YXRlLFxyXG5cdFx0c3BlbmRfa2V5X19wdWJsaWMsXHJcblx0XHRzcGVuZF9rZXlfX3ByaXZhdGUsXHJcblx0XHRmbiAvLzogKGVycj8sIHJldHVyblZhbHVlc0J5S2V5PykgLT4gVm9pZFxyXG5cdCkge1xyXG5cdFx0bW9uZXJvX3V0aWxzX3Byb21pc2UudGhlbihmdW5jdGlvbihtb25lcm9fdXRpbHMpXHJcblx0XHR7XHJcblx0XHRcdHJlc3BvbnNlX3BhcnNlcl91dGlscy5QYXJzZWRfQWRkcmVzc0luZm9fX2tleUltYWdlTWFuYWdlZChcclxuXHRcdFx0XHRkYXRhLFxyXG5cdFx0XHRcdGFkZHJlc3MsXHJcblx0XHRcdFx0dmlld19rZXlfX3ByaXZhdGUsXHJcblx0XHRcdFx0c3BlbmRfa2V5X19wdWJsaWMsXHJcblx0XHRcdFx0c3BlbmRfa2V5X19wcml2YXRlLFxyXG5cdFx0XHRcdG1vbmVyb191dGlscyxcclxuXHRcdFx0XHRmdW5jdGlvbihlcnIsIHJldHVyblZhbHVlc0J5S2V5KVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdGZuKGVyciwgcmV0dXJuVmFsdWVzQnlLZXkpXHJcblx0XHRcdFx0fVxyXG5cdFx0XHQpXHJcblx0XHR9KVxyXG5cdH1cclxuXHRQYXJzZWRfQWRkcmVzc1RyYW5zYWN0aW9ucyhcclxuXHRcdGRhdGEsXHJcblx0XHRhZGRyZXNzLFxyXG5cdFx0dmlld19rZXlfX3ByaXZhdGUsXHJcblx0XHRzcGVuZF9rZXlfX3B1YmxpYyxcclxuXHRcdHNwZW5kX2tleV9fcHJpdmF0ZSxcclxuXHRcdGZuIC8vOiAoZXJyPywgcmV0dXJuVmFsdWVzQnlLZXk/KSAtPiBWb2lkXHJcblx0KSB7XHJcblx0XHRtb25lcm9fdXRpbHNfcHJvbWlzZS50aGVuKGZ1bmN0aW9uKG1vbmVyb191dGlscylcclxuXHRcdHtcclxuXHRcdFx0cmVzcG9uc2VfcGFyc2VyX3V0aWxzLlBhcnNlZF9BZGRyZXNzVHJhbnNhY3Rpb25zX19rZXlJbWFnZU1hbmFnZWQoXHJcblx0XHRcdFx0ZGF0YSxcclxuXHRcdFx0XHRhZGRyZXNzLFxyXG5cdFx0XHRcdHZpZXdfa2V5X19wcml2YXRlLFxyXG5cdFx0XHRcdHNwZW5kX2tleV9fcHVibGljLFxyXG5cdFx0XHRcdHNwZW5kX2tleV9fcHJpdmF0ZSxcclxuXHRcdFx0XHRtb25lcm9fdXRpbHMsXHJcblx0XHRcdFx0ZnVuY3Rpb24oZXJyLCByZXR1cm5WYWx1ZXNCeUtleSlcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRmbihlcnIsIHJldHVyblZhbHVlc0J5S2V5KVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0KVxyXG5cdFx0fSlcclxuXHR9XHJcblx0UGFyc2VkX1Vuc3BlbnRPdXRzKFxyXG5cdFx0ZGF0YSxcclxuXHRcdGFkZHJlc3MsXHJcblx0XHR2aWV3X2tleV9fcHJpdmF0ZSxcclxuXHRcdHNwZW5kX2tleV9fcHVibGljLFxyXG5cdFx0c3BlbmRfa2V5X19wcml2YXRlLFxyXG5cdFx0Zm4gLy86IChlcnI/LCByZXR1cm5WYWx1ZXNCeUtleT8pIC0+IFZvaWRcclxuXHQpIHtcclxuXHRcdG1vbmVyb191dGlsc19wcm9taXNlLnRoZW4oZnVuY3Rpb24obW9uZXJvX3V0aWxzKVxyXG5cdFx0e1xyXG5cdFx0XHRyZXNwb25zZV9wYXJzZXJfdXRpbHMuUGFyc2VkX1Vuc3BlbnRPdXRzX19rZXlJbWFnZU1hbmFnZWQoXHJcblx0XHRcdFx0ZGF0YSxcclxuXHRcdFx0XHRhZGRyZXNzLFxyXG5cdFx0XHRcdHZpZXdfa2V5X19wcml2YXRlLFxyXG5cdFx0XHRcdHNwZW5kX2tleV9fcHVibGljLFxyXG5cdFx0XHRcdHNwZW5kX2tleV9fcHJpdmF0ZSxcclxuXHRcdFx0XHRtb25lcm9fdXRpbHMsXHJcblx0XHRcdFx0ZnVuY3Rpb24oZXJyLCByZXR1cm5WYWx1ZXNCeUtleSlcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRmbihlcnIsIHJldHVyblZhbHVlc0J5S2V5KVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0KVxyXG5cdFx0fSlcclxuXHR9XHJcblx0Ly9cclxuXHREZWxldGVNYW5hZ2VkS2V5SW1hZ2VzRm9yV2FsbGV0V2l0aChcclxuXHRcdGFkZHJlc3MsXHJcblx0XHRmbiAvLyAoKGVycikgLT4gVm9pZCk/IFxyXG5cdCkge1xyXG5cdFx0bW9uZXJvX2tleUltYWdlX2NhY2hlX3V0aWxzLkRlbGV0ZU1hbmFnZWRLZXlJbWFnZXNGb3JXYWxsZXRXaXRoKGFkZHJlc3MpXHJcblx0XHRpZiAoZm4pIHtcclxuXHRcdFx0c2V0SW1tZWRpYXRlKGZuKVxyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tncm91bmRSZXNwb25zZVBhcnNlciJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./libs/mymonero-app-js/local_modules/HostedMoneroAPIClient/BackgroundResponseParser.web.js\n");

/***/ }),

/***/ "./libs/mymonero-app-js/local_modules/HostedMoneroAPIClient/HostedMoneroAPIClient_Base.js":
/*!************************************************************************************************!*\
  !*** ./libs/mymonero-app-js/local_modules/HostedMoneroAPIClient/HostedMoneroAPIClient_Base.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2014-2018, MyMonero.com\r\n//\r\n// All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without modification, are\r\n// permitted provided that the following conditions are met:\r\n//\r\n// 1. Redistributions of source code must retain the above copyright notice, this list of\r\n//\tconditions and the following disclaimer.\r\n//\r\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list\r\n//\tof conditions and the following disclaimer in the documentation and/or other\r\n//\tmaterials provided with the distribution.\r\n//\r\n// 3. Neither the name of the copyright holder nor the names of its contributors may be\r\n//\tused to endorse or promote products derived from this software without specific\r\n//\tprior written permission.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\r\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\r\n// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\r\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\n\r\n//\r\nconst async = __webpack_require__(/*! async */ \"./node_modules/async/dist/async.js\")\r\n//\r\nconst JSBigInt = __webpack_require__(/*! ../mymonero_core_js/cryptonote_utils/biginteger */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/biginteger.js\").BigInteger // important: grab defined export\r\nconst monero_config = __webpack_require__(/*! ../mymonero_core_js/monero_utils/monero_config */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_config.js\")\r\nconst net_service_utils = __webpack_require__(/*! ../mymonero_core_js/hostAPI/net_service_utils */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/hostAPI/net_service_utils.js\")\r\n//\r\nconst config__MyMonero = __webpack_require__(/*! ./config__MyMonero */ \"./libs/mymonero-app-js/local_modules/HostedMoneroAPIClient/config__MyMonero.js\")\r\n//\r\nclass HostedMoneroAPIClient_Base\r\n{\r\n\t//\r\n\t// Lifecycle - Initialization\r\n\tconstructor(options, context)\r\n\t{\r\n\t\tvar self = this\r\n\t\tself.options = options\r\n\t\tself.context = context\r\n\t\t//\r\n\t\tself.request = options.request_conformant_module\r\n\t\tif (!self.request) {\r\n\t\t\tthrow `${self.constructor.name} requires an options.request_conformant_module such as require('request' / 'xhr')`\r\n\t\t}\r\n\t\t//\r\n\t\tself.setup()\r\n\t}\r\n\tsetup()\r\n\t{\r\n\t\tvar self = this\r\n\t\t{ // options\r\n\t\t\tself.appUserAgent_product = self.options.appUserAgent_product\r\n\t\t\tif (!self.appUserAgent_product) {\r\n\t\t\t\tthrow `${self.constructor.name} requires options.appUserAgent_product`\r\n\t\t\t}\r\n\t\t\tself.appUserAgent_version = self.options.appUserAgent_version\r\n\t\t\tif (!self.appUserAgent_version) {\r\n\t\t\t\tthrow `${self.constructor.name} requires options.appUserAgent_version`\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t//\r\n\t// Runtime - Accessors - Private - Requests\r\n\t_new_apiAddress_authority() \r\n\t{ // overridable\r\n\t\treturn config__MyMonero.API__authority\r\n\t}\r\n\t//\r\n\t// Runtime - Accessors - Public - Requests\r\n\tLogIn(address, view_key__private, generated_locally, fn)\r\n\t{ // fn: (err?, new_address?) -> RequestHandle\r\n\t\tconst self = this\r\n\t\tconst endpointPath = \"login\"\r\n\t\tconst parameters = net_service_utils.New_ParametersForWalletRequest(address, view_key__private)\r\n\t\tparameters.create_account = true\r\n\t\tparameters.generated_locally = generated_locally\r\n\t\tconst requestHandle = net_service_utils.HTTPRequest(\r\n\t\t\tself.request,\r\n\t\t\tself._new_apiAddress_authority(),\r\n\t\t\tendpointPath, \r\n\t\t\tparameters,\r\n\t\t\tfunction(err, data)\r\n\t\t\t{\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\tfn(err)\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\t__proceedTo_parseAndCallBack(data)\r\n\t\t\t}\r\n\t\t)\r\n\t\tfunction __proceedTo_parseAndCallBack(data)\r\n\t\t{\r\n\t\t\tconst new_address = data.new_address\r\n\t\t\tconst received__generated_locally = data.generated_locally\r\n\t\t\tconst start_height = data.start_height\r\n\t\t\t// console.log(\"data from login: \", data)\r\n\t\t\t// TODO? parse anything else?\r\n\t\t\t//\r\n\t\t\tfn(null, new_address, received__generated_locally, start_height)\r\n\t\t}\r\n\t\treturn requestHandle\r\n\t}\r\n\t//\r\n\t// Syncing\r\n\tAddressInfo_returningRequestHandle(\r\n\t\taddress,\r\n\t\tview_key__private,\r\n\t\tspend_key__public,\r\n\t\tspend_key__private,\r\n\t\tfn\r\n\t) {  // -> RequestHandle\r\n\t\tconst self = this\r\n\t\tconst endpointPath = \"get_address_info\"\r\n\t\tconst parameters = net_service_utils.New_ParametersForWalletRequest(address, view_key__private)\r\n\t\tconst requestHandle = net_service_utils.HTTPRequest(\r\n\t\t\tself.request,\r\n\t\t\tself._new_apiAddress_authority(),\r\n\t\t\tendpointPath,\r\n\t\t\tparameters,\r\n\t\t\tfunction(err, data)\r\n\t\t\t{\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\tfn(err)\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\t__proceedTo_parseAndCallBack(data)\r\n\t\t\t}\r\n\t\t)\r\n\t\tfunction __proceedTo_parseAndCallBack(data)\r\n\t\t{\r\n\t\t\tself.context.backgroundAPIResponseParser.Parsed_AddressInfo(\r\n\t\t\t\t// key-image-managed - just be sure to dekete your wallet's key img cache when you tear down\r\n\t\t\t\tdata,\r\n\t\t\t\taddress,\r\n\t\t\t\tview_key__private,\r\n\t\t\t\tspend_key__public,\r\n\t\t\t\tspend_key__private,\r\n\t\t\t\tfunction(err, returnValuesByKey)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\tfn(err)\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar total_received_JSBigInt;\r\n\t\t\t\t\tconst total_received_String = returnValuesByKey.total_received_String\r\n\t\t\t\t\tif (total_received_String) {\r\n\t\t\t\t\t\ttotal_received_JSBigInt = new JSBigInt(total_received_String)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttotal_received_JSBigInt = new JSBigInt(0)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//\r\n\t\t\t\t\tvar locked_balance_JSBigInt;\r\n\t\t\t\t\tconst locked_balance_String = returnValuesByKey.locked_balance_String\r\n\t\t\t\t\tif (locked_balance_String) {\r\n\t\t\t\t\t\tlocked_balance_JSBigInt = new JSBigInt(locked_balance_String)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tlocked_balance_JSBigInt = new JSBigInt(0)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//\r\n\t\t\t\t\tvar total_sent_JSBigInt;\r\n\t\t\t\t\tconst total_sent_String = returnValuesByKey.total_sent_String\r\n\t\t\t\t\tif (total_sent_String) {\r\n\t\t\t\t\t\ttotal_sent_JSBigInt = new JSBigInt(total_sent_String)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttotal_sent_JSBigInt = new JSBigInt(0)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfn(\r\n\t\t\t\t\t\terr,\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\ttotal_received_JSBigInt,\r\n\t\t\t\t\t\tlocked_balance_JSBigInt,\r\n\t\t\t\t\t\ttotal_sent_JSBigInt,\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\treturnValuesByKey.spent_outputs,\r\n\t\t\t\t\t\treturnValuesByKey.account_scanned_tx_height,\r\n\t\t\t\t\t\treturnValuesByKey.account_scanned_block_height,\r\n\t\t\t\t\t\treturnValuesByKey.account_scan_start_height,\r\n\t\t\t\t\t\treturnValuesByKey.transaction_height,\r\n\t\t\t\t\t\treturnValuesByKey.blockchain_height,\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\treturnValuesByKey.ratesBySymbol\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t}\r\n\t\treturn requestHandle\r\n\t}\r\n\tAddressTransactions_returningRequestHandle(\r\n\t\taddress,\r\n\t\tview_key__private,\r\n\t\tspend_key__public,\r\n\t\tspend_key__private,\r\n\t\tfn\r\n\t) { // -> RequestHandle\r\n\t\tconst self = this\r\n\t\tconst endpointPath = \"get_address_txs\"\r\n\t\tconst parameters = net_service_utils.New_ParametersForWalletRequest(address, view_key__private)\r\n\t\tconst requestHandle = net_service_utils.HTTPRequest(\r\n\t\t\tself.request,\r\n\t\t\tself._new_apiAddress_authority(),\r\n\t\t\tendpointPath,\r\n\t\t\tparameters,\r\n\t\t\tfunction(err, data)\r\n\t\t\t{\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\tfn(err)\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\t__parseAndCallBack(data)\r\n\t\t\t}\r\n\t\t)\r\n\t\tfunction __parseAndCallBack(data)\r\n\t\t{\r\n\t\t\tself.context.backgroundAPIResponseParser.Parsed_AddressTransactions(\r\n\t\t\t\tdata,\r\n\t\t\t\taddress,\r\n\t\t\t\tview_key__private,\r\n\t\t\t\tspend_key__public,\r\n\t\t\t\tspend_key__private,\r\n\t\t\t\tfunction(err, returnValuesByKey)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\tfn(err)\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//\r\n\t\t\t\t\tconst transactions = returnValuesByKey.serialized_transactions\r\n\t\t\t\t\tfor (let transaction of transactions) {\r\n\t\t\t\t\t\ttransaction.amount = new JSBigInt(transaction.amount)\r\n\t\t\t\t\t\tif (typeof transaction.total_sent !== 'undefined' && transaction.total_sent !== null) {\r\n\t\t\t\t\t\t\ttransaction.total_sent = new JSBigInt(transaction.total_sent)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttransaction.timestamp = new Date(transaction.timestamp)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//\r\n\t\t\t\t\tfn(\r\n\t\t\t\t\t\terr,\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\treturnValuesByKey.account_scanned_height,\r\n\t\t\t\t\t\treturnValuesByKey.account_scanned_block_height,\r\n\t\t\t\t\t\treturnValuesByKey.account_scan_start_height,\r\n\t\t\t\t\t\treturnValuesByKey.transaction_height,\r\n\t\t\t\t\t\treturnValuesByKey.blockchain_height,\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\ttransactions\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t}\r\n\t\treturn requestHandle\r\n\t}\r\n\t//\r\n\t// Getting wallet txs import info\r\n\tImportRequestInfoAndStatus(\r\n\t\taddress,\r\n\t\tview_key__private,\r\n\t\tfn\r\n\t) { // -> RequestHandle\r\n\t\tconst self = this\r\n\t\tconst endpointPath = \"import_wallet_request\"\r\n\t\tconst parameters = net_service_utils.New_ParametersForWalletRequest(address, view_key__private)\r\n\t\tnet_service_utils.AddUserAgentParamters(\r\n\t\t\tparameters,\r\n\t\t\tself.appUserAgent_product, \r\n\t\t\tself.appUserAgent_version\r\n\t\t)\r\n\t\tconst requestHandle = net_service_utils.HTTPRequest(\r\n\t\t\tself.request,\r\n\t\t\tself._new_apiAddress_authority(),\r\n\t\t\tendpointPath,\r\n\t\t\tparameters,\r\n\t\t\tfunction(err, data)\r\n\t\t\t{\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\tfn(err)\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\t__proceedTo_parseAndCallBack(data)\r\n\t\t\t}\r\n\t\t)\r\n\t\tfunction __proceedTo_parseAndCallBack(data)\r\n\t\t{\r\n\t\t\tconst payment_id = data.payment_id;\r\n\t\t\tconst payment_address = data.payment_address;\r\n\t\t\tconst import_fee__JSBigInt = new JSBigInt(data.import_fee);\r\n\t\t\tconst feeReceiptStatus = data.status;\r\n\t\t\tfn(\r\n\t\t\t\tnull, \r\n\t\t\t\tpayment_id, \r\n\t\t\t\tpayment_address, \r\n\t\t\t\timport_fee__JSBigInt, \r\n\t\t\t\tfeeReceiptStatus\r\n\t\t\t)\r\n\t\t}\r\n\t\treturn requestHandle\r\n\t}\r\n\t\r\n\t//\r\n\t// Getting outputs for sending funds\r\n\tUnspentOuts(\r\n\t\taddress,\r\n\t\tview_key__private,\r\n\t\tspend_key__public,\r\n\t\tspend_key__private,\r\n\t\tmixinNumber,\r\n\t\tsweeping,\r\n\t\tfn\r\n\t) { // -> RequestHandle\r\n\t\tconst self = this\r\n\t\tmixinNumber = parseInt(mixinNumber) // jic\r\n\t\t//\r\n\t\tconst endpointPath = 'get_unspent_outs'\r\n\t\tconst parameters = net_service_utils.New_ParametersForWalletRequest(address, view_key__private)\r\n\t\tparameters.amount = '0'\r\n\t\tparameters.mixin = mixinNumber\r\n\t\tparameters.use_dust = true // Client now filters unmixable by dustthreshold amount (unless sweeping) + non-rct \r\n\t\tparameters.dust_threshold = monero_config.dustThreshold.toString()\r\n\t\tnet_service_utils.AddUserAgentParamters(\r\n\t\t\tparameters,\r\n\t\t\tself.appUserAgent_product, \r\n\t\t\tself.appUserAgent_version\r\n\t\t)\r\n\t\tconst requestHandle = net_service_utils.HTTPRequest(\r\n\t\t\tself.request,\r\n\t\t\tself._new_apiAddress_authority(),\r\n\t\t\tendpointPath,\r\n\t\t\tparameters,\r\n\t\t\tfunction(err, data)\r\n\t\t\t{\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\tfn(err)\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\t__proceedTo_parseAndCallBack(data)\r\n\t\t\t}\r\n\t\t)\r\n\t\tfunction __proceedTo_parseAndCallBack(data)\r\n\t\t{\r\n\t\t\tself.context.backgroundAPIResponseParser.Parsed_UnspentOuts(\r\n\t\t\t\tdata,\r\n\t\t\t\taddress,\r\n\t\t\t\tview_key__private,\r\n\t\t\t\tspend_key__public,\r\n\t\t\t\tspend_key__private,\r\n\t\t\t\tfunction(err, returnValuesByKey)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\tfn(err)\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!returnValuesByKey.per_byte_fee__string || typeof returnValuesByKey.per_byte_fee__string === 'undefined') {\r\n\t\t\t\t\t\tthrow \"Unexpected / missing per_kb_fee\"\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfn(\r\n\t\t\t\t\t\terr, // no error\r\n\t\t\t\t\t\treturnValuesByKey.unspentOutputs, \r\n\t\t\t\t\t\treturnValuesByKey.per_byte_fee__string\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t}\r\n\t\treturn requestHandle\r\n\t}\r\n\tRandomOuts(\r\n\t\tusing_outs,\r\n\t\tmixinNumber,\r\n\t\tfn\r\n\t) { // -> RequestHandle\r\n\t\tconst self = this\r\n\t\t//\r\n\t\tmixinNumber = parseInt(mixinNumber)\r\n\t\tif (mixinNumber < 0 || isNaN(mixinNumber)) {\r\n\t\t\tconst errStr = \"Invalid mixin - must be >= 0\"\r\n\t\t\tconst err = new Error(errStr)\r\n\t\t\tfn(err)\r\n\t\t\treturn\r\n\t\t}\r\n\t\t//\r\n\t\tvar amounts = [];\r\n\t\tfor (var l = 0; l < using_outs.length; l++) {\r\n\t\t\tamounts.push(using_outs[l].rct ? \"0\" : using_outs[l].amount.toString())\r\n\t\t}\r\n\t\t//\r\n\t\tconst endpointPath = 'get_random_outs'\r\n\t\tvar parameters =\r\n\t\t{\r\n\t\t\tamounts: amounts,\r\n\t\t\tcount: mixinNumber + 1 // Add one to mixin so we can skip real output key if necessary\r\n\t\t}\r\n\t\tnet_service_utils.AddUserAgentParamters(\r\n\t\t\tparameters,\r\n\t\t\tself.appUserAgent_product, \r\n\t\t\tself.appUserAgent_version\r\n\t\t)\r\n\t\tconst requestHandle = net_service_utils.HTTPRequest(\r\n\t\t\tself.request,\r\n\t\t\tself._new_apiAddress_authority(),\r\n\t\t\tendpointPath,\r\n\t\t\tparameters,\r\n\t\t\tfunction(err, data)\r\n\t\t\t{\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\tfn(err)\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\t__proceedTo_parseAndCallBack(data)\r\n\t\t\t}\r\n\t\t)\r\n\t\tfunction __proceedTo_parseAndCallBack(data)\r\n\t\t{\r\n\t\t\t// console.log(\"debug: info: random outs: data\", data)\r\n\t\t\tconst amount_outs = data.amount_outs\r\n\t\t\t// yield\r\n\t\t\tfn(\r\n\t\t\t\tnull, // no error\r\n\t\t\t\tamount_outs\r\n\t\t\t)\r\n\t\t}\r\n\t\treturn requestHandle\r\n\t}\r\n\t//\r\n\t// Runtime - Imperatives - Public - Sending funds\r\n\tSubmitSerializedSignedTransaction(\r\n\t\taddress,\r\n\t\tview_key__private,\r\n\t\tserializedSignedTx,\r\n\t\tfn // (err?) -> RequestHandle\r\n\t)\r\n\t{\r\n\t\tconst self = this\r\n\t\t// just a debug feature:\r\n\t\tif (self.context.HostedMoneroAPIClient_DEBUGONLY_mockSendTransactionSuccess === true) {\r\n\t\t\tif (self.context.isDebug === true) {\r\n\t\t\t\tconsole.warn(\"  WARNING: Mocking that SubmitSerializedSignedTransaction returned a success response w/o having hit the server.\")\r\n\t\t\t\tfn(null)\r\n\t\t\t\treturn\r\n\t\t\t} else {\r\n\t\t\t\tthrow `[${self.constructor.name}/SubmitSerializedSignedTransaction]: context.HostedMoneroAPIClient_DEBUGONLY_mockSendTransactionSuccess was true despite isDebug not being true. Set back to false for production build.`\r\n\t\t\t}\r\n\t\t}\r\n\t\t// actual implementation:\r\n\t\tconst endpointPath = 'submit_raw_tx'\r\n\t\tconst parameters = net_service_utils.New_ParametersForWalletRequest(address, view_key__private)\r\n\t\tparameters.tx = serializedSignedTx\r\n\t\tnet_service_utils.AddUserAgentParamters(\r\n\t\t\tparameters,\r\n\t\t\tself.appUserAgent_product, \r\n\t\t\tself.appUserAgent_version\r\n\t\t)\r\n\t\tconst requestHandle = net_service_utils.HTTPRequest(\r\n\t\t\tself.request,\r\n\t\t\tself._new_apiAddress_authority(),\r\n\t\t\tendpointPath,\r\n\t\t\tparameters,\r\n\t\t\tfunction(err, data)\r\n\t\t\t{\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\tfn(err)\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\t__proceedTo_parseAndCallBack(data)\r\n\t\t\t}\r\n\t\t)\r\n\t\tfunction __proceedTo_parseAndCallBack(data)\r\n\t\t{\r\n\t\t\t// console.log(\"debug: info: submit_raw_tx: data\", data)\r\n\t\t\tfn(null)\r\n\t\t}\r\n\t\treturn requestHandle\r\n\t}\r\n}\r\nmodule.exports = HostedMoneroAPIClient_Base//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL0hvc3RlZE1vbmVyb0FQSUNsaWVudC9Ib3N0ZWRNb25lcm9BUElDbGllbnRfQmFzZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYnMvbXltb25lcm8tYXBwLWpzL2xvY2FsX21vZHVsZXMvSG9zdGVkTW9uZXJvQVBJQ2xpZW50L0hvc3RlZE1vbmVyb0FQSUNsaWVudF9CYXNlLmpzP2RlZGUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTgsIE15TW9uZXJvLmNvbVxyXG4vL1xyXG4vLyBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vL1xyXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmVcclxuLy8gcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbi8vXHJcbi8vIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mXHJcbi8vXHRjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbi8vXHJcbi8vIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0XHJcbi8vXHRvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyXHJcbi8vXHRtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4vL1xyXG4vLyAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBjb3B5cmlnaHQgaG9sZGVyIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmVcclxuLy9cdHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWNcclxuLy9cdHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuLy9cclxuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EIEFOWVxyXG4vLyBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcclxuLy8gTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTExcclxuLy8gVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXHJcbi8vIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcclxuLy8gUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXHJcbi8vIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxyXG4vLyBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcclxuLy8gVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG5cclxuXCJ1c2Ugc3RyaWN0XCJcclxuLy9cclxuY29uc3QgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpXHJcbi8vXHJcbmNvbnN0IEpTQmlnSW50ID0gcmVxdWlyZSgnLi4vbXltb25lcm9fY29yZV9qcy9jcnlwdG9ub3RlX3V0aWxzL2JpZ2ludGVnZXInKS5CaWdJbnRlZ2VyIC8vIGltcG9ydGFudDogZ3JhYiBkZWZpbmVkIGV4cG9ydFxyXG5jb25zdCBtb25lcm9fY29uZmlnID0gcmVxdWlyZSgnLi4vbXltb25lcm9fY29yZV9qcy9tb25lcm9fdXRpbHMvbW9uZXJvX2NvbmZpZycpXHJcbmNvbnN0IG5ldF9zZXJ2aWNlX3V0aWxzID0gcmVxdWlyZSgnLi4vbXltb25lcm9fY29yZV9qcy9ob3N0QVBJL25ldF9zZXJ2aWNlX3V0aWxzJylcclxuLy9cclxuY29uc3QgY29uZmlnX19NeU1vbmVybyA9IHJlcXVpcmUoJy4vY29uZmlnX19NeU1vbmVybycpXHJcbi8vXHJcbmNsYXNzIEhvc3RlZE1vbmVyb0FQSUNsaWVudF9CYXNlXHJcbntcclxuXHQvL1xyXG5cdC8vIExpZmVjeWNsZSAtIEluaXRpYWxpemF0aW9uXHJcblx0Y29uc3RydWN0b3Iob3B0aW9ucywgY29udGV4dClcclxuXHR7XHJcblx0XHR2YXIgc2VsZiA9IHRoaXNcclxuXHRcdHNlbGYub3B0aW9ucyA9IG9wdGlvbnNcclxuXHRcdHNlbGYuY29udGV4dCA9IGNvbnRleHRcclxuXHRcdC8vXHJcblx0XHRzZWxmLnJlcXVlc3QgPSBvcHRpb25zLnJlcXVlc3RfY29uZm9ybWFudF9tb2R1bGVcclxuXHRcdGlmICghc2VsZi5yZXF1ZXN0KSB7XHJcblx0XHRcdHRocm93IGAke3NlbGYuY29uc3RydWN0b3IubmFtZX0gcmVxdWlyZXMgYW4gb3B0aW9ucy5yZXF1ZXN0X2NvbmZvcm1hbnRfbW9kdWxlIHN1Y2ggYXMgcmVxdWlyZSgncmVxdWVzdCcgLyAneGhyJylgXHJcblx0XHR9XHJcblx0XHQvL1xyXG5cdFx0c2VsZi5zZXR1cCgpXHJcblx0fVxyXG5cdHNldHVwKClcclxuXHR7XHJcblx0XHR2YXIgc2VsZiA9IHRoaXNcclxuXHRcdHsgLy8gb3B0aW9uc1xyXG5cdFx0XHRzZWxmLmFwcFVzZXJBZ2VudF9wcm9kdWN0ID0gc2VsZi5vcHRpb25zLmFwcFVzZXJBZ2VudF9wcm9kdWN0XHJcblx0XHRcdGlmICghc2VsZi5hcHBVc2VyQWdlbnRfcHJvZHVjdCkge1xyXG5cdFx0XHRcdHRocm93IGAke3NlbGYuY29uc3RydWN0b3IubmFtZX0gcmVxdWlyZXMgb3B0aW9ucy5hcHBVc2VyQWdlbnRfcHJvZHVjdGBcclxuXHRcdFx0fVxyXG5cdFx0XHRzZWxmLmFwcFVzZXJBZ2VudF92ZXJzaW9uID0gc2VsZi5vcHRpb25zLmFwcFVzZXJBZ2VudF92ZXJzaW9uXHJcblx0XHRcdGlmICghc2VsZi5hcHBVc2VyQWdlbnRfdmVyc2lvbikge1xyXG5cdFx0XHRcdHRocm93IGAke3NlbGYuY29uc3RydWN0b3IubmFtZX0gcmVxdWlyZXMgb3B0aW9ucy5hcHBVc2VyQWdlbnRfdmVyc2lvbmBcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHQvL1xyXG5cdC8vIFJ1bnRpbWUgLSBBY2Nlc3NvcnMgLSBQcml2YXRlIC0gUmVxdWVzdHNcclxuXHRfbmV3X2FwaUFkZHJlc3NfYXV0aG9yaXR5KCkgXHJcblx0eyAvLyBvdmVycmlkYWJsZVxyXG5cdFx0cmV0dXJuIGNvbmZpZ19fTXlNb25lcm8uQVBJX19hdXRob3JpdHlcclxuXHR9XHJcblx0Ly9cclxuXHQvLyBSdW50aW1lIC0gQWNjZXNzb3JzIC0gUHVibGljIC0gUmVxdWVzdHNcclxuXHRMb2dJbihhZGRyZXNzLCB2aWV3X2tleV9fcHJpdmF0ZSwgZ2VuZXJhdGVkX2xvY2FsbHksIGZuKVxyXG5cdHsgLy8gZm46IChlcnI/LCBuZXdfYWRkcmVzcz8pIC0+IFJlcXVlc3RIYW5kbGVcclxuXHRcdGNvbnN0IHNlbGYgPSB0aGlzXHJcblx0XHRjb25zdCBlbmRwb2ludFBhdGggPSBcImxvZ2luXCJcclxuXHRcdGNvbnN0IHBhcmFtZXRlcnMgPSBuZXRfc2VydmljZV91dGlscy5OZXdfUGFyYW1ldGVyc0ZvcldhbGxldFJlcXVlc3QoYWRkcmVzcywgdmlld19rZXlfX3ByaXZhdGUpXHJcblx0XHRwYXJhbWV0ZXJzLmNyZWF0ZV9hY2NvdW50ID0gdHJ1ZVxyXG5cdFx0cGFyYW1ldGVycy5nZW5lcmF0ZWRfbG9jYWxseSA9IGdlbmVyYXRlZF9sb2NhbGx5XHJcblx0XHRjb25zdCByZXF1ZXN0SGFuZGxlID0gbmV0X3NlcnZpY2VfdXRpbHMuSFRUUFJlcXVlc3QoXHJcblx0XHRcdHNlbGYucmVxdWVzdCxcclxuXHRcdFx0c2VsZi5fbmV3X2FwaUFkZHJlc3NfYXV0aG9yaXR5KCksXHJcblx0XHRcdGVuZHBvaW50UGF0aCwgXHJcblx0XHRcdHBhcmFtZXRlcnMsXHJcblx0XHRcdGZ1bmN0aW9uKGVyciwgZGF0YSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGlmIChlcnIpIHtcclxuXHRcdFx0XHRcdGZuKGVycilcclxuXHRcdFx0XHRcdHJldHVyblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRfX3Byb2NlZWRUb19wYXJzZUFuZENhbGxCYWNrKGRhdGEpXHJcblx0XHRcdH1cclxuXHRcdClcclxuXHRcdGZ1bmN0aW9uIF9fcHJvY2VlZFRvX3BhcnNlQW5kQ2FsbEJhY2soZGF0YSlcclxuXHRcdHtcclxuXHRcdFx0Y29uc3QgbmV3X2FkZHJlc3MgPSBkYXRhLm5ld19hZGRyZXNzXHJcblx0XHRcdGNvbnN0IHJlY2VpdmVkX19nZW5lcmF0ZWRfbG9jYWxseSA9IGRhdGEuZ2VuZXJhdGVkX2xvY2FsbHlcclxuXHRcdFx0Y29uc3Qgc3RhcnRfaGVpZ2h0ID0gZGF0YS5zdGFydF9oZWlnaHRcclxuXHRcdFx0Ly8gY29uc29sZS5sb2coXCJkYXRhIGZyb20gbG9naW46IFwiLCBkYXRhKVxyXG5cdFx0XHQvLyBUT0RPPyBwYXJzZSBhbnl0aGluZyBlbHNlP1xyXG5cdFx0XHQvL1xyXG5cdFx0XHRmbihudWxsLCBuZXdfYWRkcmVzcywgcmVjZWl2ZWRfX2dlbmVyYXRlZF9sb2NhbGx5LCBzdGFydF9oZWlnaHQpXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVxdWVzdEhhbmRsZVxyXG5cdH1cclxuXHQvL1xyXG5cdC8vIFN5bmNpbmdcclxuXHRBZGRyZXNzSW5mb19yZXR1cm5pbmdSZXF1ZXN0SGFuZGxlKFxyXG5cdFx0YWRkcmVzcyxcclxuXHRcdHZpZXdfa2V5X19wcml2YXRlLFxyXG5cdFx0c3BlbmRfa2V5X19wdWJsaWMsXHJcblx0XHRzcGVuZF9rZXlfX3ByaXZhdGUsXHJcblx0XHRmblxyXG5cdCkgeyAgLy8gLT4gUmVxdWVzdEhhbmRsZVxyXG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXNcclxuXHRcdGNvbnN0IGVuZHBvaW50UGF0aCA9IFwiZ2V0X2FkZHJlc3NfaW5mb1wiXHJcblx0XHRjb25zdCBwYXJhbWV0ZXJzID0gbmV0X3NlcnZpY2VfdXRpbHMuTmV3X1BhcmFtZXRlcnNGb3JXYWxsZXRSZXF1ZXN0KGFkZHJlc3MsIHZpZXdfa2V5X19wcml2YXRlKVxyXG5cdFx0Y29uc3QgcmVxdWVzdEhhbmRsZSA9IG5ldF9zZXJ2aWNlX3V0aWxzLkhUVFBSZXF1ZXN0KFxyXG5cdFx0XHRzZWxmLnJlcXVlc3QsXHJcblx0XHRcdHNlbGYuX25ld19hcGlBZGRyZXNzX2F1dGhvcml0eSgpLFxyXG5cdFx0XHRlbmRwb2ludFBhdGgsXHJcblx0XHRcdHBhcmFtZXRlcnMsXHJcblx0XHRcdGZ1bmN0aW9uKGVyciwgZGF0YSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGlmIChlcnIpIHtcclxuXHRcdFx0XHRcdGZuKGVycilcclxuXHRcdFx0XHRcdHJldHVyblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRfX3Byb2NlZWRUb19wYXJzZUFuZENhbGxCYWNrKGRhdGEpXHJcblx0XHRcdH1cclxuXHRcdClcclxuXHRcdGZ1bmN0aW9uIF9fcHJvY2VlZFRvX3BhcnNlQW5kQ2FsbEJhY2soZGF0YSlcclxuXHRcdHtcclxuXHRcdFx0c2VsZi5jb250ZXh0LmJhY2tncm91bmRBUElSZXNwb25zZVBhcnNlci5QYXJzZWRfQWRkcmVzc0luZm8oXHJcblx0XHRcdFx0Ly8ga2V5LWltYWdlLW1hbmFnZWQgLSBqdXN0IGJlIHN1cmUgdG8gZGVrZXRlIHlvdXIgd2FsbGV0J3Mga2V5IGltZyBjYWNoZSB3aGVuIHlvdSB0ZWFyIGRvd25cclxuXHRcdFx0XHRkYXRhLFxyXG5cdFx0XHRcdGFkZHJlc3MsXHJcblx0XHRcdFx0dmlld19rZXlfX3ByaXZhdGUsXHJcblx0XHRcdFx0c3BlbmRfa2V5X19wdWJsaWMsXHJcblx0XHRcdFx0c3BlbmRfa2V5X19wcml2YXRlLFxyXG5cdFx0XHRcdGZ1bmN0aW9uKGVyciwgcmV0dXJuVmFsdWVzQnlLZXkpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0aWYgKGVycikge1xyXG5cdFx0XHRcdFx0XHRmbihlcnIpXHJcblx0XHRcdFx0XHRcdHJldHVyblxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dmFyIHRvdGFsX3JlY2VpdmVkX0pTQmlnSW50O1xyXG5cdFx0XHRcdFx0Y29uc3QgdG90YWxfcmVjZWl2ZWRfU3RyaW5nID0gcmV0dXJuVmFsdWVzQnlLZXkudG90YWxfcmVjZWl2ZWRfU3RyaW5nXHJcblx0XHRcdFx0XHRpZiAodG90YWxfcmVjZWl2ZWRfU3RyaW5nKSB7XHJcblx0XHRcdFx0XHRcdHRvdGFsX3JlY2VpdmVkX0pTQmlnSW50ID0gbmV3IEpTQmlnSW50KHRvdGFsX3JlY2VpdmVkX1N0cmluZylcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRvdGFsX3JlY2VpdmVkX0pTQmlnSW50ID0gbmV3IEpTQmlnSW50KDApXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHQvL1xyXG5cdFx0XHRcdFx0dmFyIGxvY2tlZF9iYWxhbmNlX0pTQmlnSW50O1xyXG5cdFx0XHRcdFx0Y29uc3QgbG9ja2VkX2JhbGFuY2VfU3RyaW5nID0gcmV0dXJuVmFsdWVzQnlLZXkubG9ja2VkX2JhbGFuY2VfU3RyaW5nXHJcblx0XHRcdFx0XHRpZiAobG9ja2VkX2JhbGFuY2VfU3RyaW5nKSB7XHJcblx0XHRcdFx0XHRcdGxvY2tlZF9iYWxhbmNlX0pTQmlnSW50ID0gbmV3IEpTQmlnSW50KGxvY2tlZF9iYWxhbmNlX1N0cmluZylcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGxvY2tlZF9iYWxhbmNlX0pTQmlnSW50ID0gbmV3IEpTQmlnSW50KDApXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHQvL1xyXG5cdFx0XHRcdFx0dmFyIHRvdGFsX3NlbnRfSlNCaWdJbnQ7XHJcblx0XHRcdFx0XHRjb25zdCB0b3RhbF9zZW50X1N0cmluZyA9IHJldHVyblZhbHVlc0J5S2V5LnRvdGFsX3NlbnRfU3RyaW5nXHJcblx0XHRcdFx0XHRpZiAodG90YWxfc2VudF9TdHJpbmcpIHtcclxuXHRcdFx0XHRcdFx0dG90YWxfc2VudF9KU0JpZ0ludCA9IG5ldyBKU0JpZ0ludCh0b3RhbF9zZW50X1N0cmluZylcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRvdGFsX3NlbnRfSlNCaWdJbnQgPSBuZXcgSlNCaWdJbnQoMClcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGZuKFxyXG5cdFx0XHRcdFx0XHRlcnIsXHJcblx0XHRcdFx0XHRcdC8vXHJcblx0XHRcdFx0XHRcdHRvdGFsX3JlY2VpdmVkX0pTQmlnSW50LFxyXG5cdFx0XHRcdFx0XHRsb2NrZWRfYmFsYW5jZV9KU0JpZ0ludCxcclxuXHRcdFx0XHRcdFx0dG90YWxfc2VudF9KU0JpZ0ludCxcclxuXHRcdFx0XHRcdFx0Ly9cclxuXHRcdFx0XHRcdFx0cmV0dXJuVmFsdWVzQnlLZXkuc3BlbnRfb3V0cHV0cyxcclxuXHRcdFx0XHRcdFx0cmV0dXJuVmFsdWVzQnlLZXkuYWNjb3VudF9zY2FubmVkX3R4X2hlaWdodCxcclxuXHRcdFx0XHRcdFx0cmV0dXJuVmFsdWVzQnlLZXkuYWNjb3VudF9zY2FubmVkX2Jsb2NrX2hlaWdodCxcclxuXHRcdFx0XHRcdFx0cmV0dXJuVmFsdWVzQnlLZXkuYWNjb3VudF9zY2FuX3N0YXJ0X2hlaWdodCxcclxuXHRcdFx0XHRcdFx0cmV0dXJuVmFsdWVzQnlLZXkudHJhbnNhY3Rpb25faGVpZ2h0LFxyXG5cdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZXNCeUtleS5ibG9ja2NoYWluX2hlaWdodCxcclxuXHRcdFx0XHRcdFx0Ly9cclxuXHRcdFx0XHRcdFx0cmV0dXJuVmFsdWVzQnlLZXkucmF0ZXNCeVN5bWJvbFxyXG5cdFx0XHRcdFx0KVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0KVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlcXVlc3RIYW5kbGVcclxuXHR9XHJcblx0QWRkcmVzc1RyYW5zYWN0aW9uc19yZXR1cm5pbmdSZXF1ZXN0SGFuZGxlKFxyXG5cdFx0YWRkcmVzcyxcclxuXHRcdHZpZXdfa2V5X19wcml2YXRlLFxyXG5cdFx0c3BlbmRfa2V5X19wdWJsaWMsXHJcblx0XHRzcGVuZF9rZXlfX3ByaXZhdGUsXHJcblx0XHRmblxyXG5cdCkgeyAvLyAtPiBSZXF1ZXN0SGFuZGxlXHJcblx0XHRjb25zdCBzZWxmID0gdGhpc1xyXG5cdFx0Y29uc3QgZW5kcG9pbnRQYXRoID0gXCJnZXRfYWRkcmVzc190eHNcIlxyXG5cdFx0Y29uc3QgcGFyYW1ldGVycyA9IG5ldF9zZXJ2aWNlX3V0aWxzLk5ld19QYXJhbWV0ZXJzRm9yV2FsbGV0UmVxdWVzdChhZGRyZXNzLCB2aWV3X2tleV9fcHJpdmF0ZSlcclxuXHRcdGNvbnN0IHJlcXVlc3RIYW5kbGUgPSBuZXRfc2VydmljZV91dGlscy5IVFRQUmVxdWVzdChcclxuXHRcdFx0c2VsZi5yZXF1ZXN0LFxyXG5cdFx0XHRzZWxmLl9uZXdfYXBpQWRkcmVzc19hdXRob3JpdHkoKSxcclxuXHRcdFx0ZW5kcG9pbnRQYXRoLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLFxyXG5cdFx0XHRmdW5jdGlvbihlcnIsIGRhdGEpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRpZiAoZXJyKSB7XHJcblx0XHRcdFx0XHRmbihlcnIpXHJcblx0XHRcdFx0XHRyZXR1cm5cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0X19wYXJzZUFuZENhbGxCYWNrKGRhdGEpXHJcblx0XHRcdH1cclxuXHRcdClcclxuXHRcdGZ1bmN0aW9uIF9fcGFyc2VBbmRDYWxsQmFjayhkYXRhKVxyXG5cdFx0e1xyXG5cdFx0XHRzZWxmLmNvbnRleHQuYmFja2dyb3VuZEFQSVJlc3BvbnNlUGFyc2VyLlBhcnNlZF9BZGRyZXNzVHJhbnNhY3Rpb25zKFxyXG5cdFx0XHRcdGRhdGEsXHJcblx0XHRcdFx0YWRkcmVzcyxcclxuXHRcdFx0XHR2aWV3X2tleV9fcHJpdmF0ZSxcclxuXHRcdFx0XHRzcGVuZF9rZXlfX3B1YmxpYyxcclxuXHRcdFx0XHRzcGVuZF9rZXlfX3ByaXZhdGUsXHJcblx0XHRcdFx0ZnVuY3Rpb24oZXJyLCByZXR1cm5WYWx1ZXNCeUtleSlcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRpZiAoZXJyKSB7XHJcblx0XHRcdFx0XHRcdGZuKGVycilcclxuXHRcdFx0XHRcdFx0cmV0dXJuXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHQvL1xyXG5cdFx0XHRcdFx0Y29uc3QgdHJhbnNhY3Rpb25zID0gcmV0dXJuVmFsdWVzQnlLZXkuc2VyaWFsaXplZF90cmFuc2FjdGlvbnNcclxuXHRcdFx0XHRcdGZvciAobGV0IHRyYW5zYWN0aW9uIG9mIHRyYW5zYWN0aW9ucykge1xyXG5cdFx0XHRcdFx0XHR0cmFuc2FjdGlvbi5hbW91bnQgPSBuZXcgSlNCaWdJbnQodHJhbnNhY3Rpb24uYW1vdW50KVxyXG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHRyYW5zYWN0aW9uLnRvdGFsX3NlbnQgIT09ICd1bmRlZmluZWQnICYmIHRyYW5zYWN0aW9uLnRvdGFsX3NlbnQgIT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbi50b3RhbF9zZW50ID0gbmV3IEpTQmlnSW50KHRyYW5zYWN0aW9uLnRvdGFsX3NlbnQpXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0dHJhbnNhY3Rpb24udGltZXN0YW1wID0gbmV3IERhdGUodHJhbnNhY3Rpb24udGltZXN0YW1wKVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Ly9cclxuXHRcdFx0XHRcdGZuKFxyXG5cdFx0XHRcdFx0XHRlcnIsXHJcblx0XHRcdFx0XHRcdC8vXHJcblx0XHRcdFx0XHRcdHJldHVyblZhbHVlc0J5S2V5LmFjY291bnRfc2Nhbm5lZF9oZWlnaHQsXHJcblx0XHRcdFx0XHRcdHJldHVyblZhbHVlc0J5S2V5LmFjY291bnRfc2Nhbm5lZF9ibG9ja19oZWlnaHQsXHJcblx0XHRcdFx0XHRcdHJldHVyblZhbHVlc0J5S2V5LmFjY291bnRfc2Nhbl9zdGFydF9oZWlnaHQsXHJcblx0XHRcdFx0XHRcdHJldHVyblZhbHVlc0J5S2V5LnRyYW5zYWN0aW9uX2hlaWdodCxcclxuXHRcdFx0XHRcdFx0cmV0dXJuVmFsdWVzQnlLZXkuYmxvY2tjaGFpbl9oZWlnaHQsXHJcblx0XHRcdFx0XHRcdC8vXHJcblx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uc1xyXG5cdFx0XHRcdFx0KVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0KVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlcXVlc3RIYW5kbGVcclxuXHR9XHJcblx0Ly9cclxuXHQvLyBHZXR0aW5nIHdhbGxldCB0eHMgaW1wb3J0IGluZm9cclxuXHRJbXBvcnRSZXF1ZXN0SW5mb0FuZFN0YXR1cyhcclxuXHRcdGFkZHJlc3MsXHJcblx0XHR2aWV3X2tleV9fcHJpdmF0ZSxcclxuXHRcdGZuXHJcblx0KSB7IC8vIC0+IFJlcXVlc3RIYW5kbGVcclxuXHRcdGNvbnN0IHNlbGYgPSB0aGlzXHJcblx0XHRjb25zdCBlbmRwb2ludFBhdGggPSBcImltcG9ydF93YWxsZXRfcmVxdWVzdFwiXHJcblx0XHRjb25zdCBwYXJhbWV0ZXJzID0gbmV0X3NlcnZpY2VfdXRpbHMuTmV3X1BhcmFtZXRlcnNGb3JXYWxsZXRSZXF1ZXN0KGFkZHJlc3MsIHZpZXdfa2V5X19wcml2YXRlKVxyXG5cdFx0bmV0X3NlcnZpY2VfdXRpbHMuQWRkVXNlckFnZW50UGFyYW10ZXJzKFxyXG5cdFx0XHRwYXJhbWV0ZXJzLFxyXG5cdFx0XHRzZWxmLmFwcFVzZXJBZ2VudF9wcm9kdWN0LCBcclxuXHRcdFx0c2VsZi5hcHBVc2VyQWdlbnRfdmVyc2lvblxyXG5cdFx0KVxyXG5cdFx0Y29uc3QgcmVxdWVzdEhhbmRsZSA9IG5ldF9zZXJ2aWNlX3V0aWxzLkhUVFBSZXF1ZXN0KFxyXG5cdFx0XHRzZWxmLnJlcXVlc3QsXHJcblx0XHRcdHNlbGYuX25ld19hcGlBZGRyZXNzX2F1dGhvcml0eSgpLFxyXG5cdFx0XHRlbmRwb2ludFBhdGgsXHJcblx0XHRcdHBhcmFtZXRlcnMsXHJcblx0XHRcdGZ1bmN0aW9uKGVyciwgZGF0YSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGlmIChlcnIpIHtcclxuXHRcdFx0XHRcdGZuKGVycilcclxuXHRcdFx0XHRcdHJldHVyblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRfX3Byb2NlZWRUb19wYXJzZUFuZENhbGxCYWNrKGRhdGEpXHJcblx0XHRcdH1cclxuXHRcdClcclxuXHRcdGZ1bmN0aW9uIF9fcHJvY2VlZFRvX3BhcnNlQW5kQ2FsbEJhY2soZGF0YSlcclxuXHRcdHtcclxuXHRcdFx0Y29uc3QgcGF5bWVudF9pZCA9IGRhdGEucGF5bWVudF9pZDtcclxuXHRcdFx0Y29uc3QgcGF5bWVudF9hZGRyZXNzID0gZGF0YS5wYXltZW50X2FkZHJlc3M7XHJcblx0XHRcdGNvbnN0IGltcG9ydF9mZWVfX0pTQmlnSW50ID0gbmV3IEpTQmlnSW50KGRhdGEuaW1wb3J0X2ZlZSk7XHJcblx0XHRcdGNvbnN0IGZlZVJlY2VpcHRTdGF0dXMgPSBkYXRhLnN0YXR1cztcclxuXHRcdFx0Zm4oXHJcblx0XHRcdFx0bnVsbCwgXHJcblx0XHRcdFx0cGF5bWVudF9pZCwgXHJcblx0XHRcdFx0cGF5bWVudF9hZGRyZXNzLCBcclxuXHRcdFx0XHRpbXBvcnRfZmVlX19KU0JpZ0ludCwgXHJcblx0XHRcdFx0ZmVlUmVjZWlwdFN0YXR1c1xyXG5cdFx0XHQpXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVxdWVzdEhhbmRsZVxyXG5cdH1cclxuXHRcclxuXHQvL1xyXG5cdC8vIEdldHRpbmcgb3V0cHV0cyBmb3Igc2VuZGluZyBmdW5kc1xyXG5cdFVuc3BlbnRPdXRzKFxyXG5cdFx0YWRkcmVzcyxcclxuXHRcdHZpZXdfa2V5X19wcml2YXRlLFxyXG5cdFx0c3BlbmRfa2V5X19wdWJsaWMsXHJcblx0XHRzcGVuZF9rZXlfX3ByaXZhdGUsXHJcblx0XHRtaXhpbk51bWJlcixcclxuXHRcdHN3ZWVwaW5nLFxyXG5cdFx0Zm5cclxuXHQpIHsgLy8gLT4gUmVxdWVzdEhhbmRsZVxyXG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXNcclxuXHRcdG1peGluTnVtYmVyID0gcGFyc2VJbnQobWl4aW5OdW1iZXIpIC8vIGppY1xyXG5cdFx0Ly9cclxuXHRcdGNvbnN0IGVuZHBvaW50UGF0aCA9ICdnZXRfdW5zcGVudF9vdXRzJ1xyXG5cdFx0Y29uc3QgcGFyYW1ldGVycyA9IG5ldF9zZXJ2aWNlX3V0aWxzLk5ld19QYXJhbWV0ZXJzRm9yV2FsbGV0UmVxdWVzdChhZGRyZXNzLCB2aWV3X2tleV9fcHJpdmF0ZSlcclxuXHRcdHBhcmFtZXRlcnMuYW1vdW50ID0gJzAnXHJcblx0XHRwYXJhbWV0ZXJzLm1peGluID0gbWl4aW5OdW1iZXJcclxuXHRcdHBhcmFtZXRlcnMudXNlX2R1c3QgPSB0cnVlIC8vIENsaWVudCBub3cgZmlsdGVycyB1bm1peGFibGUgYnkgZHVzdHRocmVzaG9sZCBhbW91bnQgKHVubGVzcyBzd2VlcGluZykgKyBub24tcmN0IFxyXG5cdFx0cGFyYW1ldGVycy5kdXN0X3RocmVzaG9sZCA9IG1vbmVyb19jb25maWcuZHVzdFRocmVzaG9sZC50b1N0cmluZygpXHJcblx0XHRuZXRfc2VydmljZV91dGlscy5BZGRVc2VyQWdlbnRQYXJhbXRlcnMoXHJcblx0XHRcdHBhcmFtZXRlcnMsXHJcblx0XHRcdHNlbGYuYXBwVXNlckFnZW50X3Byb2R1Y3QsIFxyXG5cdFx0XHRzZWxmLmFwcFVzZXJBZ2VudF92ZXJzaW9uXHJcblx0XHQpXHJcblx0XHRjb25zdCByZXF1ZXN0SGFuZGxlID0gbmV0X3NlcnZpY2VfdXRpbHMuSFRUUFJlcXVlc3QoXHJcblx0XHRcdHNlbGYucmVxdWVzdCxcclxuXHRcdFx0c2VsZi5fbmV3X2FwaUFkZHJlc3NfYXV0aG9yaXR5KCksXHJcblx0XHRcdGVuZHBvaW50UGF0aCxcclxuXHRcdFx0cGFyYW1ldGVycyxcclxuXHRcdFx0ZnVuY3Rpb24oZXJyLCBkYXRhKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0aWYgKGVycikge1xyXG5cdFx0XHRcdFx0Zm4oZXJyKVxyXG5cdFx0XHRcdFx0cmV0dXJuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdF9fcHJvY2VlZFRvX3BhcnNlQW5kQ2FsbEJhY2soZGF0YSlcclxuXHRcdFx0fVxyXG5cdFx0KVxyXG5cdFx0ZnVuY3Rpb24gX19wcm9jZWVkVG9fcGFyc2VBbmRDYWxsQmFjayhkYXRhKVxyXG5cdFx0e1xyXG5cdFx0XHRzZWxmLmNvbnRleHQuYmFja2dyb3VuZEFQSVJlc3BvbnNlUGFyc2VyLlBhcnNlZF9VbnNwZW50T3V0cyhcclxuXHRcdFx0XHRkYXRhLFxyXG5cdFx0XHRcdGFkZHJlc3MsXHJcblx0XHRcdFx0dmlld19rZXlfX3ByaXZhdGUsXHJcblx0XHRcdFx0c3BlbmRfa2V5X19wdWJsaWMsXHJcblx0XHRcdFx0c3BlbmRfa2V5X19wcml2YXRlLFxyXG5cdFx0XHRcdGZ1bmN0aW9uKGVyciwgcmV0dXJuVmFsdWVzQnlLZXkpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0aWYgKGVycikge1xyXG5cdFx0XHRcdFx0XHRmbihlcnIpXHJcblx0XHRcdFx0XHRcdHJldHVyblxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCFyZXR1cm5WYWx1ZXNCeUtleS5wZXJfYnl0ZV9mZWVfX3N0cmluZyB8fCB0eXBlb2YgcmV0dXJuVmFsdWVzQnlLZXkucGVyX2J5dGVfZmVlX19zdHJpbmcgPT09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0XHRcdHRocm93IFwiVW5leHBlY3RlZCAvIG1pc3NpbmcgcGVyX2tiX2ZlZVwiXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRmbihcclxuXHRcdFx0XHRcdFx0ZXJyLCAvLyBubyBlcnJvclxyXG5cdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZXNCeUtleS51bnNwZW50T3V0cHV0cywgXHJcblx0XHRcdFx0XHRcdHJldHVyblZhbHVlc0J5S2V5LnBlcl9ieXRlX2ZlZV9fc3RyaW5nXHJcblx0XHRcdFx0XHQpXHJcblx0XHRcdFx0fVxyXG5cdFx0XHQpXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVxdWVzdEhhbmRsZVxyXG5cdH1cclxuXHRSYW5kb21PdXRzKFxyXG5cdFx0dXNpbmdfb3V0cyxcclxuXHRcdG1peGluTnVtYmVyLFxyXG5cdFx0Zm5cclxuXHQpIHsgLy8gLT4gUmVxdWVzdEhhbmRsZVxyXG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXNcclxuXHRcdC8vXHJcblx0XHRtaXhpbk51bWJlciA9IHBhcnNlSW50KG1peGluTnVtYmVyKVxyXG5cdFx0aWYgKG1peGluTnVtYmVyIDwgMCB8fCBpc05hTihtaXhpbk51bWJlcikpIHtcclxuXHRcdFx0Y29uc3QgZXJyU3RyID0gXCJJbnZhbGlkIG1peGluIC0gbXVzdCBiZSA+PSAwXCJcclxuXHRcdFx0Y29uc3QgZXJyID0gbmV3IEVycm9yKGVyclN0cilcclxuXHRcdFx0Zm4oZXJyKVxyXG5cdFx0XHRyZXR1cm5cclxuXHRcdH1cclxuXHRcdC8vXHJcblx0XHR2YXIgYW1vdW50cyA9IFtdO1xyXG5cdFx0Zm9yICh2YXIgbCA9IDA7IGwgPCB1c2luZ19vdXRzLmxlbmd0aDsgbCsrKSB7XHJcblx0XHRcdGFtb3VudHMucHVzaCh1c2luZ19vdXRzW2xdLnJjdCA/IFwiMFwiIDogdXNpbmdfb3V0c1tsXS5hbW91bnQudG9TdHJpbmcoKSlcclxuXHRcdH1cclxuXHRcdC8vXHJcblx0XHRjb25zdCBlbmRwb2ludFBhdGggPSAnZ2V0X3JhbmRvbV9vdXRzJ1xyXG5cdFx0dmFyIHBhcmFtZXRlcnMgPVxyXG5cdFx0e1xyXG5cdFx0XHRhbW91bnRzOiBhbW91bnRzLFxyXG5cdFx0XHRjb3VudDogbWl4aW5OdW1iZXIgKyAxIC8vIEFkZCBvbmUgdG8gbWl4aW4gc28gd2UgY2FuIHNraXAgcmVhbCBvdXRwdXQga2V5IGlmIG5lY2Vzc2FyeVxyXG5cdFx0fVxyXG5cdFx0bmV0X3NlcnZpY2VfdXRpbHMuQWRkVXNlckFnZW50UGFyYW10ZXJzKFxyXG5cdFx0XHRwYXJhbWV0ZXJzLFxyXG5cdFx0XHRzZWxmLmFwcFVzZXJBZ2VudF9wcm9kdWN0LCBcclxuXHRcdFx0c2VsZi5hcHBVc2VyQWdlbnRfdmVyc2lvblxyXG5cdFx0KVxyXG5cdFx0Y29uc3QgcmVxdWVzdEhhbmRsZSA9IG5ldF9zZXJ2aWNlX3V0aWxzLkhUVFBSZXF1ZXN0KFxyXG5cdFx0XHRzZWxmLnJlcXVlc3QsXHJcblx0XHRcdHNlbGYuX25ld19hcGlBZGRyZXNzX2F1dGhvcml0eSgpLFxyXG5cdFx0XHRlbmRwb2ludFBhdGgsXHJcblx0XHRcdHBhcmFtZXRlcnMsXHJcblx0XHRcdGZ1bmN0aW9uKGVyciwgZGF0YSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGlmIChlcnIpIHtcclxuXHRcdFx0XHRcdGZuKGVycilcclxuXHRcdFx0XHRcdHJldHVyblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRfX3Byb2NlZWRUb19wYXJzZUFuZENhbGxCYWNrKGRhdGEpXHJcblx0XHRcdH1cclxuXHRcdClcclxuXHRcdGZ1bmN0aW9uIF9fcHJvY2VlZFRvX3BhcnNlQW5kQ2FsbEJhY2soZGF0YSlcclxuXHRcdHtcclxuXHRcdFx0Ly8gY29uc29sZS5sb2coXCJkZWJ1ZzogaW5mbzogcmFuZG9tIG91dHM6IGRhdGFcIiwgZGF0YSlcclxuXHRcdFx0Y29uc3QgYW1vdW50X291dHMgPSBkYXRhLmFtb3VudF9vdXRzXHJcblx0XHRcdC8vIHlpZWxkXHJcblx0XHRcdGZuKFxyXG5cdFx0XHRcdG51bGwsIC8vIG5vIGVycm9yXHJcblx0XHRcdFx0YW1vdW50X291dHNcclxuXHRcdFx0KVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlcXVlc3RIYW5kbGVcclxuXHR9XHJcblx0Ly9cclxuXHQvLyBSdW50aW1lIC0gSW1wZXJhdGl2ZXMgLSBQdWJsaWMgLSBTZW5kaW5nIGZ1bmRzXHJcblx0U3VibWl0U2VyaWFsaXplZFNpZ25lZFRyYW5zYWN0aW9uKFxyXG5cdFx0YWRkcmVzcyxcclxuXHRcdHZpZXdfa2V5X19wcml2YXRlLFxyXG5cdFx0c2VyaWFsaXplZFNpZ25lZFR4LFxyXG5cdFx0Zm4gLy8gKGVycj8pIC0+IFJlcXVlc3RIYW5kbGVcclxuXHQpXHJcblx0e1xyXG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXNcclxuXHRcdC8vIGp1c3QgYSBkZWJ1ZyBmZWF0dXJlOlxyXG5cdFx0aWYgKHNlbGYuY29udGV4dC5Ib3N0ZWRNb25lcm9BUElDbGllbnRfREVCVUdPTkxZX21vY2tTZW5kVHJhbnNhY3Rpb25TdWNjZXNzID09PSB0cnVlKSB7XHJcblx0XHRcdGlmIChzZWxmLmNvbnRleHQuaXNEZWJ1ZyA9PT0gdHJ1ZSkge1xyXG5cdFx0XHRcdGNvbnNvbGUud2FybihcIuKaoO+4jyAgV0FSTklORzogTW9ja2luZyB0aGF0IFN1Ym1pdFNlcmlhbGl6ZWRTaWduZWRUcmFuc2FjdGlvbiByZXR1cm5lZCBhIHN1Y2Nlc3MgcmVzcG9uc2Ugdy9vIGhhdmluZyBoaXQgdGhlIHNlcnZlci5cIilcclxuXHRcdFx0XHRmbihudWxsKVxyXG5cdFx0XHRcdHJldHVyblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocm93IGBbJHtzZWxmLmNvbnN0cnVjdG9yLm5hbWV9L1N1Ym1pdFNlcmlhbGl6ZWRTaWduZWRUcmFuc2FjdGlvbl06IGNvbnRleHQuSG9zdGVkTW9uZXJvQVBJQ2xpZW50X0RFQlVHT05MWV9tb2NrU2VuZFRyYW5zYWN0aW9uU3VjY2VzcyB3YXMgdHJ1ZSBkZXNwaXRlIGlzRGVidWcgbm90IGJlaW5nIHRydWUuIFNldCBiYWNrIHRvIGZhbHNlIGZvciBwcm9kdWN0aW9uIGJ1aWxkLmBcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Ly8gYWN0dWFsIGltcGxlbWVudGF0aW9uOlxyXG5cdFx0Y29uc3QgZW5kcG9pbnRQYXRoID0gJ3N1Ym1pdF9yYXdfdHgnXHJcblx0XHRjb25zdCBwYXJhbWV0ZXJzID0gbmV0X3NlcnZpY2VfdXRpbHMuTmV3X1BhcmFtZXRlcnNGb3JXYWxsZXRSZXF1ZXN0KGFkZHJlc3MsIHZpZXdfa2V5X19wcml2YXRlKVxyXG5cdFx0cGFyYW1ldGVycy50eCA9IHNlcmlhbGl6ZWRTaWduZWRUeFxyXG5cdFx0bmV0X3NlcnZpY2VfdXRpbHMuQWRkVXNlckFnZW50UGFyYW10ZXJzKFxyXG5cdFx0XHRwYXJhbWV0ZXJzLFxyXG5cdFx0XHRzZWxmLmFwcFVzZXJBZ2VudF9wcm9kdWN0LCBcclxuXHRcdFx0c2VsZi5hcHBVc2VyQWdlbnRfdmVyc2lvblxyXG5cdFx0KVxyXG5cdFx0Y29uc3QgcmVxdWVzdEhhbmRsZSA9IG5ldF9zZXJ2aWNlX3V0aWxzLkhUVFBSZXF1ZXN0KFxyXG5cdFx0XHRzZWxmLnJlcXVlc3QsXHJcblx0XHRcdHNlbGYuX25ld19hcGlBZGRyZXNzX2F1dGhvcml0eSgpLFxyXG5cdFx0XHRlbmRwb2ludFBhdGgsXHJcblx0XHRcdHBhcmFtZXRlcnMsXHJcblx0XHRcdGZ1bmN0aW9uKGVyciwgZGF0YSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGlmIChlcnIpIHtcclxuXHRcdFx0XHRcdGZuKGVycilcclxuXHRcdFx0XHRcdHJldHVyblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRfX3Byb2NlZWRUb19wYXJzZUFuZENhbGxCYWNrKGRhdGEpXHJcblx0XHRcdH1cclxuXHRcdClcclxuXHRcdGZ1bmN0aW9uIF9fcHJvY2VlZFRvX3BhcnNlQW5kQ2FsbEJhY2soZGF0YSlcclxuXHRcdHtcclxuXHRcdFx0Ly8gY29uc29sZS5sb2coXCJkZWJ1ZzogaW5mbzogc3VibWl0X3Jhd190eDogZGF0YVwiLCBkYXRhKVxyXG5cdFx0XHRmbihudWxsKVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlcXVlc3RIYW5kbGVcclxuXHR9XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBIb3N0ZWRNb25lcm9BUElDbGllbnRfQmFzZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./libs/mymonero-app-js/local_modules/HostedMoneroAPIClient/HostedMoneroAPIClient_Base.js\n");

/***/ }),

/***/ "./libs/mymonero-app-js/local_modules/HostedMoneroAPIClient/config__MyMonero.js":
/*!**************************************************************************************!*\
  !*** ./libs/mymonero-app-js/local_modules/HostedMoneroAPIClient/config__MyMonero.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = \r\n{\r\n\tAPI__authority: \"api.mymonero.com:8443\"\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL0hvc3RlZE1vbmVyb0FQSUNsaWVudC9jb25maWdfX015TW9uZXJvLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGlicy9teW1vbmVyby1hcHAtanMvbG9jYWxfbW9kdWxlcy9Ib3N0ZWRNb25lcm9BUElDbGllbnQvY29uZmlnX19NeU1vbmVyby5qcz9lZGM0Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXHJcbntcclxuXHRBUElfX2F1dGhvcml0eTogXCJhcGkubXltb25lcm8uY29tOjg0NDNcIlxyXG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./libs/mymonero-app-js/local_modules/HostedMoneroAPIClient/config__MyMonero.js\n");

/***/ }),

/***/ "./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/biginteger.js":
/*!********************************************************************************************!*\
  !*** ./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/biginteger.js ***!
  \********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\r\n\tJavaScript BigInteger library version 0.9.1\r\n\thttp://silentmatt.com/biginteger/\r\n\r\n\tCopyright (c) 2009 Matthew Crumley <email@matthewcrumley.com>\r\n\tCopyright (c) 2010,2011 by John Tobey <John.Tobey@gmail.com>\r\n\tLicensed under the MIT license.\r\n\r\n\tSupport for arbitrary internal representation base was added by\r\n\tVitaly Magerya.\r\n*/\r\n/*\r\n\r\nThis file has been modified by Paul Shapiro:\r\n\r\n1. to bring in the function lowVal which was written by Lucas Jones\r\n2. to expose CONSTRUCT\r\n\r\n*/\r\n/*\r\n\tFile: biginteger.js\r\n\r\n\tExports:\r\n\r\n\t\t<BigInteger>\r\n*/\r\n(function(exports) {\r\n\"use strict\";\r\n/*\r\n\tClass: BigInteger\r\n\tAn arbitrarily-large integer.\r\n\r\n\t<BigInteger> objects should be considered immutable. None of the \"built-in\"\r\n\tmethods modify *this* or their arguments. All properties should be\r\n\tconsidered private.\r\n\r\n\tAll the methods of <BigInteger> instances can be called \"statically\". The\r\n\tstatic versions are convenient if you don't already have a <BigInteger>\r\n\tobject.\r\n\r\n\tAs an example, these calls are equivalent.\r\n\r\n\t> BigInteger(4).multiply(5); // returns BigInteger(20);\r\n\t> BigInteger.multiply(4, 5); // returns BigInteger(20);\r\n\r\n\t> var a = 42;\r\n\t> var a = BigInteger.toJSValue(\"0b101010\"); // Not completely useless...\r\n*/\r\n\r\nvar CONSTRUCT = {}; // Unique token to call \"private\" version of constructor\r\n\r\n/*\r\n\tConstructor: BigInteger()\r\n\tConvert a value to a <BigInteger>.\r\n\r\n\tAlthough <BigInteger()> is the constructor for <BigInteger> objects, it is\r\n\tbest not to call it as a constructor. If *n* is a <BigInteger> object, it is\r\n\tsimply returned as-is. Otherwise, <BigInteger()> is equivalent to <parse>\r\n\twithout a radix argument.\r\n\r\n\t> var n0 = BigInteger();\t  // Same as <BigInteger.ZERO>\r\n\t> var n1 = BigInteger(\"123\"); // Create a new <BigInteger> with value 123\r\n\t> var n2 = BigInteger(123);   // Create a new <BigInteger> with value 123\r\n\t> var n3 = BigInteger(n2);\t// Return n2, unchanged\r\n\r\n\tThe constructor form only takes an array and a sign. *n* must be an\r\n\tarray of numbers in little-endian order, where each digit is between 0\r\n\tand BigInteger.base.  The second parameter sets the sign: -1 for\r\n\tnegative, +1 for positive, or 0 for zero. The array is *not copied and\r\n\tmay be modified*. If the array contains only zeros, the sign parameter\r\n\tis ignored and is forced to zero.\r\n\r\n\t> new BigInteger([5], -1): create a new BigInteger with value -5\r\n\r\n\tParameters:\r\n\r\n\t\tn - Value to convert to a <BigInteger>.\r\n\r\n\tReturns:\r\n\r\n\t\tA <BigInteger> value.\r\n\r\n\tSee Also:\r\n\r\n\t\t<parse>, <BigInteger>\r\n*/\r\nfunction BigInteger(n, s, token) {\r\n\tif (token !== CONSTRUCT) {\r\n\t\tif (n instanceof BigInteger) {\r\n\t\t\treturn n;\r\n\t\t}\r\n\t\telse if (typeof n === \"undefined\") {\r\n\t\t\treturn ZERO;\r\n\t\t}\r\n\t\treturn BigInteger.parse(n);\r\n\t}\r\n\r\n\tn = n || [];  // Provide the nullary constructor for subclasses.\r\n\twhile (n.length && !n[n.length - 1]) {\r\n\t\t--n.length;\r\n\t}\r\n\tthis._d = n;\r\n\tthis._s = n.length ? (s || 1) : 0;\r\n}\r\nBigInteger.CONSTRUCT = CONSTRUCT; // added by PS to actually use the constructor\r\n\r\nBigInteger._construct = function(n, s) {\r\n\treturn new BigInteger(n, s, CONSTRUCT);\r\n};\r\n\r\n// Base-10 speedup hacks in parse, toString, exp10 and log functions\r\n// require base to be a power of 10. 10^7 is the largest such power\r\n// that won't cause a precision loss when digits are multiplied.\r\nvar BigInteger_base = 10000000;\r\nvar BigInteger_base_log10 = 7;\r\n\r\nBigInteger.base = BigInteger_base;\r\nBigInteger.base_log10 = BigInteger_base_log10;\r\n\r\nvar ZERO = new BigInteger([], 0, CONSTRUCT);\r\n// Constant: ZERO\r\n// <BigInteger> 0.\r\nBigInteger.ZERO = ZERO;\r\n\r\nvar ONE = new BigInteger([1], 1, CONSTRUCT);\r\n// Constant: ONE\r\n// <BigInteger> 1.\r\nBigInteger.ONE = ONE;\r\n\r\nvar M_ONE = new BigInteger(ONE._d, -1, CONSTRUCT);\r\n// Constant: M_ONE\r\n// <BigInteger> -1.\r\nBigInteger.M_ONE = M_ONE;\r\n\r\n// Constant: _0\r\n// Shortcut for <ZERO>.\r\nBigInteger._0 = ZERO;\r\n\r\n// Constant: _1\r\n// Shortcut for <ONE>.\r\nBigInteger._1 = ONE;\r\n\r\n/*\r\n\tConstant: small\r\n\tArray of <BigIntegers> from 0 to 36.\r\n\r\n\tThese are used internally for parsing, but useful when you need a \"small\"\r\n\t<BigInteger>.\r\n\r\n\tSee Also:\r\n\r\n\t\t<ZERO>, <ONE>, <_0>, <_1>\r\n*/\r\nBigInteger.small = [\r\n\tZERO,\r\n\tONE,\r\n\t/* Assuming BigInteger_base > 36 */\r\n\tnew BigInteger( [2], 1, CONSTRUCT),\r\n\tnew BigInteger( [3], 1, CONSTRUCT),\r\n\tnew BigInteger( [4], 1, CONSTRUCT),\r\n\tnew BigInteger( [5], 1, CONSTRUCT),\r\n\tnew BigInteger( [6], 1, CONSTRUCT),\r\n\tnew BigInteger( [7], 1, CONSTRUCT),\r\n\tnew BigInteger( [8], 1, CONSTRUCT),\r\n\tnew BigInteger( [9], 1, CONSTRUCT),\r\n\tnew BigInteger([10], 1, CONSTRUCT),\r\n\tnew BigInteger([11], 1, CONSTRUCT),\r\n\tnew BigInteger([12], 1, CONSTRUCT),\r\n\tnew BigInteger([13], 1, CONSTRUCT),\r\n\tnew BigInteger([14], 1, CONSTRUCT),\r\n\tnew BigInteger([15], 1, CONSTRUCT),\r\n\tnew BigInteger([16], 1, CONSTRUCT),\r\n\tnew BigInteger([17], 1, CONSTRUCT),\r\n\tnew BigInteger([18], 1, CONSTRUCT),\r\n\tnew BigInteger([19], 1, CONSTRUCT),\r\n\tnew BigInteger([20], 1, CONSTRUCT),\r\n\tnew BigInteger([21], 1, CONSTRUCT),\r\n\tnew BigInteger([22], 1, CONSTRUCT),\r\n\tnew BigInteger([23], 1, CONSTRUCT),\r\n\tnew BigInteger([24], 1, CONSTRUCT),\r\n\tnew BigInteger([25], 1, CONSTRUCT),\r\n\tnew BigInteger([26], 1, CONSTRUCT),\r\n\tnew BigInteger([27], 1, CONSTRUCT),\r\n\tnew BigInteger([28], 1, CONSTRUCT),\r\n\tnew BigInteger([29], 1, CONSTRUCT),\r\n\tnew BigInteger([30], 1, CONSTRUCT),\r\n\tnew BigInteger([31], 1, CONSTRUCT),\r\n\tnew BigInteger([32], 1, CONSTRUCT),\r\n\tnew BigInteger([33], 1, CONSTRUCT),\r\n\tnew BigInteger([34], 1, CONSTRUCT),\r\n\tnew BigInteger([35], 1, CONSTRUCT),\r\n\tnew BigInteger([36], 1, CONSTRUCT)\r\n];\r\n\r\n// Used for parsing/radix conversion\r\nBigInteger.digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\");\r\n\r\n/*\r\n\tMethod: toString\r\n\tConvert a <BigInteger> to a string.\r\n\r\n\tWhen *base* is greater than 10, letters are upper case.\r\n\r\n\tParameters:\r\n\r\n\t\tbase - Optional base to represent the number in (default is base 10).\r\n\t\t\t   Must be between 2 and 36 inclusive, or an Error will be thrown.\r\n\r\n\tReturns:\r\n\r\n\t\tThe string representation of the <BigInteger>.\r\n*/\r\nBigInteger.prototype.toString = function(base) {\r\n\tbase = +base || 10;\r\n\tif (base < 2 || base > 36) {\r\n\t\tthrow new Error(\"illegal radix \" + base + \".\");\r\n\t}\r\n\tif (this._s === 0) {\r\n\t\treturn \"0\";\r\n\t}\r\n\tif (base === 10) {\r\n\t\tvar str = this._s < 0 ? \"-\" : \"\";\r\n\t\tstr += this._d[this._d.length - 1].toString();\r\n\t\tfor (var i = this._d.length - 2; i >= 0; i--) {\r\n\t\t\tvar group = this._d[i].toString();\r\n\t\t\twhile (group.length < BigInteger_base_log10) group = '0' + group;\r\n\t\t\tstr += group;\r\n\t\t}\r\n\t\treturn str;\r\n\t}\r\n\telse {\r\n\t\tvar numerals = BigInteger.digits;\r\n\t\tbase = BigInteger.small[base];\r\n\t\tvar sign = this._s;\r\n\r\n\t\tvar n = this.abs();\r\n\t\tvar digits = [];\r\n\t\tvar digit;\r\n\r\n\t\twhile (n._s !== 0) {\r\n\t\t\tvar divmod = n.divRem(base);\r\n\t\t\tn = divmod[0];\r\n\t\t\tdigit = divmod[1];\r\n\t\t\t// TODO: This could be changed to unshift instead of reversing at the end.\r\n\t\t\t// Benchmark both to compare speeds.\r\n\t\t\tdigits.push(numerals[digit.valueOf()]);\r\n\t\t}\r\n\t\treturn (sign < 0 ? \"-\" : \"\") + digits.reverse().join(\"\");\r\n\t}\r\n};\r\n\r\n// Verify strings for parsing\r\nBigInteger.radixRegex = [\r\n\t/^$/,\r\n\t/^$/,\r\n\t/^[01]*$/,\r\n\t/^[012]*$/,\r\n\t/^[0-3]*$/,\r\n\t/^[0-4]*$/,\r\n\t/^[0-5]*$/,\r\n\t/^[0-6]*$/,\r\n\t/^[0-7]*$/,\r\n\t/^[0-8]*$/,\r\n\t/^[0-9]*$/,\r\n\t/^[0-9aA]*$/,\r\n\t/^[0-9abAB]*$/,\r\n\t/^[0-9abcABC]*$/,\r\n\t/^[0-9a-dA-D]*$/,\r\n\t/^[0-9a-eA-E]*$/,\r\n\t/^[0-9a-fA-F]*$/,\r\n\t/^[0-9a-gA-G]*$/,\r\n\t/^[0-9a-hA-H]*$/,\r\n\t/^[0-9a-iA-I]*$/,\r\n\t/^[0-9a-jA-J]*$/,\r\n\t/^[0-9a-kA-K]*$/,\r\n\t/^[0-9a-lA-L]*$/,\r\n\t/^[0-9a-mA-M]*$/,\r\n\t/^[0-9a-nA-N]*$/,\r\n\t/^[0-9a-oA-O]*$/,\r\n\t/^[0-9a-pA-P]*$/,\r\n\t/^[0-9a-qA-Q]*$/,\r\n\t/^[0-9a-rA-R]*$/,\r\n\t/^[0-9a-sA-S]*$/,\r\n\t/^[0-9a-tA-T]*$/,\r\n\t/^[0-9a-uA-U]*$/,\r\n\t/^[0-9a-vA-V]*$/,\r\n\t/^[0-9a-wA-W]*$/,\r\n\t/^[0-9a-xA-X]*$/,\r\n\t/^[0-9a-yA-Y]*$/,\r\n\t/^[0-9a-zA-Z]*$/\r\n];\r\n\r\n/*\r\n\tFunction: parse\r\n\tParse a string into a <BigInteger>.\r\n\r\n\t*base* is optional but, if provided, must be from 2 to 36 inclusive. If\r\n\t*base* is not provided, it will be guessed based on the leading characters\r\n\tof *s* as follows:\r\n\r\n\t- \"0x\" or \"0X\": *base* = 16\r\n\t- \"0c\" or \"0C\": *base* = 8\r\n\t- \"0b\" or \"0B\": *base* = 2\r\n\t- else: *base* = 10\r\n\r\n\tIf no base is provided, or *base* is 10, the number can be in exponential\r\n\tform. For example, these are all valid:\r\n\r\n\t> BigInteger.parse(\"1e9\");\t\t\t  // Same as \"1000000000\"\r\n\t> BigInteger.parse(\"1.234*10^3\");\t   // Same as 1234\r\n\t> BigInteger.parse(\"56789 * 10 ** -2\"); // Same as 567\r\n\r\n\tIf any characters fall outside the range defined by the radix, an exception\r\n\twill be thrown.\r\n\r\n\tParameters:\r\n\r\n\t\ts - The string to parse.\r\n\t\tbase - Optional radix (default is to guess based on *s*).\r\n\r\n\tReturns:\r\n\r\n\t\ta <BigInteger> instance.\r\n*/\r\nBigInteger.parse = function(s, base) {\r\n\t// Expands a number in exponential form to decimal form.\r\n\t// expandExponential(\"-13.441*10^5\") === \"1344100\";\r\n\t// expandExponential(\"1.12300e-1\") === \"0.112300\";\r\n\t// expandExponential(1000000000000000000000000000000) === \"1000000000000000000000000000000\";\r\n\tfunction expandExponential(str) {\r\n\t\tstr = str.replace(/\\s*[*xX]\\s*10\\s*(\\^|\\*\\*)\\s*/, \"e\");\r\n\r\n\t\treturn str.replace(/^([+\\-])?(\\d+)\\.?(\\d*)[eE]([+\\-]?\\d+)$/, function(x, s, n, f, c) {\r\n\t\t\tc = +c;\r\n\t\t\tvar l = c < 0;\r\n\t\t\tvar i = n.length + c;\r\n\t\t\tx = (l ? n : f).length;\r\n\t\t\tc = ((c = Math.abs(c)) >= x ? c - x + l : 0);\r\n\t\t\tvar z = (new Array(c + 1)).join(\"0\");\r\n\t\t\tvar r = n + f;\r\n\t\t\treturn (s || \"\") + (l ? r = z + r : r += z).substr(0, i += l ? z.length : 0) + (i < r.length ? \".\" + r.substr(i) : \"\");\r\n\t\t});\r\n\t}\r\n\r\n\ts = s.toString();\r\n\tif (typeof base === \"undefined\" || +base === 10) {\r\n\t\ts = expandExponential(s);\r\n\t}\r\n\r\n\tvar prefixRE;\r\n\tif (typeof base === \"undefined\") {\r\n\t\tprefixRE = '0[xcb]';\r\n\t}\r\n\telse if (base == 16) {\r\n\t\tprefixRE = '0x';\r\n\t}\r\n\telse if (base == 8) {\r\n\t\tprefixRE = '0c';\r\n\t}\r\n\telse if (base == 2) {\r\n\t\tprefixRE = '0b';\r\n\t}\r\n\telse {\r\n\t\tprefixRE = '';\r\n\t}\r\n\tvar parts = new RegExp('^([+\\\\-]?)(' + prefixRE + ')?([0-9a-z]*)(?:\\\\.\\\\d*)?$', 'i').exec(s);\r\n\tif (parts) {\r\n\t\tvar sign = parts[1] || \"+\";\r\n\t\tvar baseSection = parts[2] || \"\";\r\n\t\tvar digits = parts[3] || \"\";\r\n\r\n\t\tif (typeof base === \"undefined\") {\r\n\t\t\t// Guess base\r\n\t\t\tif (baseSection === \"0x\" || baseSection === \"0X\") { // Hex\r\n\t\t\t\tbase = 16;\r\n\t\t\t}\r\n\t\t\telse if (baseSection === \"0c\" || baseSection === \"0C\") { // Octal\r\n\t\t\t\tbase = 8;\r\n\t\t\t}\r\n\t\t\telse if (baseSection === \"0b\" || baseSection === \"0B\") { // Binary\r\n\t\t\t\tbase = 2;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tbase = 10;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (base < 2 || base > 36) {\r\n\t\t\tthrow new Error(\"Illegal radix \" + base + \".\");\r\n\t\t}\r\n\r\n\t\tbase = +base;\r\n\r\n\t\t// Check for digits outside the range\r\n\t\tif (!(BigInteger.radixRegex[base].test(digits))) {\r\n\t\t\tthrow new Error(\"Bad digit for radix \" + base);\r\n\t\t}\r\n\r\n\t\t// Strip leading zeros, and convert to array\r\n\t\tdigits = digits.replace(/^0+/, \"\").split(\"\");\r\n\t\tif (digits.length === 0) {\r\n\t\t\treturn ZERO;\r\n\t\t}\r\n\r\n\t\t// Get the sign (we know it's not zero)\r\n\t\tsign = (sign === \"-\") ? -1 : 1;\r\n\r\n\t\t// Optimize 10\r\n\t\tif (base == 10) {\r\n\t\t\tvar d = [];\r\n\t\t\twhile (digits.length >= BigInteger_base_log10) {\r\n\t\t\t\td.push(parseInt(digits.splice(digits.length-BigInteger.base_log10, BigInteger.base_log10).join(''), 10));\r\n\t\t\t}\r\n\t\t\td.push(parseInt(digits.join(''), 10));\r\n\t\t\treturn new BigInteger(d, sign, CONSTRUCT);\r\n\t\t}\r\n\r\n\t\t// Do the conversion\r\n\t\tvar d = ZERO;\r\n\t\tbase = BigInteger.small[base];\r\n\t\tvar small = BigInteger.small;\r\n\t\tfor (var i = 0; i < digits.length; i++) {\r\n\t\t\td = d.multiply(base).add(small[parseInt(digits[i], 36)]);\r\n\t\t}\r\n\t\treturn new BigInteger(d._d, sign, CONSTRUCT);\r\n\t}\r\n\telse {\r\n\t\tthrow new Error(\"Invalid BigInteger format: \" + s);\r\n\t}\r\n};\r\n\r\n/*\r\n\tFunction: add\r\n\tAdd two <BigIntegers>.\r\n\r\n\tParameters:\r\n\r\n\t\tn - The number to add to *this*. Will be converted to a <BigInteger>.\r\n\r\n\tReturns:\r\n\r\n\t\tThe numbers added together.\r\n\r\n\tSee Also:\r\n\r\n\t\t<subtract>, <multiply>, <quotient>, <next>\r\n*/\r\nBigInteger.prototype.add = function(n) {\r\n\tif (this._s === 0) {\r\n\t\treturn BigInteger(n);\r\n\t}\r\n\r\n\tn = BigInteger(n);\r\n\tif (n._s === 0) {\r\n\t\treturn this;\r\n\t}\r\n\tif (this._s !== n._s) {\r\n\t\tn = n.negate();\r\n\t\treturn this.subtract(n);\r\n\t}\r\n\r\n\tvar a = this._d;\r\n\tvar b = n._d;\r\n\tvar al = a.length;\r\n\tvar bl = b.length;\r\n\tvar sum = new Array(Math.max(al, bl) + 1);\r\n\tvar size = Math.min(al, bl);\r\n\tvar carry = 0;\r\n\tvar digit;\r\n\r\n\tfor (var i = 0; i < size; i++) {\r\n\t\tdigit = a[i] + b[i] + carry;\r\n\t\tsum[i] = digit % BigInteger_base;\r\n\t\tcarry = (digit / BigInteger_base) | 0;\r\n\t}\r\n\tif (bl > al) {\r\n\t\ta = b;\r\n\t\tal = bl;\r\n\t}\r\n\tfor (i = size; carry && i < al; i++) {\r\n\t\tdigit = a[i] + carry;\r\n\t\tsum[i] = digit % BigInteger_base;\r\n\t\tcarry = (digit / BigInteger_base) | 0;\r\n\t}\r\n\tif (carry) {\r\n\t\tsum[i] = carry;\r\n\t}\r\n\r\n\tfor ( ; i < al; i++) {\r\n\t\tsum[i] = a[i];\r\n\t}\r\n\r\n\treturn new BigInteger(sum, this._s, CONSTRUCT);\r\n};\r\n\r\n/*\r\n\tFunction: negate\r\n\tGet the additive inverse of a <BigInteger>.\r\n\r\n\tReturns:\r\n\r\n\t\tA <BigInteger> with the same magnatude, but with the opposite sign.\r\n\r\n\tSee Also:\r\n\r\n\t\t<abs>\r\n*/\r\nBigInteger.prototype.negate = function() {\r\n\treturn new BigInteger(this._d, (-this._s) | 0, CONSTRUCT);\r\n};\r\n\r\n/*\r\n\tFunction: abs\r\n\tGet the absolute value of a <BigInteger>.\r\n\r\n\tReturns:\r\n\r\n\t\tA <BigInteger> with the same magnatude, but always positive (or zero).\r\n\r\n\tSee Also:\r\n\r\n\t\t<negate>\r\n*/\r\nBigInteger.prototype.abs = function() {\r\n\treturn (this._s < 0) ? this.negate() : this;\r\n};\r\n\r\n/*\r\n\tFunction: subtract\r\n\tSubtract two <BigIntegers>.\r\n\r\n\tParameters:\r\n\r\n\t\tn - The number to subtract from *this*. Will be converted to a <BigInteger>.\r\n\r\n\tReturns:\r\n\r\n\t\tThe *n* subtracted from *this*.\r\n\r\n\tSee Also:\r\n\r\n\t\t<add>, <multiply>, <quotient>, <prev>\r\n*/\r\nBigInteger.prototype.subtract = function(n) {\r\n\tif (this._s === 0) {\r\n\t\treturn BigInteger(n).negate();\r\n\t}\r\n\r\n\tn = BigInteger(n);\r\n\tif (n._s === 0) {\r\n\t\treturn this;\r\n\t}\r\n\tif (this._s !== n._s) {\r\n\t\tn = n.negate();\r\n\t\treturn this.add(n);\r\n\t}\r\n\r\n\tvar m = this;\r\n\t// negative - negative => -|a| - -|b| => -|a| + |b| => |b| - |a|\r\n\tif (this._s < 0) {\r\n\t\tm = new BigInteger(n._d, 1, CONSTRUCT);\r\n\t\tn = new BigInteger(this._d, 1, CONSTRUCT);\r\n\t}\r\n\r\n\t// Both are positive => a - b\r\n\tvar sign = m.compareAbs(n);\r\n\tif (sign === 0) {\r\n\t\treturn ZERO;\r\n\t}\r\n\telse if (sign < 0) {\r\n\t\t// swap m and n\r\n\t\tvar t = n;\r\n\t\tn = m;\r\n\t\tm = t;\r\n\t}\r\n\r\n\t// a > b\r\n\tvar a = m._d;\r\n\tvar b = n._d;\r\n\tvar al = a.length;\r\n\tvar bl = b.length;\r\n\tvar diff = new Array(al); // al >= bl since a > b\r\n\tvar borrow = 0;\r\n\tvar i;\r\n\tvar digit;\r\n\r\n\tfor (i = 0; i < bl; i++) {\r\n\t\tdigit = a[i] - borrow - b[i];\r\n\t\tif (digit < 0) {\r\n\t\t\tdigit += BigInteger_base;\r\n\t\t\tborrow = 1;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tborrow = 0;\r\n\t\t}\r\n\t\tdiff[i] = digit;\r\n\t}\r\n\tfor (i = bl; i < al; i++) {\r\n\t\tdigit = a[i] - borrow;\r\n\t\tif (digit < 0) {\r\n\t\t\tdigit += BigInteger_base;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdiff[i++] = digit;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tdiff[i] = digit;\r\n\t}\r\n\tfor ( ; i < al; i++) {\r\n\t\tdiff[i] = a[i];\r\n\t}\r\n\r\n\treturn new BigInteger(diff, sign, CONSTRUCT);\r\n};\r\n\r\n(function() {\r\n\tfunction addOne(n, sign) {\r\n\t\tvar a = n._d;\r\n\t\tvar sum = a.slice();\r\n\t\tvar carry = true;\r\n\t\tvar i = 0;\r\n\r\n\t\twhile (true) {\r\n\t\t\tvar digit = (a[i] || 0) + 1;\r\n\t\t\tsum[i] = digit % BigInteger_base;\r\n\t\t\tif (digit <= BigInteger_base - 1) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t++i;\r\n\t\t}\r\n\r\n\t\treturn new BigInteger(sum, sign, CONSTRUCT);\r\n\t}\r\n\r\n\tfunction subtractOne(n, sign) {\r\n\t\tvar a = n._d;\r\n\t\tvar sum = a.slice();\r\n\t\tvar borrow = true;\r\n\t\tvar i = 0;\r\n\r\n\t\twhile (true) {\r\n\t\t\tvar digit = (a[i] || 0) - 1;\r\n\t\t\tif (digit < 0) {\r\n\t\t\t\tsum[i] = digit + BigInteger_base;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tsum[i] = digit;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t++i;\r\n\t\t}\r\n\r\n\t\treturn new BigInteger(sum, sign, CONSTRUCT);\r\n\t}\r\n\r\n\t/*\r\n\t\tFunction: next\r\n\t\tGet the next <BigInteger> (add one).\r\n\r\n\t\tReturns:\r\n\r\n\t\t\t*this* + 1.\r\n\r\n\t\tSee Also:\r\n\r\n\t\t\t<add>, <prev>\r\n\t*/\r\n\tBigInteger.prototype.next = function() {\r\n\t\tswitch (this._s) {\r\n\t\tcase 0:\r\n\t\t\treturn ONE;\r\n\t\tcase -1:\r\n\t\t\treturn subtractOne(this, -1);\r\n\t\t// case 1:\r\n\t\tdefault:\r\n\t\t\treturn addOne(this, 1);\r\n\t\t}\r\n\t};\r\n\r\n\t/*\r\n\t\tFunction: prev\r\n\t\tGet the previous <BigInteger> (subtract one).\r\n\r\n\t\tReturns:\r\n\r\n\t\t\t*this* - 1.\r\n\r\n\t\tSee Also:\r\n\r\n\t\t\t<next>, <subtract>\r\n\t*/\r\n\tBigInteger.prototype.prev = function() {\r\n\t\tswitch (this._s) {\r\n\t\tcase 0:\r\n\t\t\treturn M_ONE;\r\n\t\tcase -1:\r\n\t\t\treturn addOne(this, -1);\r\n\t\t// case 1:\r\n\t\tdefault:\r\n\t\t\treturn subtractOne(this, 1);\r\n\t\t}\r\n\t};\r\n})();\r\n\r\n/*\r\n\tFunction: compareAbs\r\n\tCompare the absolute value of two <BigIntegers>.\r\n\r\n\tCalling <compareAbs> is faster than calling <abs> twice, then <compare>.\r\n\r\n\tParameters:\r\n\r\n\t\tn - The number to compare to *this*. Will be converted to a <BigInteger>.\r\n\r\n\tReturns:\r\n\r\n\t\t-1, 0, or +1 if *|this|* is less than, equal to, or greater than *|n|*.\r\n\r\n\tSee Also:\r\n\r\n\t\t<compare>, <abs>\r\n*/\r\nBigInteger.prototype.compareAbs = function(n) {\r\n\tif (this === n) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tif (!(n instanceof BigInteger)) {\r\n\t\tif (!isFinite(n)) {\r\n\t\t\treturn(isNaN(n) ? n : -1);\r\n\t\t}\r\n\t\tn = BigInteger(n);\r\n\t}\r\n\r\n\tif (this._s === 0) {\r\n\t\treturn (n._s !== 0) ? -1 : 0;\r\n\t}\r\n\tif (n._s === 0) {\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tvar l = this._d.length;\r\n\tvar nl = n._d.length;\r\n\tif (l < nl) {\r\n\t\treturn -1;\r\n\t}\r\n\telse if (l > nl) {\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tvar a = this._d;\r\n\tvar b = n._d;\r\n\tfor (var i = l-1; i >= 0; i--) {\r\n\t\tif (a[i] !== b[i]) {\r\n\t\t\treturn a[i] < b[i] ? -1 : 1;\r\n\t\t}\r\n\t}\r\n\r\n\treturn 0;\r\n};\r\n\r\n/*\r\n\tFunction: compare\r\n\tCompare two <BigIntegers>.\r\n\r\n\tParameters:\r\n\r\n\t\tn - The number to compare to *this*. Will be converted to a <BigInteger>.\r\n\r\n\tReturns:\r\n\r\n\t\t-1, 0, or +1 if *this* is less than, equal to, or greater than *n*.\r\n\r\n\tSee Also:\r\n\r\n\t\t<compareAbs>, <isPositive>, <isNegative>, <isUnit>\r\n*/\r\nBigInteger.prototype.compare = function(n) {\r\n\tif (this === n) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tn = BigInteger(n);\r\n\r\n\tif (this._s === 0) {\r\n\t\treturn -n._s;\r\n\t}\r\n\r\n\tif (this._s === n._s) { // both positive or both negative\r\n\t\tvar cmp = this.compareAbs(n);\r\n\t\treturn cmp * this._s;\r\n\t}\r\n\telse {\r\n\t\treturn this._s;\r\n\t}\r\n};\r\n\r\n/*\r\n\tFunction: isUnit\r\n\tReturn true iff *this* is either 1 or -1.\r\n\r\n\tReturns:\r\n\r\n\t\ttrue if *this* compares equal to <BigInteger.ONE> or <BigInteger.M_ONE>.\r\n\r\n\tSee Also:\r\n\r\n\t\t<isZero>, <isNegative>, <isPositive>, <compareAbs>, <compare>,\r\n\t\t<BigInteger.ONE>, <BigInteger.M_ONE>\r\n*/\r\nBigInteger.prototype.isUnit = function() {\r\n\treturn this === ONE ||\r\n\t\tthis === M_ONE ||\r\n\t\t(this._d.length === 1 && this._d[0] === 1);\r\n};\r\n\r\n/*\r\n\tFunction: multiply\r\n\tMultiply two <BigIntegers>.\r\n\r\n\tParameters:\r\n\r\n\t\tn - The number to multiply *this* by. Will be converted to a\r\n\t\t<BigInteger>.\r\n\r\n\tReturns:\r\n\r\n\t\tThe numbers multiplied together.\r\n\r\n\tSee Also:\r\n\r\n\t\t<add>, <subtract>, <quotient>, <square>\r\n*/\r\nBigInteger.prototype.multiply = function(n) {\r\n\t// TODO: Consider adding Karatsuba multiplication for large numbers\r\n\tif (this._s === 0) {\r\n\t\treturn ZERO;\r\n\t}\r\n\r\n\tn = BigInteger(n);\r\n\tif (n._s === 0) {\r\n\t\treturn ZERO;\r\n\t}\r\n\tif (this.isUnit()) {\r\n\t\tif (this._s < 0) {\r\n\t\t\treturn n.negate();\r\n\t\t}\r\n\t\treturn n;\r\n\t}\r\n\tif (n.isUnit()) {\r\n\t\tif (n._s < 0) {\r\n\t\t\treturn this.negate();\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\tif (this === n) {\r\n\t\treturn this.square();\r\n\t}\r\n\r\n\tvar r = (this._d.length >= n._d.length);\r\n\tvar a = (r ? this : n)._d; // a will be longer than b\r\n\tvar b = (r ? n : this)._d;\r\n\tvar al = a.length;\r\n\tvar bl = b.length;\r\n\r\n\tvar pl = al + bl;\r\n\tvar partial = new Array(pl);\r\n\tvar i;\r\n\tfor (i = 0; i < pl; i++) {\r\n\t\tpartial[i] = 0;\r\n\t}\r\n\r\n\tfor (i = 0; i < bl; i++) {\r\n\t\tvar carry = 0;\r\n\t\tvar bi = b[i];\r\n\t\tvar jlimit = al + i;\r\n\t\tvar digit;\r\n\t\tfor (var j = i; j < jlimit; j++) {\r\n\t\t\tdigit = partial[j] + bi * a[j - i] + carry;\r\n\t\t\tcarry = (digit / BigInteger_base) | 0;\r\n\t\t\tpartial[j] = (digit % BigInteger_base) | 0;\r\n\t\t}\r\n\t\tif (carry) {\r\n\t\t\tdigit = partial[j] + carry;\r\n\t\t\tcarry = (digit / BigInteger_base) | 0;\r\n\t\t\tpartial[j] = digit % BigInteger_base;\r\n\t\t}\r\n\t}\r\n\treturn new BigInteger(partial, this._s * n._s, CONSTRUCT);\r\n};\r\n\r\n// Multiply a BigInteger by a single-digit native number\r\n// Assumes that this and n are >= 0\r\n// This is not really intended to be used outside the library itself\r\nBigInteger.prototype.multiplySingleDigit = function(n) {\r\n\tif (n === 0 || this._s === 0) {\r\n\t\treturn ZERO;\r\n\t}\r\n\tif (n === 1) {\r\n\t\treturn this;\r\n\t}\r\n\r\n\tvar digit;\r\n\tif (this._d.length === 1) {\r\n\t\tdigit = this._d[0] * n;\r\n\t\tif (digit >= BigInteger_base) {\r\n\t\t\treturn new BigInteger([(digit % BigInteger_base)|0,\r\n\t\t\t\t\t(digit / BigInteger_base)|0], 1, CONSTRUCT);\r\n\t\t}\r\n\t\treturn new BigInteger([digit], 1, CONSTRUCT);\r\n\t}\r\n\r\n\tif (n === 2) {\r\n\t\treturn this.add(this);\r\n\t}\r\n\tif (this.isUnit()) {\r\n\t\treturn new BigInteger([n], 1, CONSTRUCT);\r\n\t}\r\n\r\n\tvar a = this._d;\r\n\tvar al = a.length;\r\n\r\n\tvar pl = al + 1;\r\n\tvar partial = new Array(pl);\r\n\tfor (var i = 0; i < pl; i++) {\r\n\t\tpartial[i] = 0;\r\n\t}\r\n\r\n\tvar carry = 0;\r\n\tfor (var j = 0; j < al; j++) {\r\n\t\tdigit = n * a[j] + carry;\r\n\t\tcarry = (digit / BigInteger_base) | 0;\r\n\t\tpartial[j] = (digit % BigInteger_base) | 0;\r\n\t}\r\n\tif (carry) {\r\n\t\tpartial[j] = carry;\r\n\t}\r\n\r\n\treturn new BigInteger(partial, 1, CONSTRUCT);\r\n};\r\n\r\n/*\r\n\tFunction: square\r\n\tMultiply a <BigInteger> by itself.\r\n\r\n\tThis is slightly faster than regular multiplication, since it removes the\r\n\tduplicated multiplcations.\r\n\r\n\tReturns:\r\n\r\n\t\t> this.multiply(this)\r\n\r\n\tSee Also:\r\n\t\t<multiply>\r\n*/\r\nBigInteger.prototype.square = function() {\r\n\t// Normally, squaring a 10-digit number would take 100 multiplications.\r\n\t// Of these 10 are unique diagonals, of the remaining 90 (100-10), 45 are repeated.\r\n\t// This procedure saves (N*(N-1))/2 multiplications, (e.g., 45 of 100 multiplies).\r\n\t// Based on code by Gary Darby, Intellitech Systems Inc., www.DelphiForFun.org\r\n\r\n\tif (this._s === 0) {\r\n\t\treturn ZERO;\r\n\t}\r\n\tif (this.isUnit()) {\r\n\t\treturn ONE;\r\n\t}\r\n\r\n\tvar digits = this._d;\r\n\tvar length = digits.length;\r\n\tvar imult1 = new Array(length + length + 1);\r\n\tvar product, carry, k;\r\n\tvar i;\r\n\r\n\t// Calculate diagonal\r\n\tfor (i = 0; i < length; i++) {\r\n\t\tk = i * 2;\r\n\t\tproduct = digits[i] * digits[i];\r\n\t\tcarry = (product / BigInteger_base) | 0;\r\n\t\timult1[k] = product % BigInteger_base;\r\n\t\timult1[k + 1] = carry;\r\n\t}\r\n\r\n\t// Calculate repeating part\r\n\tfor (i = 0; i < length; i++) {\r\n\t\tcarry = 0;\r\n\t\tk = i * 2 + 1;\r\n\t\tfor (var j = i + 1; j < length; j++, k++) {\r\n\t\t\tproduct = digits[j] * digits[i] * 2 + imult1[k] + carry;\r\n\t\t\tcarry = (product / BigInteger_base) | 0;\r\n\t\t\timult1[k] = product % BigInteger_base;\r\n\t\t}\r\n\t\tk = length + i;\r\n\t\tvar digit = carry + imult1[k];\r\n\t\tcarry = (digit / BigInteger_base) | 0;\r\n\t\timult1[k] = digit % BigInteger_base;\r\n\t\timult1[k + 1] += carry;\r\n\t}\r\n\r\n\treturn new BigInteger(imult1, 1, CONSTRUCT);\r\n};\r\n\r\n/*\r\n\tFunction: quotient\r\n\tDivide two <BigIntegers> and truncate towards zero.\r\n\r\n\t<quotient> throws an exception if *n* is zero.\r\n\r\n\tParameters:\r\n\r\n\t\tn - The number to divide *this* by. Will be converted to a <BigInteger>.\r\n\r\n\tReturns:\r\n\r\n\t\tThe *this* / *n*, truncated to an integer.\r\n\r\n\tSee Also:\r\n\r\n\t\t<add>, <subtract>, <multiply>, <divRem>, <remainder>\r\n*/\r\nBigInteger.prototype.quotient = function(n) {\r\n\treturn this.divRem(n)[0];\r\n};\r\n\r\n/*\r\n\tFunction: divide\r\n\tDeprecated synonym for <quotient>.\r\n*/\r\nBigInteger.prototype.divide = BigInteger.prototype.quotient;\r\n\r\n/*\r\n\tFunction: remainder\r\n\tCalculate the remainder of two <BigIntegers>.\r\n\r\n\t<remainder> throws an exception if *n* is zero.\r\n\r\n\tParameters:\r\n\r\n\t\tn - The remainder after *this* is divided *this* by *n*. Will be\r\n\t\t\tconverted to a <BigInteger>.\r\n\r\n\tReturns:\r\n\r\n\t\t*this* % *n*.\r\n\r\n\tSee Also:\r\n\r\n\t\t<divRem>, <quotient>\r\n*/\r\nBigInteger.prototype.remainder = function(n) {\r\n\treturn this.divRem(n)[1];\r\n};\r\n\r\n/*\r\n\tFunction: divRem\r\n\tCalculate the integer quotient and remainder of two <BigIntegers>.\r\n\r\n\t<divRem> throws an exception if *n* is zero.\r\n\r\n\tParameters:\r\n\r\n\t\tn - The number to divide *this* by. Will be converted to a <BigInteger>.\r\n\r\n\tReturns:\r\n\r\n\t\tA two-element array containing the quotient and the remainder.\r\n\r\n\t\t> a.divRem(b)\r\n\r\n\t\tis exactly equivalent to\r\n\r\n\t\t> [a.quotient(b), a.remainder(b)]\r\n\r\n\t\texcept it is faster, because they are calculated at the same time.\r\n\r\n\tSee Also:\r\n\r\n\t\t<quotient>, <remainder>\r\n*/\r\nBigInteger.prototype.divRem = function(n) {\r\n\tn = BigInteger(n);\r\n\tif (n._s === 0) {\r\n\t\tthrow new Error(\"Divide by zero\");\r\n\t}\r\n\tif (this._s === 0) {\r\n\t\treturn [ZERO, ZERO];\r\n\t}\r\n\tif (n._d.length === 1) {\r\n\t\treturn this.divRemSmall(n._s * n._d[0]);\r\n\t}\r\n\r\n\t// Test for easy cases -- |n1| <= |n2|\r\n\tswitch (this.compareAbs(n)) {\r\n\tcase 0: // n1 == n2\r\n\t\treturn [this._s === n._s ? ONE : M_ONE, ZERO];\r\n\tcase -1: // |n1| < |n2|\r\n\t\treturn [ZERO, this];\r\n\t}\r\n\r\n\tvar sign = this._s * n._s;\r\n\tvar a = n.abs();\r\n\tvar b_digits = this._d;\r\n\tvar b_index = b_digits.length;\r\n\tvar digits = n._d.length;\r\n\tvar quot = [];\r\n\tvar guess;\r\n\r\n\tvar part = new BigInteger([], 0, CONSTRUCT);\r\n\r\n\twhile (b_index) {\r\n\t\tpart._d.unshift(b_digits[--b_index]);\r\n\t\tpart = new BigInteger(part._d, 1, CONSTRUCT);\r\n\r\n\t\tif (part.compareAbs(n) < 0) {\r\n\t\t\tquot.push(0);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (part._s === 0) {\r\n\t\t\tguess = 0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tvar xlen = part._d.length, ylen = a._d.length;\r\n\t\t\tvar highx = part._d[xlen-1]*BigInteger_base + part._d[xlen-2];\r\n\t\t\tvar highy = a._d[ylen-1]*BigInteger_base + a._d[ylen-2];\r\n\t\t\tif (part._d.length > a._d.length) {\r\n\t\t\t\t// The length of part._d can either match a._d length,\r\n\t\t\t\t// or exceed it by one.\r\n\t\t\t\thighx = (highx+1)*BigInteger_base;\r\n\t\t\t}\r\n\t\t\tguess = Math.ceil(highx/highy);\r\n\t\t}\r\n\t\tdo {\r\n\t\t\tvar check = a.multiplySingleDigit(guess);\r\n\t\t\tif (check.compareAbs(part) <= 0) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tguess--;\r\n\t\t} while (guess);\r\n\r\n\t\tquot.push(guess);\r\n\t\tif (!guess) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tvar diff = part.subtract(check);\r\n\t\tpart._d = diff._d.slice();\r\n\t}\r\n\r\n\treturn [new BigInteger(quot.reverse(), sign, CONSTRUCT),\r\n\t\t   new BigInteger(part._d, this._s, CONSTRUCT)];\r\n};\r\n\r\n// Throws an exception if n is outside of (-BigInteger.base, -1] or\r\n// [1, BigInteger.base).  It's not necessary to call this, since the\r\n// other division functions will call it if they are able to.\r\nBigInteger.prototype.divRemSmall = function(n) {\r\n\tvar r;\r\n\tn = +n;\r\n\tif (n === 0) {\r\n\t\tthrow new Error(\"Divide by zero\");\r\n\t}\r\n\r\n\tvar n_s = n < 0 ? -1 : 1;\r\n\tvar sign = this._s * n_s;\r\n\tn = Math.abs(n);\r\n\r\n\tif (n < 1 || n >= BigInteger_base) {\r\n\t\tthrow new Error(\"Argument out of range\");\r\n\t}\r\n\r\n\tif (this._s === 0) {\r\n\t\treturn [ZERO, ZERO];\r\n\t}\r\n\r\n\tif (n === 1 || n === -1) {\r\n\t\treturn [(sign === 1) ? this.abs() : new BigInteger(this._d, sign, CONSTRUCT), ZERO];\r\n\t}\r\n\r\n\t// 2 <= n < BigInteger_base\r\n\r\n\t// divide a single digit by a single digit\r\n\tif (this._d.length === 1) {\r\n\t\tvar q = new BigInteger([(this._d[0] / n) | 0], 1, CONSTRUCT);\r\n\t\tr = new BigInteger([(this._d[0] % n) | 0], 1, CONSTRUCT);\r\n\t\tif (sign < 0) {\r\n\t\t\tq = q.negate();\r\n\t\t}\r\n\t\tif (this._s < 0) {\r\n\t\t\tr = r.negate();\r\n\t\t}\r\n\t\treturn [q, r];\r\n\t}\r\n\r\n\tvar digits = this._d.slice();\r\n\tvar quot = new Array(digits.length);\r\n\tvar part = 0;\r\n\tvar diff = 0;\r\n\tvar i = 0;\r\n\tvar guess;\r\n\r\n\twhile (digits.length) {\r\n\t\tpart = part * BigInteger_base + digits[digits.length - 1];\r\n\t\tif (part < n) {\r\n\t\t\tquot[i++] = 0;\r\n\t\t\tdigits.pop();\r\n\t\t\tdiff = BigInteger_base * diff + part;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (part === 0) {\r\n\t\t\tguess = 0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tguess = (part / n) | 0;\r\n\t\t}\r\n\r\n\t\tvar check = n * guess;\r\n\t\tdiff = part - check;\r\n\t\tquot[i++] = guess;\r\n\t\tif (!guess) {\r\n\t\t\tdigits.pop();\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tdigits.pop();\r\n\t\tpart = diff;\r\n\t}\r\n\r\n\tr = new BigInteger([diff], 1, CONSTRUCT);\r\n\tif (this._s < 0) {\r\n\t\tr = r.negate();\r\n\t}\r\n\treturn [new BigInteger(quot.reverse(), sign, CONSTRUCT), r];\r\n};\r\n\r\n/*\r\n\tFunction: isEven\r\n\tReturn true iff *this* is divisible by two.\r\n\r\n\tNote that <BigInteger.ZERO> is even.\r\n\r\n\tReturns:\r\n\r\n\t\ttrue if *this* is even, false otherwise.\r\n\r\n\tSee Also:\r\n\r\n\t\t<isOdd>\r\n*/\r\nBigInteger.prototype.isEven = function() {\r\n\tvar digits = this._d;\r\n\treturn this._s === 0 || digits.length === 0 || (digits[0] % 2) === 0;\r\n};\r\n\r\n/*\r\n\tFunction: isOdd\r\n\tReturn true iff *this* is not divisible by two.\r\n\r\n\tReturns:\r\n\r\n\t\ttrue if *this* is odd, false otherwise.\r\n\r\n\tSee Also:\r\n\r\n\t\t<isEven>\r\n*/\r\nBigInteger.prototype.isOdd = function() {\r\n\treturn !this.isEven();\r\n};\r\n\r\n/*\r\n\tFunction: sign\r\n\tGet the sign of a <BigInteger>.\r\n\r\n\tReturns:\r\n\r\n\t\t* -1 if *this* < 0\r\n\t\t* 0 if *this* == 0\r\n\t\t* +1 if *this* > 0\r\n\r\n\tSee Also:\r\n\r\n\t\t<isZero>, <isPositive>, <isNegative>, <compare>, <BigInteger.ZERO>\r\n*/\r\nBigInteger.prototype.sign = function() {\r\n\treturn this._s;\r\n};\r\n\r\n/*\r\n\tFunction: isPositive\r\n\tReturn true iff *this* > 0.\r\n\r\n\tReturns:\r\n\r\n\t\ttrue if *this*.compare(<BigInteger.ZERO>) == 1.\r\n\r\n\tSee Also:\r\n\r\n\t\t<sign>, <isZero>, <isNegative>, <isUnit>, <compare>, <BigInteger.ZERO>\r\n*/\r\nBigInteger.prototype.isPositive = function() {\r\n\treturn this._s > 0;\r\n};\r\n\r\n/*\r\n\tFunction: isNegative\r\n\tReturn true iff *this* < 0.\r\n\r\n\tReturns:\r\n\r\n\t\ttrue if *this*.compare(<BigInteger.ZERO>) == -1.\r\n\r\n\tSee Also:\r\n\r\n\t\t<sign>, <isPositive>, <isZero>, <isUnit>, <compare>, <BigInteger.ZERO>\r\n*/\r\nBigInteger.prototype.isNegative = function() {\r\n\treturn this._s < 0;\r\n};\r\n\r\n/*\r\n\tFunction: isZero\r\n\tReturn true iff *this* == 0.\r\n\r\n\tReturns:\r\n\r\n\t\ttrue if *this*.compare(<BigInteger.ZERO>) == 0.\r\n\r\n\tSee Also:\r\n\r\n\t\t<sign>, <isPositive>, <isNegative>, <isUnit>, <BigInteger.ZERO>\r\n*/\r\nBigInteger.prototype.isZero = function() {\r\n\treturn this._s === 0;\r\n};\r\n\r\n/*\r\n\tFunction: exp10\r\n\tMultiply a <BigInteger> by a power of 10.\r\n\r\n\tThis is equivalent to, but faster than\r\n\r\n\t> if (n >= 0) {\r\n\t>\t return this.multiply(BigInteger(\"1e\" + n));\r\n\t> }\r\n\t> else { // n <= 0\r\n\t>\t return this.quotient(BigInteger(\"1e\" + -n));\r\n\t> }\r\n\r\n\tParameters:\r\n\r\n\t\tn - The power of 10 to multiply *this* by. *n* is converted to a\r\n\t\tjavascipt number and must be no greater than <BigInteger.MAX_EXP>\r\n\t\t(0x7FFFFFFF), or an exception will be thrown.\r\n\r\n\tReturns:\r\n\r\n\t\t*this* * (10 ** *n*), truncated to an integer if necessary.\r\n\r\n\tSee Also:\r\n\r\n\t\t<pow>, <multiply>\r\n*/\r\nBigInteger.prototype.exp10 = function(n) {\r\n\tn = +n;\r\n\tif (n === 0) {\r\n\t\treturn this;\r\n\t}\r\n\tif (Math.abs(n) > Number(MAX_EXP)) {\r\n\t\tthrow new Error(\"exponent too large in BigInteger.exp10\");\r\n\t}\r\n\t// Optimization for this == 0. This also keeps us from having to trim zeros in the positive n case\r\n\tif (this._s === 0) {\r\n\t\treturn ZERO;\r\n\t}\r\n\tif (n > 0) {\r\n\t\tvar k = new BigInteger(this._d.slice(), this._s, CONSTRUCT);\r\n\r\n\t\tfor (; n >= BigInteger_base_log10; n -= BigInteger_base_log10) {\r\n\t\t\tk._d.unshift(0);\r\n\t\t}\r\n\t\tif (n == 0)\r\n\t\t\treturn k;\r\n\t\tk._s = 1;\r\n\t\tk = k.multiplySingleDigit(Math.pow(10, n));\r\n\t\treturn (this._s < 0 ? k.negate() : k);\r\n\t} else if (-n >= this._d.length*BigInteger_base_log10) {\r\n\t\treturn ZERO;\r\n\t} else {\r\n\t\tvar k = new BigInteger(this._d.slice(), this._s, CONSTRUCT);\r\n\r\n\t\tfor (n = -n; n >= BigInteger_base_log10; n -= BigInteger_base_log10) {\r\n\t\t\tk._d.shift();\r\n\t\t}\r\n\t\treturn (n == 0) ? k : k.divRemSmall(Math.pow(10, n))[0];\r\n\t}\r\n};\r\n\r\n/*\r\n\tFunction: pow\r\n\tRaise a <BigInteger> to a power.\r\n\r\n\tIn this implementation, 0**0 is 1.\r\n\r\n\tParameters:\r\n\r\n\t\tn - The exponent to raise *this* by. *n* must be no greater than\r\n\t\t<BigInteger.MAX_EXP> (0x7FFFFFFF), or an exception will be thrown.\r\n\r\n\tReturns:\r\n\r\n\t\t*this* raised to the *nth* power.\r\n\r\n\tSee Also:\r\n\r\n\t\t<modPow>\r\n*/\r\nBigInteger.prototype.pow = function(n) {\r\n\tif (this.isUnit()) {\r\n\t\tif (this._s > 0) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn BigInteger(n).isOdd() ? this : this.negate();\r\n\t\t}\r\n\t}\r\n\r\n\tn = BigInteger(n);\r\n\tif (n._s === 0) {\r\n\t\treturn ONE;\r\n\t}\r\n\telse if (n._s < 0) {\r\n\t\tif (this._s === 0) {\r\n\t\t\tthrow new Error(\"Divide by zero\");\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn ZERO;\r\n\t\t}\r\n\t}\r\n\tif (this._s === 0) {\r\n\t\treturn ZERO;\r\n\t}\r\n\tif (n.isUnit()) {\r\n\t\treturn this;\r\n\t}\r\n\r\n\tif (n.compareAbs(MAX_EXP) > 0) {\r\n\t\tthrow new Error(\"exponent too large in BigInteger.pow\");\r\n\t}\r\n\tvar x = this;\r\n\tvar aux = ONE;\r\n\tvar two = BigInteger.small[2];\r\n\r\n\twhile (n.isPositive()) {\r\n\t\tif (n.isOdd()) {\r\n\t\t\taux = aux.multiply(x);\r\n\t\t\tif (n.isUnit()) {\r\n\t\t\t\treturn aux;\r\n\t\t\t}\r\n\t\t}\r\n\t\tx = x.square();\r\n\t\tn = n.quotient(two);\r\n\t}\r\n\r\n\treturn aux;\r\n};\r\n\r\n/*\r\n\tFunction: modPow\r\n\tRaise a <BigInteger> to a power (mod m).\r\n\r\n\tBecause it is reduced by a modulus, <modPow> is not limited by\r\n\t<BigInteger.MAX_EXP> like <pow>.\r\n\r\n\tParameters:\r\n\r\n\t\texponent - The exponent to raise *this* by. Must be positive.\r\n\t\tmodulus - The modulus.\r\n\r\n\tReturns:\r\n\r\n\t\t*this* ^ *exponent* (mod *modulus*).\r\n\r\n\tSee Also:\r\n\r\n\t\t<pow>, <mod>\r\n*/\r\nBigInteger.prototype.modPow = function(exponent, modulus) {\r\n\tvar result = ONE;\r\n\tvar base = this;\r\n\r\n\twhile (exponent.isPositive()) {\r\n\t\tif (exponent.isOdd()) {\r\n\t\t\tresult = result.multiply(base).remainder(modulus);\r\n\t\t}\r\n\r\n\t\texponent = exponent.quotient(BigInteger.small[2]);\r\n\t\tif (exponent.isPositive()) {\r\n\t\t\tbase = base.square().remainder(modulus);\r\n\t\t}\r\n\t}\r\n\r\n\treturn result;\r\n};\r\n\r\n/*\r\n\tFunction: log\r\n\tGet the natural logarithm of a <BigInteger> as a native JavaScript number.\r\n\r\n\tThis is equivalent to\r\n\r\n\t> Math.log(this.toJSValue())\r\n\r\n\tbut handles values outside of the native number range.\r\n\r\n\tReturns:\r\n\r\n\t\tlog( *this* )\r\n\r\n\tSee Also:\r\n\r\n\t\t<toJSValue>\r\n*/\r\nBigInteger.prototype.log = function() {\r\n\tswitch (this._s) {\r\n\tcase 0:\t return -Infinity;\r\n\tcase -1: return NaN;\r\n\tdefault: // Fall through.\r\n\t}\r\n\r\n\tvar l = this._d.length;\r\n\r\n\tif (l*BigInteger_base_log10 < 30) {\r\n\t\treturn Math.log(this.valueOf());\r\n\t}\r\n\r\n\tvar N = Math.ceil(30/BigInteger_base_log10);\r\n\tvar firstNdigits = this._d.slice(l - N);\r\n\treturn Math.log((new BigInteger(firstNdigits, 1, CONSTRUCT)).valueOf()) + (l - N) * Math.log(BigInteger_base);\r\n};\r\n\r\n/*\r\n\tFunction: valueOf\r\n\tConvert a <BigInteger> to a native JavaScript integer.\r\n\r\n\tThis is called automatically by JavaScipt to convert a <BigInteger> to a\r\n\tnative value.\r\n\r\n\tReturns:\r\n\r\n\t\t> parseInt(this.toString(), 10)\r\n\r\n\tSee Also:\r\n\r\n\t\t<toString>, <toJSValue>\r\n*/\r\nBigInteger.prototype.valueOf = function() {\r\n\treturn parseInt(this.toString(), 10);\r\n};\r\n\r\n/*\r\n\tFunction: toJSValue\r\n\tConvert a <BigInteger> to a native JavaScript integer.\r\n\r\n\tThis is the same as valueOf, but more explicitly named.\r\n\r\n\tReturns:\r\n\r\n\t\t> parseInt(this.toString(), 10)\r\n\r\n\tSee Also:\r\n\r\n\t\t<toString>, <valueOf>\r\n*/\r\nBigInteger.prototype.toJSValue = function() {\r\n\treturn parseInt(this.toString(), 10);\r\n};\r\n\r\n/*\r\n\tFunction: lowVal\r\n\tAuthor: Lucas Jones\r\n*/\r\nBigInteger.prototype.lowVal = function () {\r\n\treturn this._d[0] || 0;\r\n};\r\n\r\nvar MAX_EXP = BigInteger(0x7FFFFFFF);\r\n// Constant: MAX_EXP\r\n// The largest exponent allowed in <pow> and <exp10> (0x7FFFFFFF or 2147483647).\r\nBigInteger.MAX_EXP = MAX_EXP;\r\n\r\n(function() {\r\n\tfunction makeUnary(fn) {\r\n\t\treturn function(a) {\r\n\t\t\treturn fn.call(BigInteger(a));\r\n\t\t};\r\n\t}\r\n\r\n\tfunction makeBinary(fn) {\r\n\t\treturn function(a, b) {\r\n\t\t\treturn fn.call(BigInteger(a), BigInteger(b));\r\n\t\t};\r\n\t}\r\n\r\n\tfunction makeTrinary(fn) {\r\n\t\treturn function(a, b, c) {\r\n\t\t\treturn fn.call(BigInteger(a), BigInteger(b), BigInteger(c));\r\n\t\t};\r\n\t}\r\n\r\n\t(function() {\r\n\t\tvar i, fn;\r\n\t\tvar unary = \"toJSValue,isEven,isOdd,sign,isZero,isNegative,abs,isUnit,square,negate,isPositive,toString,next,prev,log\".split(\",\");\r\n\t\tvar binary = \"compare,remainder,divRem,subtract,add,quotient,divide,multiply,pow,compareAbs\".split(\",\");\r\n\t\tvar trinary = [\"modPow\"];\r\n\r\n\t\tfor (i = 0; i < unary.length; i++) {\r\n\t\t\tfn = unary[i];\r\n\t\t\tBigInteger[fn] = makeUnary(BigInteger.prototype[fn]);\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < binary.length; i++) {\r\n\t\t\tfn = binary[i];\r\n\t\t\tBigInteger[fn] = makeBinary(BigInteger.prototype[fn]);\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < trinary.length; i++) {\r\n\t\t\tfn = trinary[i];\r\n\t\t\tBigInteger[fn] = makeTrinary(BigInteger.prototype[fn]);\r\n\t\t}\r\n\r\n\t\tBigInteger.exp10 = function(x, n) {\r\n\t\t\treturn BigInteger(x).exp10(n);\r\n\t\t};\r\n\t})();\r\n})();\r\n\r\nexports.BigInteger = BigInteger;\r\n})( true ? exports : undefined);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvY3J5cHRvbm90ZV91dGlscy9iaWdpbnRlZ2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGlicy9teW1vbmVyby1hcHAtanMvbG9jYWxfbW9kdWxlcy9teW1vbmVyb19jb3JlX2pzL2NyeXB0b25vdGVfdXRpbHMvYmlnaW50ZWdlci5qcz84ZjYzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcblx0SmF2YVNjcmlwdCBCaWdJbnRlZ2VyIGxpYnJhcnkgdmVyc2lvbiAwLjkuMVxyXG5cdGh0dHA6Ly9zaWxlbnRtYXR0LmNvbS9iaWdpbnRlZ2VyL1xyXG5cclxuXHRDb3B5cmlnaHQgKGMpIDIwMDkgTWF0dGhldyBDcnVtbGV5IDxlbWFpbEBtYXR0aGV3Y3J1bWxleS5jb20+XHJcblx0Q29weXJpZ2h0IChjKSAyMDEwLDIwMTEgYnkgSm9obiBUb2JleSA8Sm9obi5Ub2JleUBnbWFpbC5jb20+XHJcblx0TGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxyXG5cclxuXHRTdXBwb3J0IGZvciBhcmJpdHJhcnkgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gYmFzZSB3YXMgYWRkZWQgYnlcclxuXHRWaXRhbHkgTWFnZXJ5YS5cclxuKi9cclxuLypcclxuXHJcblRoaXMgZmlsZSBoYXMgYmVlbiBtb2RpZmllZCBieSBQYXVsIFNoYXBpcm86XHJcblxyXG4xLiB0byBicmluZyBpbiB0aGUgZnVuY3Rpb24gbG93VmFsIHdoaWNoIHdhcyB3cml0dGVuIGJ5IEx1Y2FzIEpvbmVzXHJcbjIuIHRvIGV4cG9zZSBDT05TVFJVQ1RcclxuXHJcbiovXHJcbi8qXHJcblx0RmlsZTogYmlnaW50ZWdlci5qc1xyXG5cclxuXHRFeHBvcnRzOlxyXG5cclxuXHRcdDxCaWdJbnRlZ2VyPlxyXG4qL1xyXG4oZnVuY3Rpb24oZXhwb3J0cykge1xyXG5cInVzZSBzdHJpY3RcIjtcclxuLypcclxuXHRDbGFzczogQmlnSW50ZWdlclxyXG5cdEFuIGFyYml0cmFyaWx5LWxhcmdlIGludGVnZXIuXHJcblxyXG5cdDxCaWdJbnRlZ2VyPiBvYmplY3RzIHNob3VsZCBiZSBjb25zaWRlcmVkIGltbXV0YWJsZS4gTm9uZSBvZiB0aGUgXCJidWlsdC1pblwiXHJcblx0bWV0aG9kcyBtb2RpZnkgKnRoaXMqIG9yIHRoZWlyIGFyZ3VtZW50cy4gQWxsIHByb3BlcnRpZXMgc2hvdWxkIGJlXHJcblx0Y29uc2lkZXJlZCBwcml2YXRlLlxyXG5cclxuXHRBbGwgdGhlIG1ldGhvZHMgb2YgPEJpZ0ludGVnZXI+IGluc3RhbmNlcyBjYW4gYmUgY2FsbGVkIFwic3RhdGljYWxseVwiLiBUaGVcclxuXHRzdGF0aWMgdmVyc2lvbnMgYXJlIGNvbnZlbmllbnQgaWYgeW91IGRvbid0IGFscmVhZHkgaGF2ZSBhIDxCaWdJbnRlZ2VyPlxyXG5cdG9iamVjdC5cclxuXHJcblx0QXMgYW4gZXhhbXBsZSwgdGhlc2UgY2FsbHMgYXJlIGVxdWl2YWxlbnQuXHJcblxyXG5cdD4gQmlnSW50ZWdlcig0KS5tdWx0aXBseSg1KTsgLy8gcmV0dXJucyBCaWdJbnRlZ2VyKDIwKTtcclxuXHQ+IEJpZ0ludGVnZXIubXVsdGlwbHkoNCwgNSk7IC8vIHJldHVybnMgQmlnSW50ZWdlcigyMCk7XHJcblxyXG5cdD4gdmFyIGEgPSA0MjtcclxuXHQ+IHZhciBhID0gQmlnSW50ZWdlci50b0pTVmFsdWUoXCIwYjEwMTAxMFwiKTsgLy8gTm90IGNvbXBsZXRlbHkgdXNlbGVzcy4uLlxyXG4qL1xyXG5cclxudmFyIENPTlNUUlVDVCA9IHt9OyAvLyBVbmlxdWUgdG9rZW4gdG8gY2FsbCBcInByaXZhdGVcIiB2ZXJzaW9uIG9mIGNvbnN0cnVjdG9yXHJcblxyXG4vKlxyXG5cdENvbnN0cnVjdG9yOiBCaWdJbnRlZ2VyKClcclxuXHRDb252ZXJ0IGEgdmFsdWUgdG8gYSA8QmlnSW50ZWdlcj4uXHJcblxyXG5cdEFsdGhvdWdoIDxCaWdJbnRlZ2VyKCk+IGlzIHRoZSBjb25zdHJ1Y3RvciBmb3IgPEJpZ0ludGVnZXI+IG9iamVjdHMsIGl0IGlzXHJcblx0YmVzdCBub3QgdG8gY2FsbCBpdCBhcyBhIGNvbnN0cnVjdG9yLiBJZiAqbiogaXMgYSA8QmlnSW50ZWdlcj4gb2JqZWN0LCBpdCBpc1xyXG5cdHNpbXBseSByZXR1cm5lZCBhcy1pcy4gT3RoZXJ3aXNlLCA8QmlnSW50ZWdlcigpPiBpcyBlcXVpdmFsZW50IHRvIDxwYXJzZT5cclxuXHR3aXRob3V0IGEgcmFkaXggYXJndW1lbnQuXHJcblxyXG5cdD4gdmFyIG4wID0gQmlnSW50ZWdlcigpO1x0ICAvLyBTYW1lIGFzIDxCaWdJbnRlZ2VyLlpFUk8+XHJcblx0PiB2YXIgbjEgPSBCaWdJbnRlZ2VyKFwiMTIzXCIpOyAvLyBDcmVhdGUgYSBuZXcgPEJpZ0ludGVnZXI+IHdpdGggdmFsdWUgMTIzXHJcblx0PiB2YXIgbjIgPSBCaWdJbnRlZ2VyKDEyMyk7ICAgLy8gQ3JlYXRlIGEgbmV3IDxCaWdJbnRlZ2VyPiB3aXRoIHZhbHVlIDEyM1xyXG5cdD4gdmFyIG4zID0gQmlnSW50ZWdlcihuMik7XHQvLyBSZXR1cm4gbjIsIHVuY2hhbmdlZFxyXG5cclxuXHRUaGUgY29uc3RydWN0b3IgZm9ybSBvbmx5IHRha2VzIGFuIGFycmF5IGFuZCBhIHNpZ24uICpuKiBtdXN0IGJlIGFuXHJcblx0YXJyYXkgb2YgbnVtYmVycyBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyLCB3aGVyZSBlYWNoIGRpZ2l0IGlzIGJldHdlZW4gMFxyXG5cdGFuZCBCaWdJbnRlZ2VyLmJhc2UuICBUaGUgc2Vjb25kIHBhcmFtZXRlciBzZXRzIHRoZSBzaWduOiAtMSBmb3JcclxuXHRuZWdhdGl2ZSwgKzEgZm9yIHBvc2l0aXZlLCBvciAwIGZvciB6ZXJvLiBUaGUgYXJyYXkgaXMgKm5vdCBjb3BpZWQgYW5kXHJcblx0bWF5IGJlIG1vZGlmaWVkKi4gSWYgdGhlIGFycmF5IGNvbnRhaW5zIG9ubHkgemVyb3MsIHRoZSBzaWduIHBhcmFtZXRlclxyXG5cdGlzIGlnbm9yZWQgYW5kIGlzIGZvcmNlZCB0byB6ZXJvLlxyXG5cclxuXHQ+IG5ldyBCaWdJbnRlZ2VyKFs1XSwgLTEpOiBjcmVhdGUgYSBuZXcgQmlnSW50ZWdlciB3aXRoIHZhbHVlIC01XHJcblxyXG5cdFBhcmFtZXRlcnM6XHJcblxyXG5cdFx0biAtIFZhbHVlIHRvIGNvbnZlcnQgdG8gYSA8QmlnSW50ZWdlcj4uXHJcblxyXG5cdFJldHVybnM6XHJcblxyXG5cdFx0QSA8QmlnSW50ZWdlcj4gdmFsdWUuXHJcblxyXG5cdFNlZSBBbHNvOlxyXG5cclxuXHRcdDxwYXJzZT4sIDxCaWdJbnRlZ2VyPlxyXG4qL1xyXG5mdW5jdGlvbiBCaWdJbnRlZ2VyKG4sIHMsIHRva2VuKSB7XHJcblx0aWYgKHRva2VuICE9PSBDT05TVFJVQ1QpIHtcclxuXHRcdGlmIChuIGluc3RhbmNlb2YgQmlnSW50ZWdlcikge1xyXG5cdFx0XHRyZXR1cm4gbjtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKHR5cGVvZiBuID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdHJldHVybiBaRVJPO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIEJpZ0ludGVnZXIucGFyc2Uobik7XHJcblx0fVxyXG5cclxuXHRuID0gbiB8fCBbXTsgIC8vIFByb3ZpZGUgdGhlIG51bGxhcnkgY29uc3RydWN0b3IgZm9yIHN1YmNsYXNzZXMuXHJcblx0d2hpbGUgKG4ubGVuZ3RoICYmICFuW24ubGVuZ3RoIC0gMV0pIHtcclxuXHRcdC0tbi5sZW5ndGg7XHJcblx0fVxyXG5cdHRoaXMuX2QgPSBuO1xyXG5cdHRoaXMuX3MgPSBuLmxlbmd0aCA/IChzIHx8IDEpIDogMDtcclxufVxyXG5CaWdJbnRlZ2VyLkNPTlNUUlVDVCA9IENPTlNUUlVDVDsgLy8gYWRkZWQgYnkgUFMgdG8gYWN0dWFsbHkgdXNlIHRoZSBjb25zdHJ1Y3RvclxyXG5cclxuQmlnSW50ZWdlci5fY29uc3RydWN0ID0gZnVuY3Rpb24obiwgcykge1xyXG5cdHJldHVybiBuZXcgQmlnSW50ZWdlcihuLCBzLCBDT05TVFJVQ1QpO1xyXG59O1xyXG5cclxuLy8gQmFzZS0xMCBzcGVlZHVwIGhhY2tzIGluIHBhcnNlLCB0b1N0cmluZywgZXhwMTAgYW5kIGxvZyBmdW5jdGlvbnNcclxuLy8gcmVxdWlyZSBiYXNlIHRvIGJlIGEgcG93ZXIgb2YgMTAuIDEwXjcgaXMgdGhlIGxhcmdlc3Qgc3VjaCBwb3dlclxyXG4vLyB0aGF0IHdvbid0IGNhdXNlIGEgcHJlY2lzaW9uIGxvc3Mgd2hlbiBkaWdpdHMgYXJlIG11bHRpcGxpZWQuXHJcbnZhciBCaWdJbnRlZ2VyX2Jhc2UgPSAxMDAwMDAwMDtcclxudmFyIEJpZ0ludGVnZXJfYmFzZV9sb2cxMCA9IDc7XHJcblxyXG5CaWdJbnRlZ2VyLmJhc2UgPSBCaWdJbnRlZ2VyX2Jhc2U7XHJcbkJpZ0ludGVnZXIuYmFzZV9sb2cxMCA9IEJpZ0ludGVnZXJfYmFzZV9sb2cxMDtcclxuXHJcbnZhciBaRVJPID0gbmV3IEJpZ0ludGVnZXIoW10sIDAsIENPTlNUUlVDVCk7XHJcbi8vIENvbnN0YW50OiBaRVJPXHJcbi8vIDxCaWdJbnRlZ2VyPiAwLlxyXG5CaWdJbnRlZ2VyLlpFUk8gPSBaRVJPO1xyXG5cclxudmFyIE9ORSA9IG5ldyBCaWdJbnRlZ2VyKFsxXSwgMSwgQ09OU1RSVUNUKTtcclxuLy8gQ29uc3RhbnQ6IE9ORVxyXG4vLyA8QmlnSW50ZWdlcj4gMS5cclxuQmlnSW50ZWdlci5PTkUgPSBPTkU7XHJcblxyXG52YXIgTV9PTkUgPSBuZXcgQmlnSW50ZWdlcihPTkUuX2QsIC0xLCBDT05TVFJVQ1QpO1xyXG4vLyBDb25zdGFudDogTV9PTkVcclxuLy8gPEJpZ0ludGVnZXI+IC0xLlxyXG5CaWdJbnRlZ2VyLk1fT05FID0gTV9PTkU7XHJcblxyXG4vLyBDb25zdGFudDogXzBcclxuLy8gU2hvcnRjdXQgZm9yIDxaRVJPPi5cclxuQmlnSW50ZWdlci5fMCA9IFpFUk87XHJcblxyXG4vLyBDb25zdGFudDogXzFcclxuLy8gU2hvcnRjdXQgZm9yIDxPTkU+LlxyXG5CaWdJbnRlZ2VyLl8xID0gT05FO1xyXG5cclxuLypcclxuXHRDb25zdGFudDogc21hbGxcclxuXHRBcnJheSBvZiA8QmlnSW50ZWdlcnM+IGZyb20gMCB0byAzNi5cclxuXHJcblx0VGhlc2UgYXJlIHVzZWQgaW50ZXJuYWxseSBmb3IgcGFyc2luZywgYnV0IHVzZWZ1bCB3aGVuIHlvdSBuZWVkIGEgXCJzbWFsbFwiXHJcblx0PEJpZ0ludGVnZXI+LlxyXG5cclxuXHRTZWUgQWxzbzpcclxuXHJcblx0XHQ8WkVSTz4sIDxPTkU+LCA8XzA+LCA8XzE+XHJcbiovXHJcbkJpZ0ludGVnZXIuc21hbGwgPSBbXHJcblx0WkVSTyxcclxuXHRPTkUsXHJcblx0LyogQXNzdW1pbmcgQmlnSW50ZWdlcl9iYXNlID4gMzYgKi9cclxuXHRuZXcgQmlnSW50ZWdlciggWzJdLCAxLCBDT05TVFJVQ1QpLFxyXG5cdG5ldyBCaWdJbnRlZ2VyKCBbM10sIDEsIENPTlNUUlVDVCksXHJcblx0bmV3IEJpZ0ludGVnZXIoIFs0XSwgMSwgQ09OU1RSVUNUKSxcclxuXHRuZXcgQmlnSW50ZWdlciggWzVdLCAxLCBDT05TVFJVQ1QpLFxyXG5cdG5ldyBCaWdJbnRlZ2VyKCBbNl0sIDEsIENPTlNUUlVDVCksXHJcblx0bmV3IEJpZ0ludGVnZXIoIFs3XSwgMSwgQ09OU1RSVUNUKSxcclxuXHRuZXcgQmlnSW50ZWdlciggWzhdLCAxLCBDT05TVFJVQ1QpLFxyXG5cdG5ldyBCaWdJbnRlZ2VyKCBbOV0sIDEsIENPTlNUUlVDVCksXHJcblx0bmV3IEJpZ0ludGVnZXIoWzEwXSwgMSwgQ09OU1RSVUNUKSxcclxuXHRuZXcgQmlnSW50ZWdlcihbMTFdLCAxLCBDT05TVFJVQ1QpLFxyXG5cdG5ldyBCaWdJbnRlZ2VyKFsxMl0sIDEsIENPTlNUUlVDVCksXHJcblx0bmV3IEJpZ0ludGVnZXIoWzEzXSwgMSwgQ09OU1RSVUNUKSxcclxuXHRuZXcgQmlnSW50ZWdlcihbMTRdLCAxLCBDT05TVFJVQ1QpLFxyXG5cdG5ldyBCaWdJbnRlZ2VyKFsxNV0sIDEsIENPTlNUUlVDVCksXHJcblx0bmV3IEJpZ0ludGVnZXIoWzE2XSwgMSwgQ09OU1RSVUNUKSxcclxuXHRuZXcgQmlnSW50ZWdlcihbMTddLCAxLCBDT05TVFJVQ1QpLFxyXG5cdG5ldyBCaWdJbnRlZ2VyKFsxOF0sIDEsIENPTlNUUlVDVCksXHJcblx0bmV3IEJpZ0ludGVnZXIoWzE5XSwgMSwgQ09OU1RSVUNUKSxcclxuXHRuZXcgQmlnSW50ZWdlcihbMjBdLCAxLCBDT05TVFJVQ1QpLFxyXG5cdG5ldyBCaWdJbnRlZ2VyKFsyMV0sIDEsIENPTlNUUlVDVCksXHJcblx0bmV3IEJpZ0ludGVnZXIoWzIyXSwgMSwgQ09OU1RSVUNUKSxcclxuXHRuZXcgQmlnSW50ZWdlcihbMjNdLCAxLCBDT05TVFJVQ1QpLFxyXG5cdG5ldyBCaWdJbnRlZ2VyKFsyNF0sIDEsIENPTlNUUlVDVCksXHJcblx0bmV3IEJpZ0ludGVnZXIoWzI1XSwgMSwgQ09OU1RSVUNUKSxcclxuXHRuZXcgQmlnSW50ZWdlcihbMjZdLCAxLCBDT05TVFJVQ1QpLFxyXG5cdG5ldyBCaWdJbnRlZ2VyKFsyN10sIDEsIENPTlNUUlVDVCksXHJcblx0bmV3IEJpZ0ludGVnZXIoWzI4XSwgMSwgQ09OU1RSVUNUKSxcclxuXHRuZXcgQmlnSW50ZWdlcihbMjldLCAxLCBDT05TVFJVQ1QpLFxyXG5cdG5ldyBCaWdJbnRlZ2VyKFszMF0sIDEsIENPTlNUUlVDVCksXHJcblx0bmV3IEJpZ0ludGVnZXIoWzMxXSwgMSwgQ09OU1RSVUNUKSxcclxuXHRuZXcgQmlnSW50ZWdlcihbMzJdLCAxLCBDT05TVFJVQ1QpLFxyXG5cdG5ldyBCaWdJbnRlZ2VyKFszM10sIDEsIENPTlNUUlVDVCksXHJcblx0bmV3IEJpZ0ludGVnZXIoWzM0XSwgMSwgQ09OU1RSVUNUKSxcclxuXHRuZXcgQmlnSW50ZWdlcihbMzVdLCAxLCBDT05TVFJVQ1QpLFxyXG5cdG5ldyBCaWdJbnRlZ2VyKFszNl0sIDEsIENPTlNUUlVDVClcclxuXTtcclxuXHJcbi8vIFVzZWQgZm9yIHBhcnNpbmcvcmFkaXggY29udmVyc2lvblxyXG5CaWdJbnRlZ2VyLmRpZ2l0cyA9IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCIuc3BsaXQoXCJcIik7XHJcblxyXG4vKlxyXG5cdE1ldGhvZDogdG9TdHJpbmdcclxuXHRDb252ZXJ0IGEgPEJpZ0ludGVnZXI+IHRvIGEgc3RyaW5nLlxyXG5cclxuXHRXaGVuICpiYXNlKiBpcyBncmVhdGVyIHRoYW4gMTAsIGxldHRlcnMgYXJlIHVwcGVyIGNhc2UuXHJcblxyXG5cdFBhcmFtZXRlcnM6XHJcblxyXG5cdFx0YmFzZSAtIE9wdGlvbmFsIGJhc2UgdG8gcmVwcmVzZW50IHRoZSBudW1iZXIgaW4gKGRlZmF1bHQgaXMgYmFzZSAxMCkuXHJcblx0XHRcdCAgIE11c3QgYmUgYmV0d2VlbiAyIGFuZCAzNiBpbmNsdXNpdmUsIG9yIGFuIEVycm9yIHdpbGwgYmUgdGhyb3duLlxyXG5cclxuXHRSZXR1cm5zOlxyXG5cclxuXHRcdFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIDxCaWdJbnRlZ2VyPi5cclxuKi9cclxuQmlnSW50ZWdlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihiYXNlKSB7XHJcblx0YmFzZSA9ICtiYXNlIHx8IDEwO1xyXG5cdGlmIChiYXNlIDwgMiB8fCBiYXNlID4gMzYpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgcmFkaXggXCIgKyBiYXNlICsgXCIuXCIpO1xyXG5cdH1cclxuXHRpZiAodGhpcy5fcyA9PT0gMCkge1xyXG5cdFx0cmV0dXJuIFwiMFwiO1xyXG5cdH1cclxuXHRpZiAoYmFzZSA9PT0gMTApIHtcclxuXHRcdHZhciBzdHIgPSB0aGlzLl9zIDwgMCA/IFwiLVwiIDogXCJcIjtcclxuXHRcdHN0ciArPSB0aGlzLl9kW3RoaXMuX2QubGVuZ3RoIC0gMV0udG9TdHJpbmcoKTtcclxuXHRcdGZvciAodmFyIGkgPSB0aGlzLl9kLmxlbmd0aCAtIDI7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdHZhciBncm91cCA9IHRoaXMuX2RbaV0udG9TdHJpbmcoKTtcclxuXHRcdFx0d2hpbGUgKGdyb3VwLmxlbmd0aCA8IEJpZ0ludGVnZXJfYmFzZV9sb2cxMCkgZ3JvdXAgPSAnMCcgKyBncm91cDtcclxuXHRcdFx0c3RyICs9IGdyb3VwO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHN0cjtcclxuXHR9XHJcblx0ZWxzZSB7XHJcblx0XHR2YXIgbnVtZXJhbHMgPSBCaWdJbnRlZ2VyLmRpZ2l0cztcclxuXHRcdGJhc2UgPSBCaWdJbnRlZ2VyLnNtYWxsW2Jhc2VdO1xyXG5cdFx0dmFyIHNpZ24gPSB0aGlzLl9zO1xyXG5cclxuXHRcdHZhciBuID0gdGhpcy5hYnMoKTtcclxuXHRcdHZhciBkaWdpdHMgPSBbXTtcclxuXHRcdHZhciBkaWdpdDtcclxuXHJcblx0XHR3aGlsZSAobi5fcyAhPT0gMCkge1xyXG5cdFx0XHR2YXIgZGl2bW9kID0gbi5kaXZSZW0oYmFzZSk7XHJcblx0XHRcdG4gPSBkaXZtb2RbMF07XHJcblx0XHRcdGRpZ2l0ID0gZGl2bW9kWzFdO1xyXG5cdFx0XHQvLyBUT0RPOiBUaGlzIGNvdWxkIGJlIGNoYW5nZWQgdG8gdW5zaGlmdCBpbnN0ZWFkIG9mIHJldmVyc2luZyBhdCB0aGUgZW5kLlxyXG5cdFx0XHQvLyBCZW5jaG1hcmsgYm90aCB0byBjb21wYXJlIHNwZWVkcy5cclxuXHRcdFx0ZGlnaXRzLnB1c2gobnVtZXJhbHNbZGlnaXQudmFsdWVPZigpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKHNpZ24gPCAwID8gXCItXCIgOiBcIlwiKSArIGRpZ2l0cy5yZXZlcnNlKCkuam9pbihcIlwiKTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBWZXJpZnkgc3RyaW5ncyBmb3IgcGFyc2luZ1xyXG5CaWdJbnRlZ2VyLnJhZGl4UmVnZXggPSBbXHJcblx0L14kLyxcclxuXHQvXiQvLFxyXG5cdC9eWzAxXSokLyxcclxuXHQvXlswMTJdKiQvLFxyXG5cdC9eWzAtM10qJC8sXHJcblx0L15bMC00XSokLyxcclxuXHQvXlswLTVdKiQvLFxyXG5cdC9eWzAtNl0qJC8sXHJcblx0L15bMC03XSokLyxcclxuXHQvXlswLThdKiQvLFxyXG5cdC9eWzAtOV0qJC8sXHJcblx0L15bMC05YUFdKiQvLFxyXG5cdC9eWzAtOWFiQUJdKiQvLFxyXG5cdC9eWzAtOWFiY0FCQ10qJC8sXHJcblx0L15bMC05YS1kQS1EXSokLyxcclxuXHQvXlswLTlhLWVBLUVdKiQvLFxyXG5cdC9eWzAtOWEtZkEtRl0qJC8sXHJcblx0L15bMC05YS1nQS1HXSokLyxcclxuXHQvXlswLTlhLWhBLUhdKiQvLFxyXG5cdC9eWzAtOWEtaUEtSV0qJC8sXHJcblx0L15bMC05YS1qQS1KXSokLyxcclxuXHQvXlswLTlhLWtBLUtdKiQvLFxyXG5cdC9eWzAtOWEtbEEtTF0qJC8sXHJcblx0L15bMC05YS1tQS1NXSokLyxcclxuXHQvXlswLTlhLW5BLU5dKiQvLFxyXG5cdC9eWzAtOWEtb0EtT10qJC8sXHJcblx0L15bMC05YS1wQS1QXSokLyxcclxuXHQvXlswLTlhLXFBLVFdKiQvLFxyXG5cdC9eWzAtOWEtckEtUl0qJC8sXHJcblx0L15bMC05YS1zQS1TXSokLyxcclxuXHQvXlswLTlhLXRBLVRdKiQvLFxyXG5cdC9eWzAtOWEtdUEtVV0qJC8sXHJcblx0L15bMC05YS12QS1WXSokLyxcclxuXHQvXlswLTlhLXdBLVddKiQvLFxyXG5cdC9eWzAtOWEteEEtWF0qJC8sXHJcblx0L15bMC05YS15QS1ZXSokLyxcclxuXHQvXlswLTlhLXpBLVpdKiQvXHJcbl07XHJcblxyXG4vKlxyXG5cdEZ1bmN0aW9uOiBwYXJzZVxyXG5cdFBhcnNlIGEgc3RyaW5nIGludG8gYSA8QmlnSW50ZWdlcj4uXHJcblxyXG5cdCpiYXNlKiBpcyBvcHRpb25hbCBidXQsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGZyb20gMiB0byAzNiBpbmNsdXNpdmUuIElmXHJcblx0KmJhc2UqIGlzIG5vdCBwcm92aWRlZCwgaXQgd2lsbCBiZSBndWVzc2VkIGJhc2VkIG9uIHRoZSBsZWFkaW5nIGNoYXJhY3RlcnNcclxuXHRvZiAqcyogYXMgZm9sbG93czpcclxuXHJcblx0LSBcIjB4XCIgb3IgXCIwWFwiOiAqYmFzZSogPSAxNlxyXG5cdC0gXCIwY1wiIG9yIFwiMENcIjogKmJhc2UqID0gOFxyXG5cdC0gXCIwYlwiIG9yIFwiMEJcIjogKmJhc2UqID0gMlxyXG5cdC0gZWxzZTogKmJhc2UqID0gMTBcclxuXHJcblx0SWYgbm8gYmFzZSBpcyBwcm92aWRlZCwgb3IgKmJhc2UqIGlzIDEwLCB0aGUgbnVtYmVyIGNhbiBiZSBpbiBleHBvbmVudGlhbFxyXG5cdGZvcm0uIEZvciBleGFtcGxlLCB0aGVzZSBhcmUgYWxsIHZhbGlkOlxyXG5cclxuXHQ+IEJpZ0ludGVnZXIucGFyc2UoXCIxZTlcIik7XHRcdFx0ICAvLyBTYW1lIGFzIFwiMTAwMDAwMDAwMFwiXHJcblx0PiBCaWdJbnRlZ2VyLnBhcnNlKFwiMS4yMzQqMTBeM1wiKTtcdCAgIC8vIFNhbWUgYXMgMTIzNFxyXG5cdD4gQmlnSW50ZWdlci5wYXJzZShcIjU2Nzg5ICogMTAgKiogLTJcIik7IC8vIFNhbWUgYXMgNTY3XHJcblxyXG5cdElmIGFueSBjaGFyYWN0ZXJzIGZhbGwgb3V0c2lkZSB0aGUgcmFuZ2UgZGVmaW5lZCBieSB0aGUgcmFkaXgsIGFuIGV4Y2VwdGlvblxyXG5cdHdpbGwgYmUgdGhyb3duLlxyXG5cclxuXHRQYXJhbWV0ZXJzOlxyXG5cclxuXHRcdHMgLSBUaGUgc3RyaW5nIHRvIHBhcnNlLlxyXG5cdFx0YmFzZSAtIE9wdGlvbmFsIHJhZGl4IChkZWZhdWx0IGlzIHRvIGd1ZXNzIGJhc2VkIG9uICpzKikuXHJcblxyXG5cdFJldHVybnM6XHJcblxyXG5cdFx0YSA8QmlnSW50ZWdlcj4gaW5zdGFuY2UuXHJcbiovXHJcbkJpZ0ludGVnZXIucGFyc2UgPSBmdW5jdGlvbihzLCBiYXNlKSB7XHJcblx0Ly8gRXhwYW5kcyBhIG51bWJlciBpbiBleHBvbmVudGlhbCBmb3JtIHRvIGRlY2ltYWwgZm9ybS5cclxuXHQvLyBleHBhbmRFeHBvbmVudGlhbChcIi0xMy40NDEqMTBeNVwiKSA9PT0gXCIxMzQ0MTAwXCI7XHJcblx0Ly8gZXhwYW5kRXhwb25lbnRpYWwoXCIxLjEyMzAwZS0xXCIpID09PSBcIjAuMTEyMzAwXCI7XHJcblx0Ly8gZXhwYW5kRXhwb25lbnRpYWwoMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCkgPT09IFwiMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xyXG5cdGZ1bmN0aW9uIGV4cGFuZEV4cG9uZW50aWFsKHN0cikge1xyXG5cdFx0c3RyID0gc3RyLnJlcGxhY2UoL1xccypbKnhYXVxccyoxMFxccyooXFxefFxcKlxcKilcXHMqLywgXCJlXCIpO1xyXG5cclxuXHRcdHJldHVybiBzdHIucmVwbGFjZSgvXihbK1xcLV0pPyhcXGQrKVxcLj8oXFxkKilbZUVdKFsrXFwtXT9cXGQrKSQvLCBmdW5jdGlvbih4LCBzLCBuLCBmLCBjKSB7XHJcblx0XHRcdGMgPSArYztcclxuXHRcdFx0dmFyIGwgPSBjIDwgMDtcclxuXHRcdFx0dmFyIGkgPSBuLmxlbmd0aCArIGM7XHJcblx0XHRcdHggPSAobCA/IG4gOiBmKS5sZW5ndGg7XHJcblx0XHRcdGMgPSAoKGMgPSBNYXRoLmFicyhjKSkgPj0geCA/IGMgLSB4ICsgbCA6IDApO1xyXG5cdFx0XHR2YXIgeiA9IChuZXcgQXJyYXkoYyArIDEpKS5qb2luKFwiMFwiKTtcclxuXHRcdFx0dmFyIHIgPSBuICsgZjtcclxuXHRcdFx0cmV0dXJuIChzIHx8IFwiXCIpICsgKGwgPyByID0geiArIHIgOiByICs9IHopLnN1YnN0cigwLCBpICs9IGwgPyB6Lmxlbmd0aCA6IDApICsgKGkgPCByLmxlbmd0aCA/IFwiLlwiICsgci5zdWJzdHIoaSkgOiBcIlwiKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0cyA9IHMudG9TdHJpbmcoKTtcclxuXHRpZiAodHlwZW9mIGJhc2UgPT09IFwidW5kZWZpbmVkXCIgfHwgK2Jhc2UgPT09IDEwKSB7XHJcblx0XHRzID0gZXhwYW5kRXhwb25lbnRpYWwocyk7XHJcblx0fVxyXG5cclxuXHR2YXIgcHJlZml4UkU7XHJcblx0aWYgKHR5cGVvZiBiYXNlID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRwcmVmaXhSRSA9ICcwW3hjYl0nO1xyXG5cdH1cclxuXHRlbHNlIGlmIChiYXNlID09IDE2KSB7XHJcblx0XHRwcmVmaXhSRSA9ICcweCc7XHJcblx0fVxyXG5cdGVsc2UgaWYgKGJhc2UgPT0gOCkge1xyXG5cdFx0cHJlZml4UkUgPSAnMGMnO1xyXG5cdH1cclxuXHRlbHNlIGlmIChiYXNlID09IDIpIHtcclxuXHRcdHByZWZpeFJFID0gJzBiJztcclxuXHR9XHJcblx0ZWxzZSB7XHJcblx0XHRwcmVmaXhSRSA9ICcnO1xyXG5cdH1cclxuXHR2YXIgcGFydHMgPSBuZXcgUmVnRXhwKCdeKFsrXFxcXC1dPykoJyArIHByZWZpeFJFICsgJyk/KFswLTlhLXpdKikoPzpcXFxcLlxcXFxkKik/JCcsICdpJykuZXhlYyhzKTtcclxuXHRpZiAocGFydHMpIHtcclxuXHRcdHZhciBzaWduID0gcGFydHNbMV0gfHwgXCIrXCI7XHJcblx0XHR2YXIgYmFzZVNlY3Rpb24gPSBwYXJ0c1syXSB8fCBcIlwiO1xyXG5cdFx0dmFyIGRpZ2l0cyA9IHBhcnRzWzNdIHx8IFwiXCI7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBiYXNlID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdC8vIEd1ZXNzIGJhc2VcclxuXHRcdFx0aWYgKGJhc2VTZWN0aW9uID09PSBcIjB4XCIgfHwgYmFzZVNlY3Rpb24gPT09IFwiMFhcIikgeyAvLyBIZXhcclxuXHRcdFx0XHRiYXNlID0gMTY7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAoYmFzZVNlY3Rpb24gPT09IFwiMGNcIiB8fCBiYXNlU2VjdGlvbiA9PT0gXCIwQ1wiKSB7IC8vIE9jdGFsXHJcblx0XHRcdFx0YmFzZSA9IDg7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAoYmFzZVNlY3Rpb24gPT09IFwiMGJcIiB8fCBiYXNlU2VjdGlvbiA9PT0gXCIwQlwiKSB7IC8vIEJpbmFyeVxyXG5cdFx0XHRcdGJhc2UgPSAyO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGJhc2UgPSAxMDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAoYmFzZSA8IDIgfHwgYmFzZSA+IDM2KSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgcmFkaXggXCIgKyBiYXNlICsgXCIuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGJhc2UgPSArYmFzZTtcclxuXHJcblx0XHQvLyBDaGVjayBmb3IgZGlnaXRzIG91dHNpZGUgdGhlIHJhbmdlXHJcblx0XHRpZiAoIShCaWdJbnRlZ2VyLnJhZGl4UmVnZXhbYmFzZV0udGVzdChkaWdpdHMpKSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJCYWQgZGlnaXQgZm9yIHJhZGl4IFwiICsgYmFzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU3RyaXAgbGVhZGluZyB6ZXJvcywgYW5kIGNvbnZlcnQgdG8gYXJyYXlcclxuXHRcdGRpZ2l0cyA9IGRpZ2l0cy5yZXBsYWNlKC9eMCsvLCBcIlwiKS5zcGxpdChcIlwiKTtcclxuXHRcdGlmIChkaWdpdHMubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdHJldHVybiBaRVJPO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEdldCB0aGUgc2lnbiAod2Uga25vdyBpdCdzIG5vdCB6ZXJvKVxyXG5cdFx0c2lnbiA9IChzaWduID09PSBcIi1cIikgPyAtMSA6IDE7XHJcblxyXG5cdFx0Ly8gT3B0aW1pemUgMTBcclxuXHRcdGlmIChiYXNlID09IDEwKSB7XHJcblx0XHRcdHZhciBkID0gW107XHJcblx0XHRcdHdoaWxlIChkaWdpdHMubGVuZ3RoID49IEJpZ0ludGVnZXJfYmFzZV9sb2cxMCkge1xyXG5cdFx0XHRcdGQucHVzaChwYXJzZUludChkaWdpdHMuc3BsaWNlKGRpZ2l0cy5sZW5ndGgtQmlnSW50ZWdlci5iYXNlX2xvZzEwLCBCaWdJbnRlZ2VyLmJhc2VfbG9nMTApLmpvaW4oJycpLCAxMCkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGQucHVzaChwYXJzZUludChkaWdpdHMuam9pbignJyksIDEwKSk7XHJcblx0XHRcdHJldHVybiBuZXcgQmlnSW50ZWdlcihkLCBzaWduLCBDT05TVFJVQ1QpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIERvIHRoZSBjb252ZXJzaW9uXHJcblx0XHR2YXIgZCA9IFpFUk87XHJcblx0XHRiYXNlID0gQmlnSW50ZWdlci5zbWFsbFtiYXNlXTtcclxuXHRcdHZhciBzbWFsbCA9IEJpZ0ludGVnZXIuc21hbGw7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRpZ2l0cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRkID0gZC5tdWx0aXBseShiYXNlKS5hZGQoc21hbGxbcGFyc2VJbnQoZGlnaXRzW2ldLCAzNildKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgQmlnSW50ZWdlcihkLl9kLCBzaWduLCBDT05TVFJVQ1QpO1xyXG5cdH1cclxuXHRlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgQmlnSW50ZWdlciBmb3JtYXQ6IFwiICsgcyk7XHJcblx0fVxyXG59O1xyXG5cclxuLypcclxuXHRGdW5jdGlvbjogYWRkXHJcblx0QWRkIHR3byA8QmlnSW50ZWdlcnM+LlxyXG5cclxuXHRQYXJhbWV0ZXJzOlxyXG5cclxuXHRcdG4gLSBUaGUgbnVtYmVyIHRvIGFkZCB0byAqdGhpcyouIFdpbGwgYmUgY29udmVydGVkIHRvIGEgPEJpZ0ludGVnZXI+LlxyXG5cclxuXHRSZXR1cm5zOlxyXG5cclxuXHRcdFRoZSBudW1iZXJzIGFkZGVkIHRvZ2V0aGVyLlxyXG5cclxuXHRTZWUgQWxzbzpcclxuXHJcblx0XHQ8c3VidHJhY3Q+LCA8bXVsdGlwbHk+LCA8cXVvdGllbnQ+LCA8bmV4dD5cclxuKi9cclxuQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obikge1xyXG5cdGlmICh0aGlzLl9zID09PSAwKSB7XHJcblx0XHRyZXR1cm4gQmlnSW50ZWdlcihuKTtcclxuXHR9XHJcblxyXG5cdG4gPSBCaWdJbnRlZ2VyKG4pO1xyXG5cdGlmIChuLl9zID09PSAwKSB7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblx0aWYgKHRoaXMuX3MgIT09IG4uX3MpIHtcclxuXHRcdG4gPSBuLm5lZ2F0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc3VidHJhY3Qobik7XHJcblx0fVxyXG5cclxuXHR2YXIgYSA9IHRoaXMuX2Q7XHJcblx0dmFyIGIgPSBuLl9kO1xyXG5cdHZhciBhbCA9IGEubGVuZ3RoO1xyXG5cdHZhciBibCA9IGIubGVuZ3RoO1xyXG5cdHZhciBzdW0gPSBuZXcgQXJyYXkoTWF0aC5tYXgoYWwsIGJsKSArIDEpO1xyXG5cdHZhciBzaXplID0gTWF0aC5taW4oYWwsIGJsKTtcclxuXHR2YXIgY2FycnkgPSAwO1xyXG5cdHZhciBkaWdpdDtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcclxuXHRcdGRpZ2l0ID0gYVtpXSArIGJbaV0gKyBjYXJyeTtcclxuXHRcdHN1bVtpXSA9IGRpZ2l0ICUgQmlnSW50ZWdlcl9iYXNlO1xyXG5cdFx0Y2FycnkgPSAoZGlnaXQgLyBCaWdJbnRlZ2VyX2Jhc2UpIHwgMDtcclxuXHR9XHJcblx0aWYgKGJsID4gYWwpIHtcclxuXHRcdGEgPSBiO1xyXG5cdFx0YWwgPSBibDtcclxuXHR9XHJcblx0Zm9yIChpID0gc2l6ZTsgY2FycnkgJiYgaSA8IGFsOyBpKyspIHtcclxuXHRcdGRpZ2l0ID0gYVtpXSArIGNhcnJ5O1xyXG5cdFx0c3VtW2ldID0gZGlnaXQgJSBCaWdJbnRlZ2VyX2Jhc2U7XHJcblx0XHRjYXJyeSA9IChkaWdpdCAvIEJpZ0ludGVnZXJfYmFzZSkgfCAwO1xyXG5cdH1cclxuXHRpZiAoY2FycnkpIHtcclxuXHRcdHN1bVtpXSA9IGNhcnJ5O1xyXG5cdH1cclxuXHJcblx0Zm9yICggOyBpIDwgYWw7IGkrKykge1xyXG5cdFx0c3VtW2ldID0gYVtpXTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBuZXcgQmlnSW50ZWdlcihzdW0sIHRoaXMuX3MsIENPTlNUUlVDVCk7XHJcbn07XHJcblxyXG4vKlxyXG5cdEZ1bmN0aW9uOiBuZWdhdGVcclxuXHRHZXQgdGhlIGFkZGl0aXZlIGludmVyc2Ugb2YgYSA8QmlnSW50ZWdlcj4uXHJcblxyXG5cdFJldHVybnM6XHJcblxyXG5cdFx0QSA8QmlnSW50ZWdlcj4gd2l0aCB0aGUgc2FtZSBtYWduYXR1ZGUsIGJ1dCB3aXRoIHRoZSBvcHBvc2l0ZSBzaWduLlxyXG5cclxuXHRTZWUgQWxzbzpcclxuXHJcblx0XHQ8YWJzPlxyXG4qL1xyXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IEJpZ0ludGVnZXIodGhpcy5fZCwgKC10aGlzLl9zKSB8IDAsIENPTlNUUlVDVCk7XHJcbn07XHJcblxyXG4vKlxyXG5cdEZ1bmN0aW9uOiBhYnNcclxuXHRHZXQgdGhlIGFic29sdXRlIHZhbHVlIG9mIGEgPEJpZ0ludGVnZXI+LlxyXG5cclxuXHRSZXR1cm5zOlxyXG5cclxuXHRcdEEgPEJpZ0ludGVnZXI+IHdpdGggdGhlIHNhbWUgbWFnbmF0dWRlLCBidXQgYWx3YXlzIHBvc2l0aXZlIChvciB6ZXJvKS5cclxuXHJcblx0U2VlIEFsc286XHJcblxyXG5cdFx0PG5lZ2F0ZT5cclxuKi9cclxuQmlnSW50ZWdlci5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuICh0aGlzLl9zIDwgMCkgPyB0aGlzLm5lZ2F0ZSgpIDogdGhpcztcclxufTtcclxuXHJcbi8qXHJcblx0RnVuY3Rpb246IHN1YnRyYWN0XHJcblx0U3VidHJhY3QgdHdvIDxCaWdJbnRlZ2Vycz4uXHJcblxyXG5cdFBhcmFtZXRlcnM6XHJcblxyXG5cdFx0biAtIFRoZSBudW1iZXIgdG8gc3VidHJhY3QgZnJvbSAqdGhpcyouIFdpbGwgYmUgY29udmVydGVkIHRvIGEgPEJpZ0ludGVnZXI+LlxyXG5cclxuXHRSZXR1cm5zOlxyXG5cclxuXHRcdFRoZSAqbiogc3VidHJhY3RlZCBmcm9tICp0aGlzKi5cclxuXHJcblx0U2VlIEFsc286XHJcblxyXG5cdFx0PGFkZD4sIDxtdWx0aXBseT4sIDxxdW90aWVudD4sIDxwcmV2PlxyXG4qL1xyXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG4pIHtcclxuXHRpZiAodGhpcy5fcyA9PT0gMCkge1xyXG5cdFx0cmV0dXJuIEJpZ0ludGVnZXIobikubmVnYXRlKCk7XHJcblx0fVxyXG5cclxuXHRuID0gQmlnSW50ZWdlcihuKTtcclxuXHRpZiAobi5fcyA9PT0gMCkge1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cdGlmICh0aGlzLl9zICE9PSBuLl9zKSB7XHJcblx0XHRuID0gbi5uZWdhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzLmFkZChuKTtcclxuXHR9XHJcblxyXG5cdHZhciBtID0gdGhpcztcclxuXHQvLyBuZWdhdGl2ZSAtIG5lZ2F0aXZlID0+IC18YXwgLSAtfGJ8ID0+IC18YXwgKyB8YnwgPT4gfGJ8IC0gfGF8XHJcblx0aWYgKHRoaXMuX3MgPCAwKSB7XHJcblx0XHRtID0gbmV3IEJpZ0ludGVnZXIobi5fZCwgMSwgQ09OU1RSVUNUKTtcclxuXHRcdG4gPSBuZXcgQmlnSW50ZWdlcih0aGlzLl9kLCAxLCBDT05TVFJVQ1QpO1xyXG5cdH1cclxuXHJcblx0Ly8gQm90aCBhcmUgcG9zaXRpdmUgPT4gYSAtIGJcclxuXHR2YXIgc2lnbiA9IG0uY29tcGFyZUFicyhuKTtcclxuXHRpZiAoc2lnbiA9PT0gMCkge1xyXG5cdFx0cmV0dXJuIFpFUk87XHJcblx0fVxyXG5cdGVsc2UgaWYgKHNpZ24gPCAwKSB7XHJcblx0XHQvLyBzd2FwIG0gYW5kIG5cclxuXHRcdHZhciB0ID0gbjtcclxuXHRcdG4gPSBtO1xyXG5cdFx0bSA9IHQ7XHJcblx0fVxyXG5cclxuXHQvLyBhID4gYlxyXG5cdHZhciBhID0gbS5fZDtcclxuXHR2YXIgYiA9IG4uX2Q7XHJcblx0dmFyIGFsID0gYS5sZW5ndGg7XHJcblx0dmFyIGJsID0gYi5sZW5ndGg7XHJcblx0dmFyIGRpZmYgPSBuZXcgQXJyYXkoYWwpOyAvLyBhbCA+PSBibCBzaW5jZSBhID4gYlxyXG5cdHZhciBib3Jyb3cgPSAwO1xyXG5cdHZhciBpO1xyXG5cdHZhciBkaWdpdDtcclxuXHJcblx0Zm9yIChpID0gMDsgaSA8IGJsOyBpKyspIHtcclxuXHRcdGRpZ2l0ID0gYVtpXSAtIGJvcnJvdyAtIGJbaV07XHJcblx0XHRpZiAoZGlnaXQgPCAwKSB7XHJcblx0XHRcdGRpZ2l0ICs9IEJpZ0ludGVnZXJfYmFzZTtcclxuXHRcdFx0Ym9ycm93ID0gMTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRib3Jyb3cgPSAwO1xyXG5cdFx0fVxyXG5cdFx0ZGlmZltpXSA9IGRpZ2l0O1xyXG5cdH1cclxuXHRmb3IgKGkgPSBibDsgaSA8IGFsOyBpKyspIHtcclxuXHRcdGRpZ2l0ID0gYVtpXSAtIGJvcnJvdztcclxuXHRcdGlmIChkaWdpdCA8IDApIHtcclxuXHRcdFx0ZGlnaXQgKz0gQmlnSW50ZWdlcl9iYXNlO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGRpZmZbaSsrXSA9IGRpZ2l0O1xyXG5cdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHRcdGRpZmZbaV0gPSBkaWdpdDtcclxuXHR9XHJcblx0Zm9yICggOyBpIDwgYWw7IGkrKykge1xyXG5cdFx0ZGlmZltpXSA9IGFbaV07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3IEJpZ0ludGVnZXIoZGlmZiwgc2lnbiwgQ09OU1RSVUNUKTtcclxufTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHRmdW5jdGlvbiBhZGRPbmUobiwgc2lnbikge1xyXG5cdFx0dmFyIGEgPSBuLl9kO1xyXG5cdFx0dmFyIHN1bSA9IGEuc2xpY2UoKTtcclxuXHRcdHZhciBjYXJyeSA9IHRydWU7XHJcblx0XHR2YXIgaSA9IDA7XHJcblxyXG5cdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0dmFyIGRpZ2l0ID0gKGFbaV0gfHwgMCkgKyAxO1xyXG5cdFx0XHRzdW1baV0gPSBkaWdpdCAlIEJpZ0ludGVnZXJfYmFzZTtcclxuXHRcdFx0aWYgKGRpZ2l0IDw9IEJpZ0ludGVnZXJfYmFzZSAtIDEpIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHQrK2k7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHN1bSwgc2lnbiwgQ09OU1RSVUNUKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHN1YnRyYWN0T25lKG4sIHNpZ24pIHtcclxuXHRcdHZhciBhID0gbi5fZDtcclxuXHRcdHZhciBzdW0gPSBhLnNsaWNlKCk7XHJcblx0XHR2YXIgYm9ycm93ID0gdHJ1ZTtcclxuXHRcdHZhciBpID0gMDtcclxuXHJcblx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHR2YXIgZGlnaXQgPSAoYVtpXSB8fCAwKSAtIDE7XHJcblx0XHRcdGlmIChkaWdpdCA8IDApIHtcclxuXHRcdFx0XHRzdW1baV0gPSBkaWdpdCArIEJpZ0ludGVnZXJfYmFzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRzdW1baV0gPSBkaWdpdDtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHQrK2k7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHN1bSwgc2lnbiwgQ09OU1RSVUNUKTtcclxuXHR9XHJcblxyXG5cdC8qXHJcblx0XHRGdW5jdGlvbjogbmV4dFxyXG5cdFx0R2V0IHRoZSBuZXh0IDxCaWdJbnRlZ2VyPiAoYWRkIG9uZSkuXHJcblxyXG5cdFx0UmV0dXJuczpcclxuXHJcblx0XHRcdCp0aGlzKiArIDEuXHJcblxyXG5cdFx0U2VlIEFsc286XHJcblxyXG5cdFx0XHQ8YWRkPiwgPHByZXY+XHJcblx0Ki9cclxuXHRCaWdJbnRlZ2VyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRzd2l0Y2ggKHRoaXMuX3MpIHtcclxuXHRcdGNhc2UgMDpcclxuXHRcdFx0cmV0dXJuIE9ORTtcclxuXHRcdGNhc2UgLTE6XHJcblx0XHRcdHJldHVybiBzdWJ0cmFjdE9uZSh0aGlzLCAtMSk7XHJcblx0XHQvLyBjYXNlIDE6XHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHRyZXR1cm4gYWRkT25lKHRoaXMsIDEpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0XHRGdW5jdGlvbjogcHJldlxyXG5cdFx0R2V0IHRoZSBwcmV2aW91cyA8QmlnSW50ZWdlcj4gKHN1YnRyYWN0IG9uZSkuXHJcblxyXG5cdFx0UmV0dXJuczpcclxuXHJcblx0XHRcdCp0aGlzKiAtIDEuXHJcblxyXG5cdFx0U2VlIEFsc286XHJcblxyXG5cdFx0XHQ8bmV4dD4sIDxzdWJ0cmFjdD5cclxuXHQqL1xyXG5cdEJpZ0ludGVnZXIucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbigpIHtcclxuXHRcdHN3aXRjaCAodGhpcy5fcykge1xyXG5cdFx0Y2FzZSAwOlxyXG5cdFx0XHRyZXR1cm4gTV9PTkU7XHJcblx0XHRjYXNlIC0xOlxyXG5cdFx0XHRyZXR1cm4gYWRkT25lKHRoaXMsIC0xKTtcclxuXHRcdC8vIGNhc2UgMTpcclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdHJldHVybiBzdWJ0cmFjdE9uZSh0aGlzLCAxKTtcclxuXHRcdH1cclxuXHR9O1xyXG59KSgpO1xyXG5cclxuLypcclxuXHRGdW5jdGlvbjogY29tcGFyZUFic1xyXG5cdENvbXBhcmUgdGhlIGFic29sdXRlIHZhbHVlIG9mIHR3byA8QmlnSW50ZWdlcnM+LlxyXG5cclxuXHRDYWxsaW5nIDxjb21wYXJlQWJzPiBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIDxhYnM+IHR3aWNlLCB0aGVuIDxjb21wYXJlPi5cclxuXHJcblx0UGFyYW1ldGVyczpcclxuXHJcblx0XHRuIC0gVGhlIG51bWJlciB0byBjb21wYXJlIHRvICp0aGlzKi4gV2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSA8QmlnSW50ZWdlcj4uXHJcblxyXG5cdFJldHVybnM6XHJcblxyXG5cdFx0LTEsIDAsIG9yICsxIGlmICp8dGhpc3wqIGlzIGxlc3MgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiAqfG58Ki5cclxuXHJcblx0U2VlIEFsc286XHJcblxyXG5cdFx0PGNvbXBhcmU+LCA8YWJzPlxyXG4qL1xyXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlQWJzID0gZnVuY3Rpb24obikge1xyXG5cdGlmICh0aGlzID09PSBuKSB7XHJcblx0XHRyZXR1cm4gMDtcclxuXHR9XHJcblxyXG5cdGlmICghKG4gaW5zdGFuY2VvZiBCaWdJbnRlZ2VyKSkge1xyXG5cdFx0aWYgKCFpc0Zpbml0ZShuKSkge1xyXG5cdFx0XHRyZXR1cm4oaXNOYU4obikgPyBuIDogLTEpO1xyXG5cdFx0fVxyXG5cdFx0biA9IEJpZ0ludGVnZXIobik7XHJcblx0fVxyXG5cclxuXHRpZiAodGhpcy5fcyA9PT0gMCkge1xyXG5cdFx0cmV0dXJuIChuLl9zICE9PSAwKSA/IC0xIDogMDtcclxuXHR9XHJcblx0aWYgKG4uX3MgPT09IDApIHtcclxuXHRcdHJldHVybiAxO1xyXG5cdH1cclxuXHJcblx0dmFyIGwgPSB0aGlzLl9kLmxlbmd0aDtcclxuXHR2YXIgbmwgPSBuLl9kLmxlbmd0aDtcclxuXHRpZiAobCA8IG5sKSB7XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fVxyXG5cdGVsc2UgaWYgKGwgPiBubCkge1xyXG5cdFx0cmV0dXJuIDE7XHJcblx0fVxyXG5cclxuXHR2YXIgYSA9IHRoaXMuX2Q7XHJcblx0dmFyIGIgPSBuLl9kO1xyXG5cdGZvciAodmFyIGkgPSBsLTE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRpZiAoYVtpXSAhPT0gYltpXSkge1xyXG5cdFx0XHRyZXR1cm4gYVtpXSA8IGJbaV0gPyAtMSA6IDE7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gMDtcclxufTtcclxuXHJcbi8qXHJcblx0RnVuY3Rpb246IGNvbXBhcmVcclxuXHRDb21wYXJlIHR3byA8QmlnSW50ZWdlcnM+LlxyXG5cclxuXHRQYXJhbWV0ZXJzOlxyXG5cclxuXHRcdG4gLSBUaGUgbnVtYmVyIHRvIGNvbXBhcmUgdG8gKnRoaXMqLiBXaWxsIGJlIGNvbnZlcnRlZCB0byBhIDxCaWdJbnRlZ2VyPi5cclxuXHJcblx0UmV0dXJuczpcclxuXHJcblx0XHQtMSwgMCwgb3IgKzEgaWYgKnRoaXMqIGlzIGxlc3MgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiAqbiouXHJcblxyXG5cdFNlZSBBbHNvOlxyXG5cclxuXHRcdDxjb21wYXJlQWJzPiwgPGlzUG9zaXRpdmU+LCA8aXNOZWdhdGl2ZT4sIDxpc1VuaXQ+XHJcbiovXHJcbkJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbihuKSB7XHJcblx0aWYgKHRoaXMgPT09IG4pIHtcclxuXHRcdHJldHVybiAwO1xyXG5cdH1cclxuXHJcblx0biA9IEJpZ0ludGVnZXIobik7XHJcblxyXG5cdGlmICh0aGlzLl9zID09PSAwKSB7XHJcblx0XHRyZXR1cm4gLW4uX3M7XHJcblx0fVxyXG5cclxuXHRpZiAodGhpcy5fcyA9PT0gbi5fcykgeyAvLyBib3RoIHBvc2l0aXZlIG9yIGJvdGggbmVnYXRpdmVcclxuXHRcdHZhciBjbXAgPSB0aGlzLmNvbXBhcmVBYnMobik7XHJcblx0XHRyZXR1cm4gY21wICogdGhpcy5fcztcclxuXHR9XHJcblx0ZWxzZSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcztcclxuXHR9XHJcbn07XHJcblxyXG4vKlxyXG5cdEZ1bmN0aW9uOiBpc1VuaXRcclxuXHRSZXR1cm4gdHJ1ZSBpZmYgKnRoaXMqIGlzIGVpdGhlciAxIG9yIC0xLlxyXG5cclxuXHRSZXR1cm5zOlxyXG5cclxuXHRcdHRydWUgaWYgKnRoaXMqIGNvbXBhcmVzIGVxdWFsIHRvIDxCaWdJbnRlZ2VyLk9ORT4gb3IgPEJpZ0ludGVnZXIuTV9PTkU+LlxyXG5cclxuXHRTZWUgQWxzbzpcclxuXHJcblx0XHQ8aXNaZXJvPiwgPGlzTmVnYXRpdmU+LCA8aXNQb3NpdGl2ZT4sIDxjb21wYXJlQWJzPiwgPGNvbXBhcmU+LFxyXG5cdFx0PEJpZ0ludGVnZXIuT05FPiwgPEJpZ0ludGVnZXIuTV9PTkU+XHJcbiovXHJcbkJpZ0ludGVnZXIucHJvdG90eXBlLmlzVW5pdCA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzID09PSBPTkUgfHxcclxuXHRcdHRoaXMgPT09IE1fT05FIHx8XHJcblx0XHQodGhpcy5fZC5sZW5ndGggPT09IDEgJiYgdGhpcy5fZFswXSA9PT0gMSk7XHJcbn07XHJcblxyXG4vKlxyXG5cdEZ1bmN0aW9uOiBtdWx0aXBseVxyXG5cdE11bHRpcGx5IHR3byA8QmlnSW50ZWdlcnM+LlxyXG5cclxuXHRQYXJhbWV0ZXJzOlxyXG5cclxuXHRcdG4gLSBUaGUgbnVtYmVyIHRvIG11bHRpcGx5ICp0aGlzKiBieS4gV2lsbCBiZSBjb252ZXJ0ZWQgdG8gYVxyXG5cdFx0PEJpZ0ludGVnZXI+LlxyXG5cclxuXHRSZXR1cm5zOlxyXG5cclxuXHRcdFRoZSBudW1iZXJzIG11bHRpcGxpZWQgdG9nZXRoZXIuXHJcblxyXG5cdFNlZSBBbHNvOlxyXG5cclxuXHRcdDxhZGQ+LCA8c3VidHJhY3Q+LCA8cXVvdGllbnQ+LCA8c3F1YXJlPlxyXG4qL1xyXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uKG4pIHtcclxuXHQvLyBUT0RPOiBDb25zaWRlciBhZGRpbmcgS2FyYXRzdWJhIG11bHRpcGxpY2F0aW9uIGZvciBsYXJnZSBudW1iZXJzXHJcblx0aWYgKHRoaXMuX3MgPT09IDApIHtcclxuXHRcdHJldHVybiBaRVJPO1xyXG5cdH1cclxuXHJcblx0biA9IEJpZ0ludGVnZXIobik7XHJcblx0aWYgKG4uX3MgPT09IDApIHtcclxuXHRcdHJldHVybiBaRVJPO1xyXG5cdH1cclxuXHRpZiAodGhpcy5pc1VuaXQoKSkge1xyXG5cdFx0aWYgKHRoaXMuX3MgPCAwKSB7XHJcblx0XHRcdHJldHVybiBuLm5lZ2F0ZSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG47XHJcblx0fVxyXG5cdGlmIChuLmlzVW5pdCgpKSB7XHJcblx0XHRpZiAobi5fcyA8IDApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMubmVnYXRlKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblx0aWYgKHRoaXMgPT09IG4pIHtcclxuXHRcdHJldHVybiB0aGlzLnNxdWFyZSgpO1xyXG5cdH1cclxuXHJcblx0dmFyIHIgPSAodGhpcy5fZC5sZW5ndGggPj0gbi5fZC5sZW5ndGgpO1xyXG5cdHZhciBhID0gKHIgPyB0aGlzIDogbikuX2Q7IC8vIGEgd2lsbCBiZSBsb25nZXIgdGhhbiBiXHJcblx0dmFyIGIgPSAociA/IG4gOiB0aGlzKS5fZDtcclxuXHR2YXIgYWwgPSBhLmxlbmd0aDtcclxuXHR2YXIgYmwgPSBiLmxlbmd0aDtcclxuXHJcblx0dmFyIHBsID0gYWwgKyBibDtcclxuXHR2YXIgcGFydGlhbCA9IG5ldyBBcnJheShwbCk7XHJcblx0dmFyIGk7XHJcblx0Zm9yIChpID0gMDsgaSA8IHBsOyBpKyspIHtcclxuXHRcdHBhcnRpYWxbaV0gPSAwO1xyXG5cdH1cclxuXHJcblx0Zm9yIChpID0gMDsgaSA8IGJsOyBpKyspIHtcclxuXHRcdHZhciBjYXJyeSA9IDA7XHJcblx0XHR2YXIgYmkgPSBiW2ldO1xyXG5cdFx0dmFyIGpsaW1pdCA9IGFsICsgaTtcclxuXHRcdHZhciBkaWdpdDtcclxuXHRcdGZvciAodmFyIGogPSBpOyBqIDwgamxpbWl0OyBqKyspIHtcclxuXHRcdFx0ZGlnaXQgPSBwYXJ0aWFsW2pdICsgYmkgKiBhW2ogLSBpXSArIGNhcnJ5O1xyXG5cdFx0XHRjYXJyeSA9IChkaWdpdCAvIEJpZ0ludGVnZXJfYmFzZSkgfCAwO1xyXG5cdFx0XHRwYXJ0aWFsW2pdID0gKGRpZ2l0ICUgQmlnSW50ZWdlcl9iYXNlKSB8IDA7XHJcblx0XHR9XHJcblx0XHRpZiAoY2FycnkpIHtcclxuXHRcdFx0ZGlnaXQgPSBwYXJ0aWFsW2pdICsgY2Fycnk7XHJcblx0XHRcdGNhcnJ5ID0gKGRpZ2l0IC8gQmlnSW50ZWdlcl9iYXNlKSB8IDA7XHJcblx0XHRcdHBhcnRpYWxbal0gPSBkaWdpdCAlIEJpZ0ludGVnZXJfYmFzZTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHBhcnRpYWwsIHRoaXMuX3MgKiBuLl9zLCBDT05TVFJVQ1QpO1xyXG59O1xyXG5cclxuLy8gTXVsdGlwbHkgYSBCaWdJbnRlZ2VyIGJ5IGEgc2luZ2xlLWRpZ2l0IG5hdGl2ZSBudW1iZXJcclxuLy8gQXNzdW1lcyB0aGF0IHRoaXMgYW5kIG4gYXJlID49IDBcclxuLy8gVGhpcyBpcyBub3QgcmVhbGx5IGludGVuZGVkIHRvIGJlIHVzZWQgb3V0c2lkZSB0aGUgbGlicmFyeSBpdHNlbGZcclxuQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHlTaW5nbGVEaWdpdCA9IGZ1bmN0aW9uKG4pIHtcclxuXHRpZiAobiA9PT0gMCB8fCB0aGlzLl9zID09PSAwKSB7XHJcblx0XHRyZXR1cm4gWkVSTztcclxuXHR9XHJcblx0aWYgKG4gPT09IDEpIHtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0dmFyIGRpZ2l0O1xyXG5cdGlmICh0aGlzLl9kLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0ZGlnaXQgPSB0aGlzLl9kWzBdICogbjtcclxuXHRcdGlmIChkaWdpdCA+PSBCaWdJbnRlZ2VyX2Jhc2UpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKFsoZGlnaXQgJSBCaWdJbnRlZ2VyX2Jhc2UpfDAsXHJcblx0XHRcdFx0XHQoZGlnaXQgLyBCaWdJbnRlZ2VyX2Jhc2UpfDBdLCAxLCBDT05TVFJVQ1QpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKFtkaWdpdF0sIDEsIENPTlNUUlVDVCk7XHJcblx0fVxyXG5cclxuXHRpZiAobiA9PT0gMikge1xyXG5cdFx0cmV0dXJuIHRoaXMuYWRkKHRoaXMpO1xyXG5cdH1cclxuXHRpZiAodGhpcy5pc1VuaXQoKSkge1xyXG5cdFx0cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKFtuXSwgMSwgQ09OU1RSVUNUKTtcclxuXHR9XHJcblxyXG5cdHZhciBhID0gdGhpcy5fZDtcclxuXHR2YXIgYWwgPSBhLmxlbmd0aDtcclxuXHJcblx0dmFyIHBsID0gYWwgKyAxO1xyXG5cdHZhciBwYXJ0aWFsID0gbmV3IEFycmF5KHBsKTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHBsOyBpKyspIHtcclxuXHRcdHBhcnRpYWxbaV0gPSAwO1xyXG5cdH1cclxuXHJcblx0dmFyIGNhcnJ5ID0gMDtcclxuXHRmb3IgKHZhciBqID0gMDsgaiA8IGFsOyBqKyspIHtcclxuXHRcdGRpZ2l0ID0gbiAqIGFbal0gKyBjYXJyeTtcclxuXHRcdGNhcnJ5ID0gKGRpZ2l0IC8gQmlnSW50ZWdlcl9iYXNlKSB8IDA7XHJcblx0XHRwYXJ0aWFsW2pdID0gKGRpZ2l0ICUgQmlnSW50ZWdlcl9iYXNlKSB8IDA7XHJcblx0fVxyXG5cdGlmIChjYXJyeSkge1xyXG5cdFx0cGFydGlhbFtqXSA9IGNhcnJ5O1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHBhcnRpYWwsIDEsIENPTlNUUlVDVCk7XHJcbn07XHJcblxyXG4vKlxyXG5cdEZ1bmN0aW9uOiBzcXVhcmVcclxuXHRNdWx0aXBseSBhIDxCaWdJbnRlZ2VyPiBieSBpdHNlbGYuXHJcblxyXG5cdFRoaXMgaXMgc2xpZ2h0bHkgZmFzdGVyIHRoYW4gcmVndWxhciBtdWx0aXBsaWNhdGlvbiwgc2luY2UgaXQgcmVtb3ZlcyB0aGVcclxuXHRkdXBsaWNhdGVkIG11bHRpcGxjYXRpb25zLlxyXG5cclxuXHRSZXR1cm5zOlxyXG5cclxuXHRcdD4gdGhpcy5tdWx0aXBseSh0aGlzKVxyXG5cclxuXHRTZWUgQWxzbzpcclxuXHRcdDxtdWx0aXBseT5cclxuKi9cclxuQmlnSW50ZWdlci5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24oKSB7XHJcblx0Ly8gTm9ybWFsbHksIHNxdWFyaW5nIGEgMTAtZGlnaXQgbnVtYmVyIHdvdWxkIHRha2UgMTAwIG11bHRpcGxpY2F0aW9ucy5cclxuXHQvLyBPZiB0aGVzZSAxMCBhcmUgdW5pcXVlIGRpYWdvbmFscywgb2YgdGhlIHJlbWFpbmluZyA5MCAoMTAwLTEwKSwgNDUgYXJlIHJlcGVhdGVkLlxyXG5cdC8vIFRoaXMgcHJvY2VkdXJlIHNhdmVzIChOKihOLTEpKS8yIG11bHRpcGxpY2F0aW9ucywgKGUuZy4sIDQ1IG9mIDEwMCBtdWx0aXBsaWVzKS5cclxuXHQvLyBCYXNlZCBvbiBjb2RlIGJ5IEdhcnkgRGFyYnksIEludGVsbGl0ZWNoIFN5c3RlbXMgSW5jLiwgd3d3LkRlbHBoaUZvckZ1bi5vcmdcclxuXHJcblx0aWYgKHRoaXMuX3MgPT09IDApIHtcclxuXHRcdHJldHVybiBaRVJPO1xyXG5cdH1cclxuXHRpZiAodGhpcy5pc1VuaXQoKSkge1xyXG5cdFx0cmV0dXJuIE9ORTtcclxuXHR9XHJcblxyXG5cdHZhciBkaWdpdHMgPSB0aGlzLl9kO1xyXG5cdHZhciBsZW5ndGggPSBkaWdpdHMubGVuZ3RoO1xyXG5cdHZhciBpbXVsdDEgPSBuZXcgQXJyYXkobGVuZ3RoICsgbGVuZ3RoICsgMSk7XHJcblx0dmFyIHByb2R1Y3QsIGNhcnJ5LCBrO1xyXG5cdHZhciBpO1xyXG5cclxuXHQvLyBDYWxjdWxhdGUgZGlhZ29uYWxcclxuXHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuXHRcdGsgPSBpICogMjtcclxuXHRcdHByb2R1Y3QgPSBkaWdpdHNbaV0gKiBkaWdpdHNbaV07XHJcblx0XHRjYXJyeSA9IChwcm9kdWN0IC8gQmlnSW50ZWdlcl9iYXNlKSB8IDA7XHJcblx0XHRpbXVsdDFba10gPSBwcm9kdWN0ICUgQmlnSW50ZWdlcl9iYXNlO1xyXG5cdFx0aW11bHQxW2sgKyAxXSA9IGNhcnJ5O1xyXG5cdH1cclxuXHJcblx0Ly8gQ2FsY3VsYXRlIHJlcGVhdGluZyBwYXJ0XHJcblx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcblx0XHRjYXJyeSA9IDA7XHJcblx0XHRrID0gaSAqIDIgKyAxO1xyXG5cdFx0Zm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbGVuZ3RoOyBqKyssIGsrKykge1xyXG5cdFx0XHRwcm9kdWN0ID0gZGlnaXRzW2pdICogZGlnaXRzW2ldICogMiArIGltdWx0MVtrXSArIGNhcnJ5O1xyXG5cdFx0XHRjYXJyeSA9IChwcm9kdWN0IC8gQmlnSW50ZWdlcl9iYXNlKSB8IDA7XHJcblx0XHRcdGltdWx0MVtrXSA9IHByb2R1Y3QgJSBCaWdJbnRlZ2VyX2Jhc2U7XHJcblx0XHR9XHJcblx0XHRrID0gbGVuZ3RoICsgaTtcclxuXHRcdHZhciBkaWdpdCA9IGNhcnJ5ICsgaW11bHQxW2tdO1xyXG5cdFx0Y2FycnkgPSAoZGlnaXQgLyBCaWdJbnRlZ2VyX2Jhc2UpIHwgMDtcclxuXHRcdGltdWx0MVtrXSA9IGRpZ2l0ICUgQmlnSW50ZWdlcl9iYXNlO1xyXG5cdFx0aW11bHQxW2sgKyAxXSArPSBjYXJyeTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBuZXcgQmlnSW50ZWdlcihpbXVsdDEsIDEsIENPTlNUUlVDVCk7XHJcbn07XHJcblxyXG4vKlxyXG5cdEZ1bmN0aW9uOiBxdW90aWVudFxyXG5cdERpdmlkZSB0d28gPEJpZ0ludGVnZXJzPiBhbmQgdHJ1bmNhdGUgdG93YXJkcyB6ZXJvLlxyXG5cclxuXHQ8cXVvdGllbnQ+IHRocm93cyBhbiBleGNlcHRpb24gaWYgKm4qIGlzIHplcm8uXHJcblxyXG5cdFBhcmFtZXRlcnM6XHJcblxyXG5cdFx0biAtIFRoZSBudW1iZXIgdG8gZGl2aWRlICp0aGlzKiBieS4gV2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSA8QmlnSW50ZWdlcj4uXHJcblxyXG5cdFJldHVybnM6XHJcblxyXG5cdFx0VGhlICp0aGlzKiAvICpuKiwgdHJ1bmNhdGVkIHRvIGFuIGludGVnZXIuXHJcblxyXG5cdFNlZSBBbHNvOlxyXG5cclxuXHRcdDxhZGQ+LCA8c3VidHJhY3Q+LCA8bXVsdGlwbHk+LCA8ZGl2UmVtPiwgPHJlbWFpbmRlcj5cclxuKi9cclxuQmlnSW50ZWdlci5wcm90b3R5cGUucXVvdGllbnQgPSBmdW5jdGlvbihuKSB7XHJcblx0cmV0dXJuIHRoaXMuZGl2UmVtKG4pWzBdO1xyXG59O1xyXG5cclxuLypcclxuXHRGdW5jdGlvbjogZGl2aWRlXHJcblx0RGVwcmVjYXRlZCBzeW5vbnltIGZvciA8cXVvdGllbnQ+LlxyXG4qL1xyXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGUgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5xdW90aWVudDtcclxuXHJcbi8qXHJcblx0RnVuY3Rpb246IHJlbWFpbmRlclxyXG5cdENhbGN1bGF0ZSB0aGUgcmVtYWluZGVyIG9mIHR3byA8QmlnSW50ZWdlcnM+LlxyXG5cclxuXHQ8cmVtYWluZGVyPiB0aHJvd3MgYW4gZXhjZXB0aW9uIGlmICpuKiBpcyB6ZXJvLlxyXG5cclxuXHRQYXJhbWV0ZXJzOlxyXG5cclxuXHRcdG4gLSBUaGUgcmVtYWluZGVyIGFmdGVyICp0aGlzKiBpcyBkaXZpZGVkICp0aGlzKiBieSAqbiouIFdpbGwgYmVcclxuXHRcdFx0Y29udmVydGVkIHRvIGEgPEJpZ0ludGVnZXI+LlxyXG5cclxuXHRSZXR1cm5zOlxyXG5cclxuXHRcdCp0aGlzKiAlICpuKi5cclxuXHJcblx0U2VlIEFsc286XHJcblxyXG5cdFx0PGRpdlJlbT4sIDxxdW90aWVudD5cclxuKi9cclxuQmlnSW50ZWdlci5wcm90b3R5cGUucmVtYWluZGVyID0gZnVuY3Rpb24obikge1xyXG5cdHJldHVybiB0aGlzLmRpdlJlbShuKVsxXTtcclxufTtcclxuXHJcbi8qXHJcblx0RnVuY3Rpb246IGRpdlJlbVxyXG5cdENhbGN1bGF0ZSB0aGUgaW50ZWdlciBxdW90aWVudCBhbmQgcmVtYWluZGVyIG9mIHR3byA8QmlnSW50ZWdlcnM+LlxyXG5cclxuXHQ8ZGl2UmVtPiB0aHJvd3MgYW4gZXhjZXB0aW9uIGlmICpuKiBpcyB6ZXJvLlxyXG5cclxuXHRQYXJhbWV0ZXJzOlxyXG5cclxuXHRcdG4gLSBUaGUgbnVtYmVyIHRvIGRpdmlkZSAqdGhpcyogYnkuIFdpbGwgYmUgY29udmVydGVkIHRvIGEgPEJpZ0ludGVnZXI+LlxyXG5cclxuXHRSZXR1cm5zOlxyXG5cclxuXHRcdEEgdHdvLWVsZW1lbnQgYXJyYXkgY29udGFpbmluZyB0aGUgcXVvdGllbnQgYW5kIHRoZSByZW1haW5kZXIuXHJcblxyXG5cdFx0PiBhLmRpdlJlbShiKVxyXG5cclxuXHRcdGlzIGV4YWN0bHkgZXF1aXZhbGVudCB0b1xyXG5cclxuXHRcdD4gW2EucXVvdGllbnQoYiksIGEucmVtYWluZGVyKGIpXVxyXG5cclxuXHRcdGV4Y2VwdCBpdCBpcyBmYXN0ZXIsIGJlY2F1c2UgdGhleSBhcmUgY2FsY3VsYXRlZCBhdCB0aGUgc2FtZSB0aW1lLlxyXG5cclxuXHRTZWUgQWxzbzpcclxuXHJcblx0XHQ8cXVvdGllbnQ+LCA8cmVtYWluZGVyPlxyXG4qL1xyXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZSZW0gPSBmdW5jdGlvbihuKSB7XHJcblx0biA9IEJpZ0ludGVnZXIobik7XHJcblx0aWYgKG4uX3MgPT09IDApIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkRpdmlkZSBieSB6ZXJvXCIpO1xyXG5cdH1cclxuXHRpZiAodGhpcy5fcyA9PT0gMCkge1xyXG5cdFx0cmV0dXJuIFtaRVJPLCBaRVJPXTtcclxuXHR9XHJcblx0aWYgKG4uX2QubGVuZ3RoID09PSAxKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5kaXZSZW1TbWFsbChuLl9zICogbi5fZFswXSk7XHJcblx0fVxyXG5cclxuXHQvLyBUZXN0IGZvciBlYXN5IGNhc2VzIC0tIHxuMXwgPD0gfG4yfFxyXG5cdHN3aXRjaCAodGhpcy5jb21wYXJlQWJzKG4pKSB7XHJcblx0Y2FzZSAwOiAvLyBuMSA9PSBuMlxyXG5cdFx0cmV0dXJuIFt0aGlzLl9zID09PSBuLl9zID8gT05FIDogTV9PTkUsIFpFUk9dO1xyXG5cdGNhc2UgLTE6IC8vIHxuMXwgPCB8bjJ8XHJcblx0XHRyZXR1cm4gW1pFUk8sIHRoaXNdO1xyXG5cdH1cclxuXHJcblx0dmFyIHNpZ24gPSB0aGlzLl9zICogbi5fcztcclxuXHR2YXIgYSA9IG4uYWJzKCk7XHJcblx0dmFyIGJfZGlnaXRzID0gdGhpcy5fZDtcclxuXHR2YXIgYl9pbmRleCA9IGJfZGlnaXRzLmxlbmd0aDtcclxuXHR2YXIgZGlnaXRzID0gbi5fZC5sZW5ndGg7XHJcblx0dmFyIHF1b3QgPSBbXTtcclxuXHR2YXIgZ3Vlc3M7XHJcblxyXG5cdHZhciBwYXJ0ID0gbmV3IEJpZ0ludGVnZXIoW10sIDAsIENPTlNUUlVDVCk7XHJcblxyXG5cdHdoaWxlIChiX2luZGV4KSB7XHJcblx0XHRwYXJ0Ll9kLnVuc2hpZnQoYl9kaWdpdHNbLS1iX2luZGV4XSk7XHJcblx0XHRwYXJ0ID0gbmV3IEJpZ0ludGVnZXIocGFydC5fZCwgMSwgQ09OU1RSVUNUKTtcclxuXHJcblx0XHRpZiAocGFydC5jb21wYXJlQWJzKG4pIDwgMCkge1xyXG5cdFx0XHRxdW90LnB1c2goMCk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHBhcnQuX3MgPT09IDApIHtcclxuXHRcdFx0Z3Vlc3MgPSAwO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHZhciB4bGVuID0gcGFydC5fZC5sZW5ndGgsIHlsZW4gPSBhLl9kLmxlbmd0aDtcclxuXHRcdFx0dmFyIGhpZ2h4ID0gcGFydC5fZFt4bGVuLTFdKkJpZ0ludGVnZXJfYmFzZSArIHBhcnQuX2RbeGxlbi0yXTtcclxuXHRcdFx0dmFyIGhpZ2h5ID0gYS5fZFt5bGVuLTFdKkJpZ0ludGVnZXJfYmFzZSArIGEuX2RbeWxlbi0yXTtcclxuXHRcdFx0aWYgKHBhcnQuX2QubGVuZ3RoID4gYS5fZC5sZW5ndGgpIHtcclxuXHRcdFx0XHQvLyBUaGUgbGVuZ3RoIG9mIHBhcnQuX2QgY2FuIGVpdGhlciBtYXRjaCBhLl9kIGxlbmd0aCxcclxuXHRcdFx0XHQvLyBvciBleGNlZWQgaXQgYnkgb25lLlxyXG5cdFx0XHRcdGhpZ2h4ID0gKGhpZ2h4KzEpKkJpZ0ludGVnZXJfYmFzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRndWVzcyA9IE1hdGguY2VpbChoaWdoeC9oaWdoeSk7XHJcblx0XHR9XHJcblx0XHRkbyB7XHJcblx0XHRcdHZhciBjaGVjayA9IGEubXVsdGlwbHlTaW5nbGVEaWdpdChndWVzcyk7XHJcblx0XHRcdGlmIChjaGVjay5jb21wYXJlQWJzKHBhcnQpIDw9IDApIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRndWVzcy0tO1xyXG5cdFx0fSB3aGlsZSAoZ3Vlc3MpO1xyXG5cclxuXHRcdHF1b3QucHVzaChndWVzcyk7XHJcblx0XHRpZiAoIWd1ZXNzKSB7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGRpZmYgPSBwYXJ0LnN1YnRyYWN0KGNoZWNrKTtcclxuXHRcdHBhcnQuX2QgPSBkaWZmLl9kLnNsaWNlKCk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gW25ldyBCaWdJbnRlZ2VyKHF1b3QucmV2ZXJzZSgpLCBzaWduLCBDT05TVFJVQ1QpLFxyXG5cdFx0ICAgbmV3IEJpZ0ludGVnZXIocGFydC5fZCwgdGhpcy5fcywgQ09OU1RSVUNUKV07XHJcbn07XHJcblxyXG4vLyBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIG4gaXMgb3V0c2lkZSBvZiAoLUJpZ0ludGVnZXIuYmFzZSwgLTFdIG9yXHJcbi8vIFsxLCBCaWdJbnRlZ2VyLmJhc2UpLiAgSXQncyBub3QgbmVjZXNzYXJ5IHRvIGNhbGwgdGhpcywgc2luY2UgdGhlXHJcbi8vIG90aGVyIGRpdmlzaW9uIGZ1bmN0aW9ucyB3aWxsIGNhbGwgaXQgaWYgdGhleSBhcmUgYWJsZSB0by5cclxuQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2UmVtU21hbGwgPSBmdW5jdGlvbihuKSB7XHJcblx0dmFyIHI7XHJcblx0biA9ICtuO1xyXG5cdGlmIChuID09PSAwKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJEaXZpZGUgYnkgemVyb1wiKTtcclxuXHR9XHJcblxyXG5cdHZhciBuX3MgPSBuIDwgMCA/IC0xIDogMTtcclxuXHR2YXIgc2lnbiA9IHRoaXMuX3MgKiBuX3M7XHJcblx0biA9IE1hdGguYWJzKG4pO1xyXG5cclxuXHRpZiAobiA8IDEgfHwgbiA+PSBCaWdJbnRlZ2VyX2Jhc2UpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50IG91dCBvZiByYW5nZVwiKTtcclxuXHR9XHJcblxyXG5cdGlmICh0aGlzLl9zID09PSAwKSB7XHJcblx0XHRyZXR1cm4gW1pFUk8sIFpFUk9dO1xyXG5cdH1cclxuXHJcblx0aWYgKG4gPT09IDEgfHwgbiA9PT0gLTEpIHtcclxuXHRcdHJldHVybiBbKHNpZ24gPT09IDEpID8gdGhpcy5hYnMoKSA6IG5ldyBCaWdJbnRlZ2VyKHRoaXMuX2QsIHNpZ24sIENPTlNUUlVDVCksIFpFUk9dO1xyXG5cdH1cclxuXHJcblx0Ly8gMiA8PSBuIDwgQmlnSW50ZWdlcl9iYXNlXHJcblxyXG5cdC8vIGRpdmlkZSBhIHNpbmdsZSBkaWdpdCBieSBhIHNpbmdsZSBkaWdpdFxyXG5cdGlmICh0aGlzLl9kLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0dmFyIHEgPSBuZXcgQmlnSW50ZWdlcihbKHRoaXMuX2RbMF0gLyBuKSB8IDBdLCAxLCBDT05TVFJVQ1QpO1xyXG5cdFx0ciA9IG5ldyBCaWdJbnRlZ2VyKFsodGhpcy5fZFswXSAlIG4pIHwgMF0sIDEsIENPTlNUUlVDVCk7XHJcblx0XHRpZiAoc2lnbiA8IDApIHtcclxuXHRcdFx0cSA9IHEubmVnYXRlKCk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5fcyA8IDApIHtcclxuXHRcdFx0ciA9IHIubmVnYXRlKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gW3EsIHJdO1xyXG5cdH1cclxuXHJcblx0dmFyIGRpZ2l0cyA9IHRoaXMuX2Quc2xpY2UoKTtcclxuXHR2YXIgcXVvdCA9IG5ldyBBcnJheShkaWdpdHMubGVuZ3RoKTtcclxuXHR2YXIgcGFydCA9IDA7XHJcblx0dmFyIGRpZmYgPSAwO1xyXG5cdHZhciBpID0gMDtcclxuXHR2YXIgZ3Vlc3M7XHJcblxyXG5cdHdoaWxlIChkaWdpdHMubGVuZ3RoKSB7XHJcblx0XHRwYXJ0ID0gcGFydCAqIEJpZ0ludGVnZXJfYmFzZSArIGRpZ2l0c1tkaWdpdHMubGVuZ3RoIC0gMV07XHJcblx0XHRpZiAocGFydCA8IG4pIHtcclxuXHRcdFx0cXVvdFtpKytdID0gMDtcclxuXHRcdFx0ZGlnaXRzLnBvcCgpO1xyXG5cdFx0XHRkaWZmID0gQmlnSW50ZWdlcl9iYXNlICogZGlmZiArIHBhcnQ7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHBhcnQgPT09IDApIHtcclxuXHRcdFx0Z3Vlc3MgPSAwO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGd1ZXNzID0gKHBhcnQgLyBuKSB8IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGNoZWNrID0gbiAqIGd1ZXNzO1xyXG5cdFx0ZGlmZiA9IHBhcnQgLSBjaGVjaztcclxuXHRcdHF1b3RbaSsrXSA9IGd1ZXNzO1xyXG5cdFx0aWYgKCFndWVzcykge1xyXG5cdFx0XHRkaWdpdHMucG9wKCk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRpZ2l0cy5wb3AoKTtcclxuXHRcdHBhcnQgPSBkaWZmO1xyXG5cdH1cclxuXHJcblx0ciA9IG5ldyBCaWdJbnRlZ2VyKFtkaWZmXSwgMSwgQ09OU1RSVUNUKTtcclxuXHRpZiAodGhpcy5fcyA8IDApIHtcclxuXHRcdHIgPSByLm5lZ2F0ZSgpO1xyXG5cdH1cclxuXHRyZXR1cm4gW25ldyBCaWdJbnRlZ2VyKHF1b3QucmV2ZXJzZSgpLCBzaWduLCBDT05TVFJVQ1QpLCByXTtcclxufTtcclxuXHJcbi8qXHJcblx0RnVuY3Rpb246IGlzRXZlblxyXG5cdFJldHVybiB0cnVlIGlmZiAqdGhpcyogaXMgZGl2aXNpYmxlIGJ5IHR3by5cclxuXHJcblx0Tm90ZSB0aGF0IDxCaWdJbnRlZ2VyLlpFUk8+IGlzIGV2ZW4uXHJcblxyXG5cdFJldHVybnM6XHJcblxyXG5cdFx0dHJ1ZSBpZiAqdGhpcyogaXMgZXZlbiwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG5cclxuXHRTZWUgQWxzbzpcclxuXHJcblx0XHQ8aXNPZGQ+XHJcbiovXHJcbkJpZ0ludGVnZXIucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBkaWdpdHMgPSB0aGlzLl9kO1xyXG5cdHJldHVybiB0aGlzLl9zID09PSAwIHx8IGRpZ2l0cy5sZW5ndGggPT09IDAgfHwgKGRpZ2l0c1swXSAlIDIpID09PSAwO1xyXG59O1xyXG5cclxuLypcclxuXHRGdW5jdGlvbjogaXNPZGRcclxuXHRSZXR1cm4gdHJ1ZSBpZmYgKnRoaXMqIGlzIG5vdCBkaXZpc2libGUgYnkgdHdvLlxyXG5cclxuXHRSZXR1cm5zOlxyXG5cclxuXHRcdHRydWUgaWYgKnRoaXMqIGlzIG9kZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG5cclxuXHRTZWUgQWxzbzpcclxuXHJcblx0XHQ8aXNFdmVuPlxyXG4qL1xyXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiAhdGhpcy5pc0V2ZW4oKTtcclxufTtcclxuXHJcbi8qXHJcblx0RnVuY3Rpb246IHNpZ25cclxuXHRHZXQgdGhlIHNpZ24gb2YgYSA8QmlnSW50ZWdlcj4uXHJcblxyXG5cdFJldHVybnM6XHJcblxyXG5cdFx0KiAtMSBpZiAqdGhpcyogPCAwXHJcblx0XHQqIDAgaWYgKnRoaXMqID09IDBcclxuXHRcdCogKzEgaWYgKnRoaXMqID4gMFxyXG5cclxuXHRTZWUgQWxzbzpcclxuXHJcblx0XHQ8aXNaZXJvPiwgPGlzUG9zaXRpdmU+LCA8aXNOZWdhdGl2ZT4sIDxjb21wYXJlPiwgPEJpZ0ludGVnZXIuWkVSTz5cclxuKi9cclxuQmlnSW50ZWdlci5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLl9zO1xyXG59O1xyXG5cclxuLypcclxuXHRGdW5jdGlvbjogaXNQb3NpdGl2ZVxyXG5cdFJldHVybiB0cnVlIGlmZiAqdGhpcyogPiAwLlxyXG5cclxuXHRSZXR1cm5zOlxyXG5cclxuXHRcdHRydWUgaWYgKnRoaXMqLmNvbXBhcmUoPEJpZ0ludGVnZXIuWkVSTz4pID09IDEuXHJcblxyXG5cdFNlZSBBbHNvOlxyXG5cclxuXHRcdDxzaWduPiwgPGlzWmVybz4sIDxpc05lZ2F0aXZlPiwgPGlzVW5pdD4sIDxjb21wYXJlPiwgPEJpZ0ludGVnZXIuWkVSTz5cclxuKi9cclxuQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLl9zID4gMDtcclxufTtcclxuXHJcbi8qXHJcblx0RnVuY3Rpb246IGlzTmVnYXRpdmVcclxuXHRSZXR1cm4gdHJ1ZSBpZmYgKnRoaXMqIDwgMC5cclxuXHJcblx0UmV0dXJuczpcclxuXHJcblx0XHR0cnVlIGlmICp0aGlzKi5jb21wYXJlKDxCaWdJbnRlZ2VyLlpFUk8+KSA9PSAtMS5cclxuXHJcblx0U2VlIEFsc286XHJcblxyXG5cdFx0PHNpZ24+LCA8aXNQb3NpdGl2ZT4sIDxpc1plcm8+LCA8aXNVbml0PiwgPGNvbXBhcmU+LCA8QmlnSW50ZWdlci5aRVJPPlxyXG4qL1xyXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuX3MgPCAwO1xyXG59O1xyXG5cclxuLypcclxuXHRGdW5jdGlvbjogaXNaZXJvXHJcblx0UmV0dXJuIHRydWUgaWZmICp0aGlzKiA9PSAwLlxyXG5cclxuXHRSZXR1cm5zOlxyXG5cclxuXHRcdHRydWUgaWYgKnRoaXMqLmNvbXBhcmUoPEJpZ0ludGVnZXIuWkVSTz4pID09IDAuXHJcblxyXG5cdFNlZSBBbHNvOlxyXG5cclxuXHRcdDxzaWduPiwgPGlzUG9zaXRpdmU+LCA8aXNOZWdhdGl2ZT4sIDxpc1VuaXQ+LCA8QmlnSW50ZWdlci5aRVJPPlxyXG4qL1xyXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5fcyA9PT0gMDtcclxufTtcclxuXHJcbi8qXHJcblx0RnVuY3Rpb246IGV4cDEwXHJcblx0TXVsdGlwbHkgYSA8QmlnSW50ZWdlcj4gYnkgYSBwb3dlciBvZiAxMC5cclxuXHJcblx0VGhpcyBpcyBlcXVpdmFsZW50IHRvLCBidXQgZmFzdGVyIHRoYW5cclxuXHJcblx0PiBpZiAobiA+PSAwKSB7XHJcblx0Plx0IHJldHVybiB0aGlzLm11bHRpcGx5KEJpZ0ludGVnZXIoXCIxZVwiICsgbikpO1xyXG5cdD4gfVxyXG5cdD4gZWxzZSB7IC8vIG4gPD0gMFxyXG5cdD5cdCByZXR1cm4gdGhpcy5xdW90aWVudChCaWdJbnRlZ2VyKFwiMWVcIiArIC1uKSk7XHJcblx0PiB9XHJcblxyXG5cdFBhcmFtZXRlcnM6XHJcblxyXG5cdFx0biAtIFRoZSBwb3dlciBvZiAxMCB0byBtdWx0aXBseSAqdGhpcyogYnkuICpuKiBpcyBjb252ZXJ0ZWQgdG8gYVxyXG5cdFx0amF2YXNjaXB0IG51bWJlciBhbmQgbXVzdCBiZSBubyBncmVhdGVyIHRoYW4gPEJpZ0ludGVnZXIuTUFYX0VYUD5cclxuXHRcdCgweDdGRkZGRkZGKSwgb3IgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxyXG5cclxuXHRSZXR1cm5zOlxyXG5cclxuXHRcdCp0aGlzKiAqICgxMCAqKiAqbiopLCB0cnVuY2F0ZWQgdG8gYW4gaW50ZWdlciBpZiBuZWNlc3NhcnkuXHJcblxyXG5cdFNlZSBBbHNvOlxyXG5cclxuXHRcdDxwb3c+LCA8bXVsdGlwbHk+XHJcbiovXHJcbkJpZ0ludGVnZXIucHJvdG90eXBlLmV4cDEwID0gZnVuY3Rpb24obikge1xyXG5cdG4gPSArbjtcclxuXHRpZiAobiA9PT0gMCkge1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cdGlmIChNYXRoLmFicyhuKSA+IE51bWJlcihNQVhfRVhQKSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiZXhwb25lbnQgdG9vIGxhcmdlIGluIEJpZ0ludGVnZXIuZXhwMTBcIik7XHJcblx0fVxyXG5cdC8vIE9wdGltaXphdGlvbiBmb3IgdGhpcyA9PSAwLiBUaGlzIGFsc28ga2VlcHMgdXMgZnJvbSBoYXZpbmcgdG8gdHJpbSB6ZXJvcyBpbiB0aGUgcG9zaXRpdmUgbiBjYXNlXHJcblx0aWYgKHRoaXMuX3MgPT09IDApIHtcclxuXHRcdHJldHVybiBaRVJPO1xyXG5cdH1cclxuXHRpZiAobiA+IDApIHtcclxuXHRcdHZhciBrID0gbmV3IEJpZ0ludGVnZXIodGhpcy5fZC5zbGljZSgpLCB0aGlzLl9zLCBDT05TVFJVQ1QpO1xyXG5cclxuXHRcdGZvciAoOyBuID49IEJpZ0ludGVnZXJfYmFzZV9sb2cxMDsgbiAtPSBCaWdJbnRlZ2VyX2Jhc2VfbG9nMTApIHtcclxuXHRcdFx0ay5fZC51bnNoaWZ0KDApO1xyXG5cdFx0fVxyXG5cdFx0aWYgKG4gPT0gMClcclxuXHRcdFx0cmV0dXJuIGs7XHJcblx0XHRrLl9zID0gMTtcclxuXHRcdGsgPSBrLm11bHRpcGx5U2luZ2xlRGlnaXQoTWF0aC5wb3coMTAsIG4pKTtcclxuXHRcdHJldHVybiAodGhpcy5fcyA8IDAgPyBrLm5lZ2F0ZSgpIDogayk7XHJcblx0fSBlbHNlIGlmICgtbiA+PSB0aGlzLl9kLmxlbmd0aCpCaWdJbnRlZ2VyX2Jhc2VfbG9nMTApIHtcclxuXHRcdHJldHVybiBaRVJPO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgayA9IG5ldyBCaWdJbnRlZ2VyKHRoaXMuX2Quc2xpY2UoKSwgdGhpcy5fcywgQ09OU1RSVUNUKTtcclxuXHJcblx0XHRmb3IgKG4gPSAtbjsgbiA+PSBCaWdJbnRlZ2VyX2Jhc2VfbG9nMTA7IG4gLT0gQmlnSW50ZWdlcl9iYXNlX2xvZzEwKSB7XHJcblx0XHRcdGsuX2Quc2hpZnQoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiAobiA9PSAwKSA/IGsgOiBrLmRpdlJlbVNtYWxsKE1hdGgucG93KDEwLCBuKSlbMF07XHJcblx0fVxyXG59O1xyXG5cclxuLypcclxuXHRGdW5jdGlvbjogcG93XHJcblx0UmFpc2UgYSA8QmlnSW50ZWdlcj4gdG8gYSBwb3dlci5cclxuXHJcblx0SW4gdGhpcyBpbXBsZW1lbnRhdGlvbiwgMCoqMCBpcyAxLlxyXG5cclxuXHRQYXJhbWV0ZXJzOlxyXG5cclxuXHRcdG4gLSBUaGUgZXhwb25lbnQgdG8gcmFpc2UgKnRoaXMqIGJ5LiAqbiogbXVzdCBiZSBubyBncmVhdGVyIHRoYW5cclxuXHRcdDxCaWdJbnRlZ2VyLk1BWF9FWFA+ICgweDdGRkZGRkZGKSwgb3IgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxyXG5cclxuXHRSZXR1cm5zOlxyXG5cclxuXHRcdCp0aGlzKiByYWlzZWQgdG8gdGhlICpudGgqIHBvd2VyLlxyXG5cclxuXHRTZWUgQWxzbzpcclxuXHJcblx0XHQ8bW9kUG93PlxyXG4qL1xyXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbihuKSB7XHJcblx0aWYgKHRoaXMuaXNVbml0KCkpIHtcclxuXHRcdGlmICh0aGlzLl9zID4gMCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gQmlnSW50ZWdlcihuKS5pc09kZCgpID8gdGhpcyA6IHRoaXMubmVnYXRlKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRuID0gQmlnSW50ZWdlcihuKTtcclxuXHRpZiAobi5fcyA9PT0gMCkge1xyXG5cdFx0cmV0dXJuIE9ORTtcclxuXHR9XHJcblx0ZWxzZSBpZiAobi5fcyA8IDApIHtcclxuXHRcdGlmICh0aGlzLl9zID09PSAwKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkRpdmlkZSBieSB6ZXJvXCIpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHJldHVybiBaRVJPO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAodGhpcy5fcyA9PT0gMCkge1xyXG5cdFx0cmV0dXJuIFpFUk87XHJcblx0fVxyXG5cdGlmIChuLmlzVW5pdCgpKSB7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdGlmIChuLmNvbXBhcmVBYnMoTUFYX0VYUCkgPiAwKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJleHBvbmVudCB0b28gbGFyZ2UgaW4gQmlnSW50ZWdlci5wb3dcIik7XHJcblx0fVxyXG5cdHZhciB4ID0gdGhpcztcclxuXHR2YXIgYXV4ID0gT05FO1xyXG5cdHZhciB0d28gPSBCaWdJbnRlZ2VyLnNtYWxsWzJdO1xyXG5cclxuXHR3aGlsZSAobi5pc1Bvc2l0aXZlKCkpIHtcclxuXHRcdGlmIChuLmlzT2RkKCkpIHtcclxuXHRcdFx0YXV4ID0gYXV4Lm11bHRpcGx5KHgpO1xyXG5cdFx0XHRpZiAobi5pc1VuaXQoKSkge1xyXG5cdFx0XHRcdHJldHVybiBhdXg7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHggPSB4LnNxdWFyZSgpO1xyXG5cdFx0biA9IG4ucXVvdGllbnQodHdvKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBhdXg7XHJcbn07XHJcblxyXG4vKlxyXG5cdEZ1bmN0aW9uOiBtb2RQb3dcclxuXHRSYWlzZSBhIDxCaWdJbnRlZ2VyPiB0byBhIHBvd2VyIChtb2QgbSkuXHJcblxyXG5cdEJlY2F1c2UgaXQgaXMgcmVkdWNlZCBieSBhIG1vZHVsdXMsIDxtb2RQb3c+IGlzIG5vdCBsaW1pdGVkIGJ5XHJcblx0PEJpZ0ludGVnZXIuTUFYX0VYUD4gbGlrZSA8cG93Pi5cclxuXHJcblx0UGFyYW1ldGVyczpcclxuXHJcblx0XHRleHBvbmVudCAtIFRoZSBleHBvbmVudCB0byByYWlzZSAqdGhpcyogYnkuIE11c3QgYmUgcG9zaXRpdmUuXHJcblx0XHRtb2R1bHVzIC0gVGhlIG1vZHVsdXMuXHJcblxyXG5cdFJldHVybnM6XHJcblxyXG5cdFx0KnRoaXMqIF4gKmV4cG9uZW50KiAobW9kICptb2R1bHVzKikuXHJcblxyXG5cdFNlZSBBbHNvOlxyXG5cclxuXHRcdDxwb3c+LCA8bW9kPlxyXG4qL1xyXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3cgPSBmdW5jdGlvbihleHBvbmVudCwgbW9kdWx1cykge1xyXG5cdHZhciByZXN1bHQgPSBPTkU7XHJcblx0dmFyIGJhc2UgPSB0aGlzO1xyXG5cclxuXHR3aGlsZSAoZXhwb25lbnQuaXNQb3NpdGl2ZSgpKSB7XHJcblx0XHRpZiAoZXhwb25lbnQuaXNPZGQoKSkge1xyXG5cdFx0XHRyZXN1bHQgPSByZXN1bHQubXVsdGlwbHkoYmFzZSkucmVtYWluZGVyKG1vZHVsdXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGV4cG9uZW50ID0gZXhwb25lbnQucXVvdGllbnQoQmlnSW50ZWdlci5zbWFsbFsyXSk7XHJcblx0XHRpZiAoZXhwb25lbnQuaXNQb3NpdGl2ZSgpKSB7XHJcblx0XHRcdGJhc2UgPSBiYXNlLnNxdWFyZSgpLnJlbWFpbmRlcihtb2R1bHVzKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKlxyXG5cdEZ1bmN0aW9uOiBsb2dcclxuXHRHZXQgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIG9mIGEgPEJpZ0ludGVnZXI+IGFzIGEgbmF0aXZlIEphdmFTY3JpcHQgbnVtYmVyLlxyXG5cclxuXHRUaGlzIGlzIGVxdWl2YWxlbnQgdG9cclxuXHJcblx0PiBNYXRoLmxvZyh0aGlzLnRvSlNWYWx1ZSgpKVxyXG5cclxuXHRidXQgaGFuZGxlcyB2YWx1ZXMgb3V0c2lkZSBvZiB0aGUgbmF0aXZlIG51bWJlciByYW5nZS5cclxuXHJcblx0UmV0dXJuczpcclxuXHJcblx0XHRsb2coICp0aGlzKiApXHJcblxyXG5cdFNlZSBBbHNvOlxyXG5cclxuXHRcdDx0b0pTVmFsdWU+XHJcbiovXHJcbkJpZ0ludGVnZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHN3aXRjaCAodGhpcy5fcykge1xyXG5cdGNhc2UgMDpcdCByZXR1cm4gLUluZmluaXR5O1xyXG5cdGNhc2UgLTE6IHJldHVybiBOYU47XHJcblx0ZGVmYXVsdDogLy8gRmFsbCB0aHJvdWdoLlxyXG5cdH1cclxuXHJcblx0dmFyIGwgPSB0aGlzLl9kLmxlbmd0aDtcclxuXHJcblx0aWYgKGwqQmlnSW50ZWdlcl9iYXNlX2xvZzEwIDwgMzApIHtcclxuXHRcdHJldHVybiBNYXRoLmxvZyh0aGlzLnZhbHVlT2YoKSk7XHJcblx0fVxyXG5cclxuXHR2YXIgTiA9IE1hdGguY2VpbCgzMC9CaWdJbnRlZ2VyX2Jhc2VfbG9nMTApO1xyXG5cdHZhciBmaXJzdE5kaWdpdHMgPSB0aGlzLl9kLnNsaWNlKGwgLSBOKTtcclxuXHRyZXR1cm4gTWF0aC5sb2coKG5ldyBCaWdJbnRlZ2VyKGZpcnN0TmRpZ2l0cywgMSwgQ09OU1RSVUNUKSkudmFsdWVPZigpKSArIChsIC0gTikgKiBNYXRoLmxvZyhCaWdJbnRlZ2VyX2Jhc2UpO1xyXG59O1xyXG5cclxuLypcclxuXHRGdW5jdGlvbjogdmFsdWVPZlxyXG5cdENvbnZlcnQgYSA8QmlnSW50ZWdlcj4gdG8gYSBuYXRpdmUgSmF2YVNjcmlwdCBpbnRlZ2VyLlxyXG5cclxuXHRUaGlzIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IEphdmFTY2lwdCB0byBjb252ZXJ0IGEgPEJpZ0ludGVnZXI+IHRvIGFcclxuXHRuYXRpdmUgdmFsdWUuXHJcblxyXG5cdFJldHVybnM6XHJcblxyXG5cdFx0PiBwYXJzZUludCh0aGlzLnRvU3RyaW5nKCksIDEwKVxyXG5cclxuXHRTZWUgQWxzbzpcclxuXHJcblx0XHQ8dG9TdHJpbmc+LCA8dG9KU1ZhbHVlPlxyXG4qL1xyXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHBhcnNlSW50KHRoaXMudG9TdHJpbmcoKSwgMTApO1xyXG59O1xyXG5cclxuLypcclxuXHRGdW5jdGlvbjogdG9KU1ZhbHVlXHJcblx0Q29udmVydCBhIDxCaWdJbnRlZ2VyPiB0byBhIG5hdGl2ZSBKYXZhU2NyaXB0IGludGVnZXIuXHJcblxyXG5cdFRoaXMgaXMgdGhlIHNhbWUgYXMgdmFsdWVPZiwgYnV0IG1vcmUgZXhwbGljaXRseSBuYW1lZC5cclxuXHJcblx0UmV0dXJuczpcclxuXHJcblx0XHQ+IHBhcnNlSW50KHRoaXMudG9TdHJpbmcoKSwgMTApXHJcblxyXG5cdFNlZSBBbHNvOlxyXG5cclxuXHRcdDx0b1N0cmluZz4sIDx2YWx1ZU9mPlxyXG4qL1xyXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50b0pTVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gcGFyc2VJbnQodGhpcy50b1N0cmluZygpLCAxMCk7XHJcbn07XHJcblxyXG4vKlxyXG5cdEZ1bmN0aW9uOiBsb3dWYWxcclxuXHRBdXRob3I6IEx1Y2FzIEpvbmVzXHJcbiovXHJcbkJpZ0ludGVnZXIucHJvdG90eXBlLmxvd1ZhbCA9IGZ1bmN0aW9uICgpIHtcclxuXHRyZXR1cm4gdGhpcy5fZFswXSB8fCAwO1xyXG59O1xyXG5cclxudmFyIE1BWF9FWFAgPSBCaWdJbnRlZ2VyKDB4N0ZGRkZGRkYpO1xyXG4vLyBDb25zdGFudDogTUFYX0VYUFxyXG4vLyBUaGUgbGFyZ2VzdCBleHBvbmVudCBhbGxvd2VkIGluIDxwb3c+IGFuZCA8ZXhwMTA+ICgweDdGRkZGRkZGIG9yIDIxNDc0ODM2NDcpLlxyXG5CaWdJbnRlZ2VyLk1BWF9FWFAgPSBNQVhfRVhQO1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cdGZ1bmN0aW9uIG1ha2VVbmFyeShmbikge1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGEpIHtcclxuXHRcdFx0cmV0dXJuIGZuLmNhbGwoQmlnSW50ZWdlcihhKSk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gbWFrZUJpbmFyeShmbikge1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdFx0cmV0dXJuIGZuLmNhbGwoQmlnSW50ZWdlcihhKSwgQmlnSW50ZWdlcihiKSk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gbWFrZVRyaW5hcnkoZm4pIHtcclxuXHRcdHJldHVybiBmdW5jdGlvbihhLCBiLCBjKSB7XHJcblx0XHRcdHJldHVybiBmbi5jYWxsKEJpZ0ludGVnZXIoYSksIEJpZ0ludGVnZXIoYiksIEJpZ0ludGVnZXIoYykpO1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdChmdW5jdGlvbigpIHtcclxuXHRcdHZhciBpLCBmbjtcclxuXHRcdHZhciB1bmFyeSA9IFwidG9KU1ZhbHVlLGlzRXZlbixpc09kZCxzaWduLGlzWmVybyxpc05lZ2F0aXZlLGFicyxpc1VuaXQsc3F1YXJlLG5lZ2F0ZSxpc1Bvc2l0aXZlLHRvU3RyaW5nLG5leHQscHJldixsb2dcIi5zcGxpdChcIixcIik7XHJcblx0XHR2YXIgYmluYXJ5ID0gXCJjb21wYXJlLHJlbWFpbmRlcixkaXZSZW0sc3VidHJhY3QsYWRkLHF1b3RpZW50LGRpdmlkZSxtdWx0aXBseSxwb3csY29tcGFyZUFic1wiLnNwbGl0KFwiLFwiKTtcclxuXHRcdHZhciB0cmluYXJ5ID0gW1wibW9kUG93XCJdO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCB1bmFyeS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRmbiA9IHVuYXJ5W2ldO1xyXG5cdFx0XHRCaWdJbnRlZ2VyW2ZuXSA9IG1ha2VVbmFyeShCaWdJbnRlZ2VyLnByb3RvdHlwZVtmbl0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBiaW5hcnkubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0Zm4gPSBiaW5hcnlbaV07XHJcblx0XHRcdEJpZ0ludGVnZXJbZm5dID0gbWFrZUJpbmFyeShCaWdJbnRlZ2VyLnByb3RvdHlwZVtmbl0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCB0cmluYXJ5Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGZuID0gdHJpbmFyeVtpXTtcclxuXHRcdFx0QmlnSW50ZWdlcltmbl0gPSBtYWtlVHJpbmFyeShCaWdJbnRlZ2VyLnByb3RvdHlwZVtmbl0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdEJpZ0ludGVnZXIuZXhwMTAgPSBmdW5jdGlvbih4LCBuKSB7XHJcblx0XHRcdHJldHVybiBCaWdJbnRlZ2VyKHgpLmV4cDEwKG4pO1xyXG5cdFx0fTtcclxuXHR9KSgpO1xyXG59KSgpO1xyXG5cclxuZXhwb3J0cy5CaWdJbnRlZ2VyID0gQmlnSW50ZWdlcjtcclxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/biginteger.js\n");

/***/ }),

/***/ "./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/moment.js":
/*!****************************************************************************************!*\
  !*** ./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/moment.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var require;//! moment.js\r\n\r\n;(function (global, factory) {\r\n     true ? module.exports = factory() :\r\n    undefined\r\n}(this, (function () { 'use strict';\r\n\r\n    var hookCallback;\r\n\r\n    function hooks () {\r\n        return hookCallback.apply(null, arguments);\r\n    }\r\n\r\n    // This is done to register the method called with moment()\r\n    // without creating circular dependencies.\r\n    function setHookCallback (callback) {\r\n        hookCallback = callback;\r\n    }\r\n\r\n    function isArray(input) {\r\n        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';\r\n    }\r\n\r\n    function isObject(input) {\r\n        // IE8 will treat undefined and null as object if it wasn't for\r\n        // input != null\r\n        return input != null && Object.prototype.toString.call(input) === '[object Object]';\r\n    }\r\n\r\n    function isObjectEmpty(obj) {\r\n        if (Object.getOwnPropertyNames) {\r\n            return (Object.getOwnPropertyNames(obj).length === 0);\r\n        } else {\r\n            var k;\r\n            for (k in obj) {\r\n                if (obj.hasOwnProperty(k)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function isUndefined(input) {\r\n        return input === void 0;\r\n    }\r\n\r\n    function isNumber(input) {\r\n        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';\r\n    }\r\n\r\n    function isDate(input) {\r\n        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';\r\n    }\r\n\r\n    function map(arr, fn) {\r\n        var res = [], i;\r\n        for (i = 0; i < arr.length; ++i) {\r\n            res.push(fn(arr[i], i));\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function hasOwnProp(a, b) {\r\n        return Object.prototype.hasOwnProperty.call(a, b);\r\n    }\r\n\r\n    function extend(a, b) {\r\n        for (var i in b) {\r\n            if (hasOwnProp(b, i)) {\r\n                a[i] = b[i];\r\n            }\r\n        }\r\n\r\n        if (hasOwnProp(b, 'toString')) {\r\n            a.toString = b.toString;\r\n        }\r\n\r\n        if (hasOwnProp(b, 'valueOf')) {\r\n            a.valueOf = b.valueOf;\r\n        }\r\n\r\n        return a;\r\n    }\r\n\r\n    function createUTC (input, format, locale, strict) {\r\n        return createLocalOrUTC(input, format, locale, strict, true).utc();\r\n    }\r\n\r\n    function defaultParsingFlags() {\r\n        // We need to deep clone this object.\r\n        return {\r\n            empty           : false,\r\n            unusedTokens    : [],\r\n            unusedInput     : [],\r\n            overflow        : -2,\r\n            charsLeftOver   : 0,\r\n            nullInput       : false,\r\n            invalidMonth    : null,\r\n            invalidFormat   : false,\r\n            userInvalidated : false,\r\n            iso             : false,\r\n            parsedDateParts : [],\r\n            meridiem        : null,\r\n            rfc2822         : false,\r\n            weekdayMismatch : false\r\n        };\r\n    }\r\n\r\n    function getParsingFlags(m) {\r\n        if (m._pf == null) {\r\n            m._pf = defaultParsingFlags();\r\n        }\r\n        return m._pf;\r\n    }\r\n\r\n    var some;\r\n    if (Array.prototype.some) {\r\n        some = Array.prototype.some;\r\n    } else {\r\n        some = function (fun) {\r\n            var t = Object(this);\r\n            var len = t.length >>> 0;\r\n\r\n            for (var i = 0; i < len; i++) {\r\n                if (i in t && fun.call(this, t[i], i, t)) {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        };\r\n    }\r\n\r\n    function isValid(m) {\r\n        if (m._isValid == null) {\r\n            var flags = getParsingFlags(m);\r\n            var parsedParts = some.call(flags.parsedDateParts, function (i) {\r\n                return i != null;\r\n            });\r\n            var isNowValid = !isNaN(m._d.getTime()) &&\r\n                flags.overflow < 0 &&\r\n                !flags.empty &&\r\n                !flags.invalidMonth &&\r\n                !flags.invalidWeekday &&\r\n                !flags.weekdayMismatch &&\r\n                !flags.nullInput &&\r\n                !flags.invalidFormat &&\r\n                !flags.userInvalidated &&\r\n                (!flags.meridiem || (flags.meridiem && parsedParts));\r\n\r\n            if (m._strict) {\r\n                isNowValid = isNowValid &&\r\n                    flags.charsLeftOver === 0 &&\r\n                    flags.unusedTokens.length === 0 &&\r\n                    flags.bigHour === undefined;\r\n            }\r\n\r\n            if (Object.isFrozen == null || !Object.isFrozen(m)) {\r\n                m._isValid = isNowValid;\r\n            }\r\n            else {\r\n                return isNowValid;\r\n            }\r\n        }\r\n        return m._isValid;\r\n    }\r\n\r\n    function createInvalid (flags) {\r\n        var m = createUTC(NaN);\r\n        if (flags != null) {\r\n            extend(getParsingFlags(m), flags);\r\n        }\r\n        else {\r\n            getParsingFlags(m).userInvalidated = true;\r\n        }\r\n\r\n        return m;\r\n    }\r\n\r\n    // Plugins that add properties should also add the key here (null value),\r\n    // so we can properly clone ourselves.\r\n    var momentProperties = hooks.momentProperties = [];\r\n\r\n    function copyConfig(to, from) {\r\n        var i, prop, val;\r\n\r\n        if (!isUndefined(from._isAMomentObject)) {\r\n            to._isAMomentObject = from._isAMomentObject;\r\n        }\r\n        if (!isUndefined(from._i)) {\r\n            to._i = from._i;\r\n        }\r\n        if (!isUndefined(from._f)) {\r\n            to._f = from._f;\r\n        }\r\n        if (!isUndefined(from._l)) {\r\n            to._l = from._l;\r\n        }\r\n        if (!isUndefined(from._strict)) {\r\n            to._strict = from._strict;\r\n        }\r\n        if (!isUndefined(from._tzm)) {\r\n            to._tzm = from._tzm;\r\n        }\r\n        if (!isUndefined(from._isUTC)) {\r\n            to._isUTC = from._isUTC;\r\n        }\r\n        if (!isUndefined(from._offset)) {\r\n            to._offset = from._offset;\r\n        }\r\n        if (!isUndefined(from._pf)) {\r\n            to._pf = getParsingFlags(from);\r\n        }\r\n        if (!isUndefined(from._locale)) {\r\n            to._locale = from._locale;\r\n        }\r\n\r\n        if (momentProperties.length > 0) {\r\n            for (i = 0; i < momentProperties.length; i++) {\r\n                prop = momentProperties[i];\r\n                val = from[prop];\r\n                if (!isUndefined(val)) {\r\n                    to[prop] = val;\r\n                }\r\n            }\r\n        }\r\n\r\n        return to;\r\n    }\r\n\r\n    var updateInProgress = false;\r\n\r\n    // Moment prototype object\r\n    function Moment(config) {\r\n        copyConfig(this, config);\r\n        this._d = new Date(config._d != null ? config._d.getTime() : NaN);\r\n        if (!this.isValid()) {\r\n            this._d = new Date(NaN);\r\n        }\r\n        // Prevent infinite loop in case updateOffset creates new moment\r\n        // objects.\r\n        if (updateInProgress === false) {\r\n            updateInProgress = true;\r\n            hooks.updateOffset(this);\r\n            updateInProgress = false;\r\n        }\r\n    }\r\n\r\n    function isMoment (obj) {\r\n        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);\r\n    }\r\n\r\n    function absFloor (number) {\r\n        if (number < 0) {\r\n            // -0 -> 0\r\n            return Math.ceil(number) || 0;\r\n        } else {\r\n            return Math.floor(number);\r\n        }\r\n    }\r\n\r\n    function toInt(argumentForCoercion) {\r\n        var coercedNumber = +argumentForCoercion,\r\n            value = 0;\r\n\r\n        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\r\n            value = absFloor(coercedNumber);\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    // compare two arrays, return the number of differences\r\n    function compareArrays(array1, array2, dontConvert) {\r\n        var len = Math.min(array1.length, array2.length),\r\n            lengthDiff = Math.abs(array1.length - array2.length),\r\n            diffs = 0,\r\n            i;\r\n        for (i = 0; i < len; i++) {\r\n            if ((dontConvert && array1[i] !== array2[i]) ||\r\n                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {\r\n                diffs++;\r\n            }\r\n        }\r\n        return diffs + lengthDiff;\r\n    }\r\n\r\n    function warn(msg) {\r\n        if (hooks.suppressDeprecationWarnings === false &&\r\n                (typeof console !==  'undefined') && console.warn) {\r\n            console.warn('Deprecation warning: ' + msg);\r\n        }\r\n    }\r\n\r\n    function deprecate(msg, fn) {\r\n        var firstTime = true;\r\n\r\n        return extend(function () {\r\n            if (hooks.deprecationHandler != null) {\r\n                hooks.deprecationHandler(null, msg);\r\n            }\r\n            if (firstTime) {\r\n                var args = [];\r\n                var arg;\r\n                for (var i = 0; i < arguments.length; i++) {\r\n                    arg = '';\r\n                    if (typeof arguments[i] === 'object') {\r\n                        arg += '\\n[' + i + '] ';\r\n                        for (var key in arguments[0]) {\r\n                            arg += key + ': ' + arguments[0][key] + ', ';\r\n                        }\r\n                        arg = arg.slice(0, -2); // Remove trailing comma and space\r\n                    } else {\r\n                        arg = arguments[i];\r\n                    }\r\n                    args.push(arg);\r\n                }\r\n                warn(msg + '\\nArguments: ' + Array.prototype.slice.call(args).join('') + '\\n' + (new Error()).stack);\r\n                firstTime = false;\r\n            }\r\n            return fn.apply(this, arguments);\r\n        }, fn);\r\n    }\r\n\r\n    var deprecations = {};\r\n\r\n    function deprecateSimple(name, msg) {\r\n        if (hooks.deprecationHandler != null) {\r\n            hooks.deprecationHandler(name, msg);\r\n        }\r\n        if (!deprecations[name]) {\r\n            warn(msg);\r\n            deprecations[name] = true;\r\n        }\r\n    }\r\n\r\n    hooks.suppressDeprecationWarnings = false;\r\n    hooks.deprecationHandler = null;\r\n\r\n    function isFunction(input) {\r\n        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';\r\n    }\r\n\r\n    function set (config) {\r\n        var prop, i;\r\n        for (i in config) {\r\n            prop = config[i];\r\n            if (isFunction(prop)) {\r\n                this[i] = prop;\r\n            } else {\r\n                this['_' + i] = prop;\r\n            }\r\n        }\r\n        this._config = config;\r\n        // Lenient ordinal parsing accepts just a number in addition to\r\n        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\r\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\r\n        this._dayOfMonthOrdinalParseLenient = new RegExp(\r\n            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +\r\n                '|' + (/\\d{1,2}/).source);\r\n    }\r\n\r\n    function mergeConfigs(parentConfig, childConfig) {\r\n        var res = extend({}, parentConfig), prop;\r\n        for (prop in childConfig) {\r\n            if (hasOwnProp(childConfig, prop)) {\r\n                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\r\n                    res[prop] = {};\r\n                    extend(res[prop], parentConfig[prop]);\r\n                    extend(res[prop], childConfig[prop]);\r\n                } else if (childConfig[prop] != null) {\r\n                    res[prop] = childConfig[prop];\r\n                } else {\r\n                    delete res[prop];\r\n                }\r\n            }\r\n        }\r\n        for (prop in parentConfig) {\r\n            if (hasOwnProp(parentConfig, prop) &&\r\n                    !hasOwnProp(childConfig, prop) &&\r\n                    isObject(parentConfig[prop])) {\r\n                // make sure changes to properties don't modify parent config\r\n                res[prop] = extend({}, res[prop]);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function Locale(config) {\r\n        if (config != null) {\r\n            this.set(config);\r\n        }\r\n    }\r\n\r\n    var keys;\r\n\r\n    if (Object.keys) {\r\n        keys = Object.keys;\r\n    } else {\r\n        keys = function (obj) {\r\n            var i, res = [];\r\n            for (i in obj) {\r\n                if (hasOwnProp(obj, i)) {\r\n                    res.push(i);\r\n                }\r\n            }\r\n            return res;\r\n        };\r\n    }\r\n\r\n    var defaultCalendar = {\r\n        sameDay : '[Today at] LT',\r\n        nextDay : '[Tomorrow at] LT',\r\n        nextWeek : 'dddd [at] LT',\r\n        lastDay : '[Yesterday at] LT',\r\n        lastWeek : '[Last] dddd [at] LT',\r\n        sameElse : 'L'\r\n    };\r\n\r\n    function calendar (key, mom, now) {\r\n        var output = this._calendar[key] || this._calendar['sameElse'];\r\n        return isFunction(output) ? output.call(mom, now) : output;\r\n    }\r\n\r\n    var defaultLongDateFormat = {\r\n        LTS  : 'h:mm:ss A',\r\n        LT   : 'h:mm A',\r\n        L    : 'MM/DD/YYYY',\r\n        LL   : 'MMMM D, YYYY',\r\n        LLL  : 'MMMM D, YYYY h:mm A',\r\n        LLLL : 'dddd, MMMM D, YYYY h:mm A'\r\n    };\r\n\r\n    function longDateFormat (key) {\r\n        var format = this._longDateFormat[key],\r\n            formatUpper = this._longDateFormat[key.toUpperCase()];\r\n\r\n        if (format || !formatUpper) {\r\n            return format;\r\n        }\r\n\r\n        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {\r\n            return val.slice(1);\r\n        });\r\n\r\n        return this._longDateFormat[key];\r\n    }\r\n\r\n    var defaultInvalidDate = 'Invalid date';\r\n\r\n    function invalidDate () {\r\n        return this._invalidDate;\r\n    }\r\n\r\n    var defaultOrdinal = '%d';\r\n    var defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\r\n\r\n    function ordinal (number) {\r\n        return this._ordinal.replace('%d', number);\r\n    }\r\n\r\n    var defaultRelativeTime = {\r\n        future : 'in %s',\r\n        past   : '%s ago',\r\n        s  : 'a few seconds',\r\n        ss : '%d seconds',\r\n        m  : 'a minute',\r\n        mm : '%d minutes',\r\n        h  : 'an hour',\r\n        hh : '%d hours',\r\n        d  : 'a day',\r\n        dd : '%d days',\r\n        M  : 'a month',\r\n        MM : '%d months',\r\n        y  : 'a year',\r\n        yy : '%d years'\r\n    };\r\n\r\n    function relativeTime (number, withoutSuffix, string, isFuture) {\r\n        var output = this._relativeTime[string];\r\n        return (isFunction(output)) ?\r\n            output(number, withoutSuffix, string, isFuture) :\r\n            output.replace(/%d/i, number);\r\n    }\r\n\r\n    function pastFuture (diff, output) {\r\n        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\r\n        return isFunction(format) ? format(output) : format.replace(/%s/i, output);\r\n    }\r\n\r\n    var aliases = {};\r\n\r\n    function addUnitAlias (unit, shorthand) {\r\n        var lowerCase = unit.toLowerCase();\r\n        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\r\n    }\r\n\r\n    function normalizeUnits(units) {\r\n        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;\r\n    }\r\n\r\n    function normalizeObjectUnits(inputObject) {\r\n        var normalizedInput = {},\r\n            normalizedProp,\r\n            prop;\r\n\r\n        for (prop in inputObject) {\r\n            if (hasOwnProp(inputObject, prop)) {\r\n                normalizedProp = normalizeUnits(prop);\r\n                if (normalizedProp) {\r\n                    normalizedInput[normalizedProp] = inputObject[prop];\r\n                }\r\n            }\r\n        }\r\n\r\n        return normalizedInput;\r\n    }\r\n\r\n    var priorities = {};\r\n\r\n    function addUnitPriority(unit, priority) {\r\n        priorities[unit] = priority;\r\n    }\r\n\r\n    function getPrioritizedUnits(unitsObj) {\r\n        var units = [];\r\n        for (var u in unitsObj) {\r\n            units.push({unit: u, priority: priorities[u]});\r\n        }\r\n        units.sort(function (a, b) {\r\n            return a.priority - b.priority;\r\n        });\r\n        return units;\r\n    }\r\n\r\n    function zeroFill(number, targetLength, forceSign) {\r\n        var absNumber = '' + Math.abs(number),\r\n            zerosToFill = targetLength - absNumber.length,\r\n            sign = number >= 0;\r\n        return (sign ? (forceSign ? '+' : '') : '-') +\r\n            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\r\n    }\r\n\r\n    var formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;\r\n\r\n    var localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g;\r\n\r\n    var formatFunctions = {};\r\n\r\n    var formatTokenFunctions = {};\r\n\r\n    // token:    'M'\r\n    // padded:   ['MM', 2]\r\n    // ordinal:  'Mo'\r\n    // callback: function () { this.month() + 1 }\r\n    function addFormatToken (token, padded, ordinal, callback) {\r\n        var func = callback;\r\n        if (typeof callback === 'string') {\r\n            func = function () {\r\n                return this[callback]();\r\n            };\r\n        }\r\n        if (token) {\r\n            formatTokenFunctions[token] = func;\r\n        }\r\n        if (padded) {\r\n            formatTokenFunctions[padded[0]] = function () {\r\n                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\r\n            };\r\n        }\r\n        if (ordinal) {\r\n            formatTokenFunctions[ordinal] = function () {\r\n                return this.localeData().ordinal(func.apply(this, arguments), token);\r\n            };\r\n        }\r\n    }\r\n\r\n    function removeFormattingTokens(input) {\r\n        if (input.match(/\\[[\\s\\S]/)) {\r\n            return input.replace(/^\\[|\\]$/g, '');\r\n        }\r\n        return input.replace(/\\\\/g, '');\r\n    }\r\n\r\n    function makeFormatFunction(format) {\r\n        var array = format.match(formattingTokens), i, length;\r\n\r\n        for (i = 0, length = array.length; i < length; i++) {\r\n            if (formatTokenFunctions[array[i]]) {\r\n                array[i] = formatTokenFunctions[array[i]];\r\n            } else {\r\n                array[i] = removeFormattingTokens(array[i]);\r\n            }\r\n        }\r\n\r\n        return function (mom) {\r\n            var output = '', i;\r\n            for (i = 0; i < length; i++) {\r\n                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];\r\n            }\r\n            return output;\r\n        };\r\n    }\r\n\r\n    // format date using native date object\r\n    function formatMoment(m, format) {\r\n        if (!m.isValid()) {\r\n            return m.localeData().invalidDate();\r\n        }\r\n\r\n        format = expandFormat(format, m.localeData());\r\n        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\r\n\r\n        return formatFunctions[format](m);\r\n    }\r\n\r\n    function expandFormat(format, locale) {\r\n        var i = 5;\r\n\r\n        function replaceLongDateFormatTokens(input) {\r\n            return locale.longDateFormat(input) || input;\r\n        }\r\n\r\n        localFormattingTokens.lastIndex = 0;\r\n        while (i >= 0 && localFormattingTokens.test(format)) {\r\n            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\r\n            localFormattingTokens.lastIndex = 0;\r\n            i -= 1;\r\n        }\r\n\r\n        return format;\r\n    }\r\n\r\n    var match1         = /\\d/;            //       0 - 9\r\n    var match2         = /\\d\\d/;          //      00 - 99\r\n    var match3         = /\\d{3}/;         //     000 - 999\r\n    var match4         = /\\d{4}/;         //    0000 - 9999\r\n    var match6         = /[+-]?\\d{6}/;    // -999999 - 999999\r\n    var match1to2      = /\\d\\d?/;         //       0 - 99\r\n    var match3to4      = /\\d\\d\\d\\d?/;     //     999 - 9999\r\n    var match5to6      = /\\d\\d\\d\\d\\d\\d?/; //   99999 - 999999\r\n    var match1to3      = /\\d{1,3}/;       //       0 - 999\r\n    var match1to4      = /\\d{1,4}/;       //       0 - 9999\r\n    var match1to6      = /[+-]?\\d{1,6}/;  // -999999 - 999999\r\n\r\n    var matchUnsigned  = /\\d+/;           //       0 - inf\r\n    var matchSigned    = /[+-]?\\d+/;      //    -inf - inf\r\n\r\n    var matchOffset    = /Z|[+-]\\d\\d:?\\d\\d/gi; // +00:00 -00:00 +0000 -0000 or Z\r\n    var matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z\r\n\r\n    var matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/; // 123456789 123456789.123\r\n\r\n    // any word (or two) characters or numbers including two/three word month in arabic.\r\n    // includes scottish gaelic two word and hyphenated months\r\n    var matchWord = /[0-9]{0,256}['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFF07\\uFF10-\\uFFEF]{1,256}|[\\u0600-\\u06FF\\/]{1,256}(\\s*?[\\u0600-\\u06FF]{1,256}){1,2}/i;\r\n\r\n    var regexes = {};\r\n\r\n    function addRegexToken (token, regex, strictRegex) {\r\n        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {\r\n            return (isStrict && strictRegex) ? strictRegex : regex;\r\n        };\r\n    }\r\n\r\n    function getParseRegexForToken (token, config) {\r\n        if (!hasOwnProp(regexes, token)) {\r\n            return new RegExp(unescapeFormat(token));\r\n        }\r\n\r\n        return regexes[token](config._strict, config._locale);\r\n    }\r\n\r\n    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\r\n    function unescapeFormat(s) {\r\n        return regexEscape(s.replace('\\\\', '').replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\r\n            return p1 || p2 || p3 || p4;\r\n        }));\r\n    }\r\n\r\n    function regexEscape(s) {\r\n        return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\r\n    }\r\n\r\n    var tokens = {};\r\n\r\n    function addParseToken (token, callback) {\r\n        var i, func = callback;\r\n        if (typeof token === 'string') {\r\n            token = [token];\r\n        }\r\n        if (isNumber(callback)) {\r\n            func = function (input, array) {\r\n                array[callback] = toInt(input);\r\n            };\r\n        }\r\n        for (i = 0; i < token.length; i++) {\r\n            tokens[token[i]] = func;\r\n        }\r\n    }\r\n\r\n    function addWeekParseToken (token, callback) {\r\n        addParseToken(token, function (input, array, config, token) {\r\n            config._w = config._w || {};\r\n            callback(input, config._w, config, token);\r\n        });\r\n    }\r\n\r\n    function addTimeToArrayFromToken(token, input, config) {\r\n        if (input != null && hasOwnProp(tokens, token)) {\r\n            tokens[token](input, config._a, config, token);\r\n        }\r\n    }\r\n\r\n    var YEAR = 0;\r\n    var MONTH = 1;\r\n    var DATE = 2;\r\n    var HOUR = 3;\r\n    var MINUTE = 4;\r\n    var SECOND = 5;\r\n    var MILLISECOND = 6;\r\n    var WEEK = 7;\r\n    var WEEKDAY = 8;\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('Y', 0, 0, function () {\r\n        var y = this.year();\r\n        return y <= 9999 ? '' + y : '+' + y;\r\n    });\r\n\r\n    addFormatToken(0, ['YY', 2], 0, function () {\r\n        return this.year() % 100;\r\n    });\r\n\r\n    addFormatToken(0, ['YYYY',   4],       0, 'year');\r\n    addFormatToken(0, ['YYYYY',  5],       0, 'year');\r\n    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('year', 'y');\r\n\r\n    // PRIORITIES\r\n\r\n    addUnitPriority('year', 1);\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('Y',      matchSigned);\r\n    addRegexToken('YY',     match1to2, match2);\r\n    addRegexToken('YYYY',   match1to4, match4);\r\n    addRegexToken('YYYYY',  match1to6, match6);\r\n    addRegexToken('YYYYYY', match1to6, match6);\r\n\r\n    addParseToken(['YYYYY', 'YYYYYY'], YEAR);\r\n    addParseToken('YYYY', function (input, array) {\r\n        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\r\n    });\r\n    addParseToken('YY', function (input, array) {\r\n        array[YEAR] = hooks.parseTwoDigitYear(input);\r\n    });\r\n    addParseToken('Y', function (input, array) {\r\n        array[YEAR] = parseInt(input, 10);\r\n    });\r\n\r\n    // HELPERS\r\n\r\n    function daysInYear(year) {\r\n        return isLeapYear(year) ? 366 : 365;\r\n    }\r\n\r\n    function isLeapYear(year) {\r\n        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\r\n    }\r\n\r\n    // HOOKS\r\n\r\n    hooks.parseTwoDigitYear = function (input) {\r\n        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\r\n    };\r\n\r\n    // MOMENTS\r\n\r\n    var getSetYear = makeGetSet('FullYear', true);\r\n\r\n    function getIsLeapYear () {\r\n        return isLeapYear(this.year());\r\n    }\r\n\r\n    function makeGetSet (unit, keepTime) {\r\n        return function (value) {\r\n            if (value != null) {\r\n                set$1(this, unit, value);\r\n                hooks.updateOffset(this, keepTime);\r\n                return this;\r\n            } else {\r\n                return get(this, unit);\r\n            }\r\n        };\r\n    }\r\n\r\n    function get (mom, unit) {\r\n        return mom.isValid() ?\r\n            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;\r\n    }\r\n\r\n    function set$1 (mom, unit, value) {\r\n        if (mom.isValid() && !isNaN(value)) {\r\n            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {\r\n                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));\r\n            }\r\n            else {\r\n                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\r\n            }\r\n        }\r\n    }\r\n\r\n    // MOMENTS\r\n\r\n    function stringGet (units) {\r\n        units = normalizeUnits(units);\r\n        if (isFunction(this[units])) {\r\n            return this[units]();\r\n        }\r\n        return this;\r\n    }\r\n\r\n\r\n    function stringSet (units, value) {\r\n        if (typeof units === 'object') {\r\n            units = normalizeObjectUnits(units);\r\n            var prioritized = getPrioritizedUnits(units);\r\n            for (var i = 0; i < prioritized.length; i++) {\r\n                this[prioritized[i].unit](units[prioritized[i].unit]);\r\n            }\r\n        } else {\r\n            units = normalizeUnits(units);\r\n            if (isFunction(this[units])) {\r\n                return this[units](value);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    function mod(n, x) {\r\n        return ((n % x) + x) % x;\r\n    }\r\n\r\n    var indexOf;\r\n\r\n    if (Array.prototype.indexOf) {\r\n        indexOf = Array.prototype.indexOf;\r\n    } else {\r\n        indexOf = function (o) {\r\n            // I know\r\n            var i;\r\n            for (i = 0; i < this.length; ++i) {\r\n                if (this[i] === o) {\r\n                    return i;\r\n                }\r\n            }\r\n            return -1;\r\n        };\r\n    }\r\n\r\n    function daysInMonth(year, month) {\r\n        if (isNaN(year) || isNaN(month)) {\r\n            return NaN;\r\n        }\r\n        var modMonth = mod(month, 12);\r\n        year += (month - modMonth) / 12;\r\n        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);\r\n    }\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('M', ['MM', 2], 'Mo', function () {\r\n        return this.month() + 1;\r\n    });\r\n\r\n    addFormatToken('MMM', 0, 0, function (format) {\r\n        return this.localeData().monthsShort(this, format);\r\n    });\r\n\r\n    addFormatToken('MMMM', 0, 0, function (format) {\r\n        return this.localeData().months(this, format);\r\n    });\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('month', 'M');\r\n\r\n    // PRIORITY\r\n\r\n    addUnitPriority('month', 8);\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('M',    match1to2);\r\n    addRegexToken('MM',   match1to2, match2);\r\n    addRegexToken('MMM',  function (isStrict, locale) {\r\n        return locale.monthsShortRegex(isStrict);\r\n    });\r\n    addRegexToken('MMMM', function (isStrict, locale) {\r\n        return locale.monthsRegex(isStrict);\r\n    });\r\n\r\n    addParseToken(['M', 'MM'], function (input, array) {\r\n        array[MONTH] = toInt(input) - 1;\r\n    });\r\n\r\n    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\r\n        var month = config._locale.monthsParse(input, token, config._strict);\r\n        // if we didn't find a month name, mark the date as invalid.\r\n        if (month != null) {\r\n            array[MONTH] = month;\r\n        } else {\r\n            getParsingFlags(config).invalidMonth = input;\r\n        }\r\n    });\r\n\r\n    // LOCALES\r\n\r\n    var MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/;\r\n    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');\r\n    function localeMonths (m, format) {\r\n        if (!m) {\r\n            return isArray(this._months) ? this._months :\r\n                this._months['standalone'];\r\n        }\r\n        return isArray(this._months) ? this._months[m.month()] :\r\n            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];\r\n    }\r\n\r\n    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');\r\n    function localeMonthsShort (m, format) {\r\n        if (!m) {\r\n            return isArray(this._monthsShort) ? this._monthsShort :\r\n                this._monthsShort['standalone'];\r\n        }\r\n        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :\r\n            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];\r\n    }\r\n\r\n    function handleStrictParse(monthName, format, strict) {\r\n        var i, ii, mom, llc = monthName.toLocaleLowerCase();\r\n        if (!this._monthsParse) {\r\n            // this is not used\r\n            this._monthsParse = [];\r\n            this._longMonthsParse = [];\r\n            this._shortMonthsParse = [];\r\n            for (i = 0; i < 12; ++i) {\r\n                mom = createUTC([2000, i]);\r\n                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();\r\n                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\r\n            }\r\n        }\r\n\r\n        if (strict) {\r\n            if (format === 'MMM') {\r\n                ii = indexOf.call(this._shortMonthsParse, llc);\r\n                return ii !== -1 ? ii : null;\r\n            } else {\r\n                ii = indexOf.call(this._longMonthsParse, llc);\r\n                return ii !== -1 ? ii : null;\r\n            }\r\n        } else {\r\n            if (format === 'MMM') {\r\n                ii = indexOf.call(this._shortMonthsParse, llc);\r\n                if (ii !== -1) {\r\n                    return ii;\r\n                }\r\n                ii = indexOf.call(this._longMonthsParse, llc);\r\n                return ii !== -1 ? ii : null;\r\n            } else {\r\n                ii = indexOf.call(this._longMonthsParse, llc);\r\n                if (ii !== -1) {\r\n                    return ii;\r\n                }\r\n                ii = indexOf.call(this._shortMonthsParse, llc);\r\n                return ii !== -1 ? ii : null;\r\n            }\r\n        }\r\n    }\r\n\r\n    function localeMonthsParse (monthName, format, strict) {\r\n        var i, mom, regex;\r\n\r\n        if (this._monthsParseExact) {\r\n            return handleStrictParse.call(this, monthName, format, strict);\r\n        }\r\n\r\n        if (!this._monthsParse) {\r\n            this._monthsParse = [];\r\n            this._longMonthsParse = [];\r\n            this._shortMonthsParse = [];\r\n        }\r\n\r\n        // TODO: add sorting\r\n        // Sorting makes sure if one month (or abbr) is a prefix of another\r\n        // see sorting in computeMonthsParse\r\n        for (i = 0; i < 12; i++) {\r\n            // make the regex if we don't have it already\r\n            mom = createUTC([2000, i]);\r\n            if (strict && !this._longMonthsParse[i]) {\r\n                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\r\n                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\r\n            }\r\n            if (!strict && !this._monthsParse[i]) {\r\n                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\r\n                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\r\n            }\r\n            // test the regex\r\n            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\r\n                return i;\r\n            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\r\n                return i;\r\n            } else if (!strict && this._monthsParse[i].test(monthName)) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n\r\n    // MOMENTS\r\n\r\n    function setMonth (mom, value) {\r\n        var dayOfMonth;\r\n\r\n        if (!mom.isValid()) {\r\n            // No op\r\n            return mom;\r\n        }\r\n\r\n        if (typeof value === 'string') {\r\n            if (/^\\d+$/.test(value)) {\r\n                value = toInt(value);\r\n            } else {\r\n                value = mom.localeData().monthsParse(value);\r\n                // TODO: Another silent failure?\r\n                if (!isNumber(value)) {\r\n                    return mom;\r\n                }\r\n            }\r\n        }\r\n\r\n        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\r\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\r\n        return mom;\r\n    }\r\n\r\n    function getSetMonth (value) {\r\n        if (value != null) {\r\n            setMonth(this, value);\r\n            hooks.updateOffset(this, true);\r\n            return this;\r\n        } else {\r\n            return get(this, 'Month');\r\n        }\r\n    }\r\n\r\n    function getDaysInMonth () {\r\n        return daysInMonth(this.year(), this.month());\r\n    }\r\n\r\n    var defaultMonthsShortRegex = matchWord;\r\n    function monthsShortRegex (isStrict) {\r\n        if (this._monthsParseExact) {\r\n            if (!hasOwnProp(this, '_monthsRegex')) {\r\n                computeMonthsParse.call(this);\r\n            }\r\n            if (isStrict) {\r\n                return this._monthsShortStrictRegex;\r\n            } else {\r\n                return this._monthsShortRegex;\r\n            }\r\n        } else {\r\n            if (!hasOwnProp(this, '_monthsShortRegex')) {\r\n                this._monthsShortRegex = defaultMonthsShortRegex;\r\n            }\r\n            return this._monthsShortStrictRegex && isStrict ?\r\n                this._monthsShortStrictRegex : this._monthsShortRegex;\r\n        }\r\n    }\r\n\r\n    var defaultMonthsRegex = matchWord;\r\n    function monthsRegex (isStrict) {\r\n        if (this._monthsParseExact) {\r\n            if (!hasOwnProp(this, '_monthsRegex')) {\r\n                computeMonthsParse.call(this);\r\n            }\r\n            if (isStrict) {\r\n                return this._monthsStrictRegex;\r\n            } else {\r\n                return this._monthsRegex;\r\n            }\r\n        } else {\r\n            if (!hasOwnProp(this, '_monthsRegex')) {\r\n                this._monthsRegex = defaultMonthsRegex;\r\n            }\r\n            return this._monthsStrictRegex && isStrict ?\r\n                this._monthsStrictRegex : this._monthsRegex;\r\n        }\r\n    }\r\n\r\n    function computeMonthsParse () {\r\n        function cmpLenRev(a, b) {\r\n            return b.length - a.length;\r\n        }\r\n\r\n        var shortPieces = [], longPieces = [], mixedPieces = [],\r\n            i, mom;\r\n        for (i = 0; i < 12; i++) {\r\n            // make the regex if we don't have it already\r\n            mom = createUTC([2000, i]);\r\n            shortPieces.push(this.monthsShort(mom, ''));\r\n            longPieces.push(this.months(mom, ''));\r\n            mixedPieces.push(this.months(mom, ''));\r\n            mixedPieces.push(this.monthsShort(mom, ''));\r\n        }\r\n        // Sorting makes sure if one month (or abbr) is a prefix of another it\r\n        // will match the longer piece.\r\n        shortPieces.sort(cmpLenRev);\r\n        longPieces.sort(cmpLenRev);\r\n        mixedPieces.sort(cmpLenRev);\r\n        for (i = 0; i < 12; i++) {\r\n            shortPieces[i] = regexEscape(shortPieces[i]);\r\n            longPieces[i] = regexEscape(longPieces[i]);\r\n        }\r\n        for (i = 0; i < 24; i++) {\r\n            mixedPieces[i] = regexEscape(mixedPieces[i]);\r\n        }\r\n\r\n        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\r\n        this._monthsShortRegex = this._monthsRegex;\r\n        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\r\n        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\r\n    }\r\n\r\n    function createDate (y, m, d, h, M, s, ms) {\r\n        // can't just apply() to create a date:\r\n        // https://stackoverflow.com/q/181348\r\n        var date = new Date(y, m, d, h, M, s, ms);\r\n\r\n        // the date constructor remaps years 0-99 to 1900-1999\r\n        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {\r\n            date.setFullYear(y);\r\n        }\r\n        return date;\r\n    }\r\n\r\n    function createUTCDate (y) {\r\n        var date = new Date(Date.UTC.apply(null, arguments));\r\n\r\n        // the Date.UTC function remaps years 0-99 to 1900-1999\r\n        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {\r\n            date.setUTCFullYear(y);\r\n        }\r\n        return date;\r\n    }\r\n\r\n    // start-of-first-week - start-of-year\r\n    function firstWeekOffset(year, dow, doy) {\r\n        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\r\n            fwd = 7 + dow - doy,\r\n            // first-week day local weekday -- which local weekday is fwd\r\n            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\r\n\r\n        return -fwdlw + fwd - 1;\r\n    }\r\n\r\n    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\r\n    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {\r\n        var localWeekday = (7 + weekday - dow) % 7,\r\n            weekOffset = firstWeekOffset(year, dow, doy),\r\n            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\r\n            resYear, resDayOfYear;\r\n\r\n        if (dayOfYear <= 0) {\r\n            resYear = year - 1;\r\n            resDayOfYear = daysInYear(resYear) + dayOfYear;\r\n        } else if (dayOfYear > daysInYear(year)) {\r\n            resYear = year + 1;\r\n            resDayOfYear = dayOfYear - daysInYear(year);\r\n        } else {\r\n            resYear = year;\r\n            resDayOfYear = dayOfYear;\r\n        }\r\n\r\n        return {\r\n            year: resYear,\r\n            dayOfYear: resDayOfYear\r\n        };\r\n    }\r\n\r\n    function weekOfYear(mom, dow, doy) {\r\n        var weekOffset = firstWeekOffset(mom.year(), dow, doy),\r\n            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\r\n            resWeek, resYear;\r\n\r\n        if (week < 1) {\r\n            resYear = mom.year() - 1;\r\n            resWeek = week + weeksInYear(resYear, dow, doy);\r\n        } else if (week > weeksInYear(mom.year(), dow, doy)) {\r\n            resWeek = week - weeksInYear(mom.year(), dow, doy);\r\n            resYear = mom.year() + 1;\r\n        } else {\r\n            resYear = mom.year();\r\n            resWeek = week;\r\n        }\r\n\r\n        return {\r\n            week: resWeek,\r\n            year: resYear\r\n        };\r\n    }\r\n\r\n    function weeksInYear(year, dow, doy) {\r\n        var weekOffset = firstWeekOffset(year, dow, doy),\r\n            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\r\n        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\r\n    }\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('w', ['ww', 2], 'wo', 'week');\r\n    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('week', 'w');\r\n    addUnitAlias('isoWeek', 'W');\r\n\r\n    // PRIORITIES\r\n\r\n    addUnitPriority('week', 5);\r\n    addUnitPriority('isoWeek', 5);\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('w',  match1to2);\r\n    addRegexToken('ww', match1to2, match2);\r\n    addRegexToken('W',  match1to2);\r\n    addRegexToken('WW', match1to2, match2);\r\n\r\n    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {\r\n        week[token.substr(0, 1)] = toInt(input);\r\n    });\r\n\r\n    // HELPERS\r\n\r\n    // LOCALES\r\n\r\n    function localeWeek (mom) {\r\n        return weekOfYear(mom, this._week.dow, this._week.doy).week;\r\n    }\r\n\r\n    var defaultLocaleWeek = {\r\n        dow : 0, // Sunday is the first day of the week.\r\n        doy : 6  // The week that contains Jan 1st is the first week of the year.\r\n    };\r\n\r\n    function localeFirstDayOfWeek () {\r\n        return this._week.dow;\r\n    }\r\n\r\n    function localeFirstDayOfYear () {\r\n        return this._week.doy;\r\n    }\r\n\r\n    // MOMENTS\r\n\r\n    function getSetWeek (input) {\r\n        var week = this.localeData().week(this);\r\n        return input == null ? week : this.add((input - week) * 7, 'd');\r\n    }\r\n\r\n    function getSetISOWeek (input) {\r\n        var week = weekOfYear(this, 1, 4).week;\r\n        return input == null ? week : this.add((input - week) * 7, 'd');\r\n    }\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('d', 0, 'do', 'day');\r\n\r\n    addFormatToken('dd', 0, 0, function (format) {\r\n        return this.localeData().weekdaysMin(this, format);\r\n    });\r\n\r\n    addFormatToken('ddd', 0, 0, function (format) {\r\n        return this.localeData().weekdaysShort(this, format);\r\n    });\r\n\r\n    addFormatToken('dddd', 0, 0, function (format) {\r\n        return this.localeData().weekdays(this, format);\r\n    });\r\n\r\n    addFormatToken('e', 0, 0, 'weekday');\r\n    addFormatToken('E', 0, 0, 'isoWeekday');\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('day', 'd');\r\n    addUnitAlias('weekday', 'e');\r\n    addUnitAlias('isoWeekday', 'E');\r\n\r\n    // PRIORITY\r\n    addUnitPriority('day', 11);\r\n    addUnitPriority('weekday', 11);\r\n    addUnitPriority('isoWeekday', 11);\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('d',    match1to2);\r\n    addRegexToken('e',    match1to2);\r\n    addRegexToken('E',    match1to2);\r\n    addRegexToken('dd',   function (isStrict, locale) {\r\n        return locale.weekdaysMinRegex(isStrict);\r\n    });\r\n    addRegexToken('ddd',   function (isStrict, locale) {\r\n        return locale.weekdaysShortRegex(isStrict);\r\n    });\r\n    addRegexToken('dddd',   function (isStrict, locale) {\r\n        return locale.weekdaysRegex(isStrict);\r\n    });\r\n\r\n    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\r\n        var weekday = config._locale.weekdaysParse(input, token, config._strict);\r\n        // if we didn't get a weekday name, mark the date as invalid\r\n        if (weekday != null) {\r\n            week.d = weekday;\r\n        } else {\r\n            getParsingFlags(config).invalidWeekday = input;\r\n        }\r\n    });\r\n\r\n    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\r\n        week[token] = toInt(input);\r\n    });\r\n\r\n    // HELPERS\r\n\r\n    function parseWeekday(input, locale) {\r\n        if (typeof input !== 'string') {\r\n            return input;\r\n        }\r\n\r\n        if (!isNaN(input)) {\r\n            return parseInt(input, 10);\r\n        }\r\n\r\n        input = locale.weekdaysParse(input);\r\n        if (typeof input === 'number') {\r\n            return input;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    function parseIsoWeekday(input, locale) {\r\n        if (typeof input === 'string') {\r\n            return locale.weekdaysParse(input) % 7 || 7;\r\n        }\r\n        return isNaN(input) ? null : input;\r\n    }\r\n\r\n    // LOCALES\r\n\r\n    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');\r\n    function localeWeekdays (m, format) {\r\n        if (!m) {\r\n            return isArray(this._weekdays) ? this._weekdays :\r\n                this._weekdays['standalone'];\r\n        }\r\n        return isArray(this._weekdays) ? this._weekdays[m.day()] :\r\n            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];\r\n    }\r\n\r\n    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');\r\n    function localeWeekdaysShort (m) {\r\n        return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;\r\n    }\r\n\r\n    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');\r\n    function localeWeekdaysMin (m) {\r\n        return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;\r\n    }\r\n\r\n    function handleStrictParse$1(weekdayName, format, strict) {\r\n        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();\r\n        if (!this._weekdaysParse) {\r\n            this._weekdaysParse = [];\r\n            this._shortWeekdaysParse = [];\r\n            this._minWeekdaysParse = [];\r\n\r\n            for (i = 0; i < 7; ++i) {\r\n                mom = createUTC([2000, 1]).day(i);\r\n                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();\r\n                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();\r\n                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\r\n            }\r\n        }\r\n\r\n        if (strict) {\r\n            if (format === 'dddd') {\r\n                ii = indexOf.call(this._weekdaysParse, llc);\r\n                return ii !== -1 ? ii : null;\r\n            } else if (format === 'ddd') {\r\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\r\n                return ii !== -1 ? ii : null;\r\n            } else {\r\n                ii = indexOf.call(this._minWeekdaysParse, llc);\r\n                return ii !== -1 ? ii : null;\r\n            }\r\n        } else {\r\n            if (format === 'dddd') {\r\n                ii = indexOf.call(this._weekdaysParse, llc);\r\n                if (ii !== -1) {\r\n                    return ii;\r\n                }\r\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\r\n                if (ii !== -1) {\r\n                    return ii;\r\n                }\r\n                ii = indexOf.call(this._minWeekdaysParse, llc);\r\n                return ii !== -1 ? ii : null;\r\n            } else if (format === 'ddd') {\r\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\r\n                if (ii !== -1) {\r\n                    return ii;\r\n                }\r\n                ii = indexOf.call(this._weekdaysParse, llc);\r\n                if (ii !== -1) {\r\n                    return ii;\r\n                }\r\n                ii = indexOf.call(this._minWeekdaysParse, llc);\r\n                return ii !== -1 ? ii : null;\r\n            } else {\r\n                ii = indexOf.call(this._minWeekdaysParse, llc);\r\n                if (ii !== -1) {\r\n                    return ii;\r\n                }\r\n                ii = indexOf.call(this._weekdaysParse, llc);\r\n                if (ii !== -1) {\r\n                    return ii;\r\n                }\r\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\r\n                return ii !== -1 ? ii : null;\r\n            }\r\n        }\r\n    }\r\n\r\n    function localeWeekdaysParse (weekdayName, format, strict) {\r\n        var i, mom, regex;\r\n\r\n        if (this._weekdaysParseExact) {\r\n            return handleStrictParse$1.call(this, weekdayName, format, strict);\r\n        }\r\n\r\n        if (!this._weekdaysParse) {\r\n            this._weekdaysParse = [];\r\n            this._minWeekdaysParse = [];\r\n            this._shortWeekdaysParse = [];\r\n            this._fullWeekdaysParse = [];\r\n        }\r\n\r\n        for (i = 0; i < 7; i++) {\r\n            // make the regex if we don't have it already\r\n\r\n            mom = createUTC([2000, 1]).day(i);\r\n            if (strict && !this._fullWeekdaysParse[i]) {\r\n                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\\\.?') + '$', 'i');\r\n                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\\\.?') + '$', 'i');\r\n                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\\\.?') + '$', 'i');\r\n            }\r\n            if (!this._weekdaysParse[i]) {\r\n                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\r\n                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\r\n            }\r\n            // test the regex\r\n            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {\r\n                return i;\r\n            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {\r\n                return i;\r\n            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {\r\n                return i;\r\n            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n\r\n    // MOMENTS\r\n\r\n    function getSetDayOfWeek (input) {\r\n        if (!this.isValid()) {\r\n            return input != null ? this : NaN;\r\n        }\r\n        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\r\n        if (input != null) {\r\n            input = parseWeekday(input, this.localeData());\r\n            return this.add(input - day, 'd');\r\n        } else {\r\n            return day;\r\n        }\r\n    }\r\n\r\n    function getSetLocaleDayOfWeek (input) {\r\n        if (!this.isValid()) {\r\n            return input != null ? this : NaN;\r\n        }\r\n        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\r\n        return input == null ? weekday : this.add(input - weekday, 'd');\r\n    }\r\n\r\n    function getSetISODayOfWeek (input) {\r\n        if (!this.isValid()) {\r\n            return input != null ? this : NaN;\r\n        }\r\n\r\n        // behaves the same as moment#day except\r\n        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\r\n        // as a setter, sunday should belong to the previous week.\r\n\r\n        if (input != null) {\r\n            var weekday = parseIsoWeekday(input, this.localeData());\r\n            return this.day(this.day() % 7 ? weekday : weekday - 7);\r\n        } else {\r\n            return this.day() || 7;\r\n        }\r\n    }\r\n\r\n    var defaultWeekdaysRegex = matchWord;\r\n    function weekdaysRegex (isStrict) {\r\n        if (this._weekdaysParseExact) {\r\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\r\n                computeWeekdaysParse.call(this);\r\n            }\r\n            if (isStrict) {\r\n                return this._weekdaysStrictRegex;\r\n            } else {\r\n                return this._weekdaysRegex;\r\n            }\r\n        } else {\r\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\r\n                this._weekdaysRegex = defaultWeekdaysRegex;\r\n            }\r\n            return this._weekdaysStrictRegex && isStrict ?\r\n                this._weekdaysStrictRegex : this._weekdaysRegex;\r\n        }\r\n    }\r\n\r\n    var defaultWeekdaysShortRegex = matchWord;\r\n    function weekdaysShortRegex (isStrict) {\r\n        if (this._weekdaysParseExact) {\r\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\r\n                computeWeekdaysParse.call(this);\r\n            }\r\n            if (isStrict) {\r\n                return this._weekdaysShortStrictRegex;\r\n            } else {\r\n                return this._weekdaysShortRegex;\r\n            }\r\n        } else {\r\n            if (!hasOwnProp(this, '_weekdaysShortRegex')) {\r\n                this._weekdaysShortRegex = defaultWeekdaysShortRegex;\r\n            }\r\n            return this._weekdaysShortStrictRegex && isStrict ?\r\n                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\r\n        }\r\n    }\r\n\r\n    var defaultWeekdaysMinRegex = matchWord;\r\n    function weekdaysMinRegex (isStrict) {\r\n        if (this._weekdaysParseExact) {\r\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\r\n                computeWeekdaysParse.call(this);\r\n            }\r\n            if (isStrict) {\r\n                return this._weekdaysMinStrictRegex;\r\n            } else {\r\n                return this._weekdaysMinRegex;\r\n            }\r\n        } else {\r\n            if (!hasOwnProp(this, '_weekdaysMinRegex')) {\r\n                this._weekdaysMinRegex = defaultWeekdaysMinRegex;\r\n            }\r\n            return this._weekdaysMinStrictRegex && isStrict ?\r\n                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\r\n        }\r\n    }\r\n\r\n\r\n    function computeWeekdaysParse () {\r\n        function cmpLenRev(a, b) {\r\n            return b.length - a.length;\r\n        }\r\n\r\n        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],\r\n            i, mom, minp, shortp, longp;\r\n        for (i = 0; i < 7; i++) {\r\n            // make the regex if we don't have it already\r\n            mom = createUTC([2000, 1]).day(i);\r\n            minp = this.weekdaysMin(mom, '');\r\n            shortp = this.weekdaysShort(mom, '');\r\n            longp = this.weekdays(mom, '');\r\n            minPieces.push(minp);\r\n            shortPieces.push(shortp);\r\n            longPieces.push(longp);\r\n            mixedPieces.push(minp);\r\n            mixedPieces.push(shortp);\r\n            mixedPieces.push(longp);\r\n        }\r\n        // Sorting makes sure if one weekday (or abbr) is a prefix of another it\r\n        // will match the longer piece.\r\n        minPieces.sort(cmpLenRev);\r\n        shortPieces.sort(cmpLenRev);\r\n        longPieces.sort(cmpLenRev);\r\n        mixedPieces.sort(cmpLenRev);\r\n        for (i = 0; i < 7; i++) {\r\n            shortPieces[i] = regexEscape(shortPieces[i]);\r\n            longPieces[i] = regexEscape(longPieces[i]);\r\n            mixedPieces[i] = regexEscape(mixedPieces[i]);\r\n        }\r\n\r\n        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\r\n        this._weekdaysShortRegex = this._weekdaysRegex;\r\n        this._weekdaysMinRegex = this._weekdaysRegex;\r\n\r\n        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\r\n        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\r\n        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');\r\n    }\r\n\r\n    // FORMATTING\r\n\r\n    function hFormat() {\r\n        return this.hours() % 12 || 12;\r\n    }\r\n\r\n    function kFormat() {\r\n        return this.hours() || 24;\r\n    }\r\n\r\n    addFormatToken('H', ['HH', 2], 0, 'hour');\r\n    addFormatToken('h', ['hh', 2], 0, hFormat);\r\n    addFormatToken('k', ['kk', 2], 0, kFormat);\r\n\r\n    addFormatToken('hmm', 0, 0, function () {\r\n        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\r\n    });\r\n\r\n    addFormatToken('hmmss', 0, 0, function () {\r\n        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +\r\n            zeroFill(this.seconds(), 2);\r\n    });\r\n\r\n    addFormatToken('Hmm', 0, 0, function () {\r\n        return '' + this.hours() + zeroFill(this.minutes(), 2);\r\n    });\r\n\r\n    addFormatToken('Hmmss', 0, 0, function () {\r\n        return '' + this.hours() + zeroFill(this.minutes(), 2) +\r\n            zeroFill(this.seconds(), 2);\r\n    });\r\n\r\n    function meridiem (token, lowercase) {\r\n        addFormatToken(token, 0, 0, function () {\r\n            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\r\n        });\r\n    }\r\n\r\n    meridiem('a', true);\r\n    meridiem('A', false);\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('hour', 'h');\r\n\r\n    // PRIORITY\r\n    addUnitPriority('hour', 13);\r\n\r\n    // PARSING\r\n\r\n    function matchMeridiem (isStrict, locale) {\r\n        return locale._meridiemParse;\r\n    }\r\n\r\n    addRegexToken('a',  matchMeridiem);\r\n    addRegexToken('A',  matchMeridiem);\r\n    addRegexToken('H',  match1to2);\r\n    addRegexToken('h',  match1to2);\r\n    addRegexToken('k',  match1to2);\r\n    addRegexToken('HH', match1to2, match2);\r\n    addRegexToken('hh', match1to2, match2);\r\n    addRegexToken('kk', match1to2, match2);\r\n\r\n    addRegexToken('hmm', match3to4);\r\n    addRegexToken('hmmss', match5to6);\r\n    addRegexToken('Hmm', match3to4);\r\n    addRegexToken('Hmmss', match5to6);\r\n\r\n    addParseToken(['H', 'HH'], HOUR);\r\n    addParseToken(['k', 'kk'], function (input, array, config) {\r\n        var kInput = toInt(input);\r\n        array[HOUR] = kInput === 24 ? 0 : kInput;\r\n    });\r\n    addParseToken(['a', 'A'], function (input, array, config) {\r\n        config._isPm = config._locale.isPM(input);\r\n        config._meridiem = input;\r\n    });\r\n    addParseToken(['h', 'hh'], function (input, array, config) {\r\n        array[HOUR] = toInt(input);\r\n        getParsingFlags(config).bigHour = true;\r\n    });\r\n    addParseToken('hmm', function (input, array, config) {\r\n        var pos = input.length - 2;\r\n        array[HOUR] = toInt(input.substr(0, pos));\r\n        array[MINUTE] = toInt(input.substr(pos));\r\n        getParsingFlags(config).bigHour = true;\r\n    });\r\n    addParseToken('hmmss', function (input, array, config) {\r\n        var pos1 = input.length - 4;\r\n        var pos2 = input.length - 2;\r\n        array[HOUR] = toInt(input.substr(0, pos1));\r\n        array[MINUTE] = toInt(input.substr(pos1, 2));\r\n        array[SECOND] = toInt(input.substr(pos2));\r\n        getParsingFlags(config).bigHour = true;\r\n    });\r\n    addParseToken('Hmm', function (input, array, config) {\r\n        var pos = input.length - 2;\r\n        array[HOUR] = toInt(input.substr(0, pos));\r\n        array[MINUTE] = toInt(input.substr(pos));\r\n    });\r\n    addParseToken('Hmmss', function (input, array, config) {\r\n        var pos1 = input.length - 4;\r\n        var pos2 = input.length - 2;\r\n        array[HOUR] = toInt(input.substr(0, pos1));\r\n        array[MINUTE] = toInt(input.substr(pos1, 2));\r\n        array[SECOND] = toInt(input.substr(pos2));\r\n    });\r\n\r\n    // LOCALES\r\n\r\n    function localeIsPM (input) {\r\n        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\r\n        // Using charAt should be more compatible.\r\n        return ((input + '').toLowerCase().charAt(0) === 'p');\r\n    }\r\n\r\n    var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i;\r\n    function localeMeridiem (hours, minutes, isLower) {\r\n        if (hours > 11) {\r\n            return isLower ? 'pm' : 'PM';\r\n        } else {\r\n            return isLower ? 'am' : 'AM';\r\n        }\r\n    }\r\n\r\n\r\n    // MOMENTS\r\n\r\n    // Setting the hour should keep the time, because the user explicitly\r\n    // specified which hour they want. So trying to maintain the same hour (in\r\n    // a new timezone) makes sense. Adding/subtracting hours does not follow\r\n    // this rule.\r\n    var getSetHour = makeGetSet('Hours', true);\r\n\r\n    var baseConfig = {\r\n        calendar: defaultCalendar,\r\n        longDateFormat: defaultLongDateFormat,\r\n        invalidDate: defaultInvalidDate,\r\n        ordinal: defaultOrdinal,\r\n        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\r\n        relativeTime: defaultRelativeTime,\r\n\r\n        months: defaultLocaleMonths,\r\n        monthsShort: defaultLocaleMonthsShort,\r\n\r\n        week: defaultLocaleWeek,\r\n\r\n        weekdays: defaultLocaleWeekdays,\r\n        weekdaysMin: defaultLocaleWeekdaysMin,\r\n        weekdaysShort: defaultLocaleWeekdaysShort,\r\n\r\n        meridiemParse: defaultLocaleMeridiemParse\r\n    };\r\n\r\n    // internal storage for locale config files\r\n    var locales = {};\r\n    var localeFamilies = {};\r\n    var globalLocale;\r\n\r\n    function normalizeLocale(key) {\r\n        return key ? key.toLowerCase().replace('_', '-') : key;\r\n    }\r\n\r\n    // pick the locale from the array\r\n    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\r\n    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\r\n    function chooseLocale(names) {\r\n        var i = 0, j, next, locale, split;\r\n\r\n        while (i < names.length) {\r\n            split = normalizeLocale(names[i]).split('-');\r\n            j = split.length;\r\n            next = normalizeLocale(names[i + 1]);\r\n            next = next ? next.split('-') : null;\r\n            while (j > 0) {\r\n                locale = loadLocale(split.slice(0, j).join('-'));\r\n                if (locale) {\r\n                    return locale;\r\n                }\r\n                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\r\n                    //the next array item is better than a shallower substring of this one\r\n                    break;\r\n                }\r\n                j--;\r\n            }\r\n            i++;\r\n        }\r\n        return globalLocale;\r\n    }\r\n\r\n    function loadLocale(name) {\r\n        var oldLocale = null;\r\n        // TODO: Find a better way to register and load all the locales in Node\r\n        if (!locales[name] && (typeof module !== 'undefined') &&\r\n                module && module.exports) {\r\n            try {\r\n                oldLocale = globalLocale._abbr;\r\n                var aliasedRequire = require;\r\n                !(function webpackMissingModule() { var e = new Error(\"Cannot find module 'undefined'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\r\n                getSetGlobalLocale(oldLocale);\r\n            } catch (e) {}\r\n        }\r\n        return locales[name];\r\n    }\r\n\r\n    // This function will load locale and then set the global locale.  If\r\n    // no arguments are passed in, it will simply return the current global\r\n    // locale key.\r\n    function getSetGlobalLocale (key, values) {\r\n        var data;\r\n        if (key) {\r\n            if (isUndefined(values)) {\r\n                data = getLocale(key);\r\n            }\r\n            else {\r\n                data = defineLocale(key, values);\r\n            }\r\n\r\n            if (data) {\r\n                // moment.duration._locale = moment._locale = data;\r\n                globalLocale = data;\r\n            }\r\n            else {\r\n                if ((typeof console !==  'undefined') && console.warn) {\r\n                    //warn user if arguments are passed but the locale could not be set\r\n                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');\r\n                }\r\n            }\r\n        }\r\n\r\n        return globalLocale._abbr;\r\n    }\r\n\r\n    function defineLocale (name, config) {\r\n        if (config !== null) {\r\n            var locale, parentConfig = baseConfig;\r\n            config.abbr = name;\r\n            if (locales[name] != null) {\r\n                deprecateSimple('defineLocaleOverride',\r\n                        'use moment.updateLocale(localeName, config) to change ' +\r\n                        'an existing locale. moment.defineLocale(localeName, ' +\r\n                        'config) should only be used for creating a new locale ' +\r\n                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');\r\n                parentConfig = locales[name]._config;\r\n            } else if (config.parentLocale != null) {\r\n                if (locales[config.parentLocale] != null) {\r\n                    parentConfig = locales[config.parentLocale]._config;\r\n                } else {\r\n                    locale = loadLocale(config.parentLocale);\r\n                    if (locale != null) {\r\n                        parentConfig = locale._config;\r\n                    } else {\r\n                        if (!localeFamilies[config.parentLocale]) {\r\n                            localeFamilies[config.parentLocale] = [];\r\n                        }\r\n                        localeFamilies[config.parentLocale].push({\r\n                            name: name,\r\n                            config: config\r\n                        });\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n            locales[name] = new Locale(mergeConfigs(parentConfig, config));\r\n\r\n            if (localeFamilies[name]) {\r\n                localeFamilies[name].forEach(function (x) {\r\n                    defineLocale(x.name, x.config);\r\n                });\r\n            }\r\n\r\n            // backwards compat for now: also set the locale\r\n            // make sure we set the locale AFTER all child locales have been\r\n            // created, so we won't end up with the child locale set.\r\n            getSetGlobalLocale(name);\r\n\r\n\r\n            return locales[name];\r\n        } else {\r\n            // useful for testing\r\n            delete locales[name];\r\n            return null;\r\n        }\r\n    }\r\n\r\n    function updateLocale(name, config) {\r\n        if (config != null) {\r\n            var locale, tmpLocale, parentConfig = baseConfig;\r\n            // MERGE\r\n            tmpLocale = loadLocale(name);\r\n            if (tmpLocale != null) {\r\n                parentConfig = tmpLocale._config;\r\n            }\r\n            config = mergeConfigs(parentConfig, config);\r\n            locale = new Locale(config);\r\n            locale.parentLocale = locales[name];\r\n            locales[name] = locale;\r\n\r\n            // backwards compat for now: also set the locale\r\n            getSetGlobalLocale(name);\r\n        } else {\r\n            // pass null for config to unupdate, useful for tests\r\n            if (locales[name] != null) {\r\n                if (locales[name].parentLocale != null) {\r\n                    locales[name] = locales[name].parentLocale;\r\n                } else if (locales[name] != null) {\r\n                    delete locales[name];\r\n                }\r\n            }\r\n        }\r\n        return locales[name];\r\n    }\r\n\r\n    // returns locale data\r\n    function getLocale (key) {\r\n        var locale;\r\n\r\n        if (key && key._locale && key._locale._abbr) {\r\n            key = key._locale._abbr;\r\n        }\r\n\r\n        if (!key) {\r\n            return globalLocale;\r\n        }\r\n\r\n        if (!isArray(key)) {\r\n            //short-circuit everything else\r\n            locale = loadLocale(key);\r\n            if (locale) {\r\n                return locale;\r\n            }\r\n            key = [key];\r\n        }\r\n\r\n        return chooseLocale(key);\r\n    }\r\n\r\n    function listLocales() {\r\n        return keys(locales);\r\n    }\r\n\r\n    function checkOverflow (m) {\r\n        var overflow;\r\n        var a = m._a;\r\n\r\n        if (a && getParsingFlags(m).overflow === -2) {\r\n            overflow =\r\n                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :\r\n                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :\r\n                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :\r\n                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :\r\n                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :\r\n                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :\r\n                -1;\r\n\r\n            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\r\n                overflow = DATE;\r\n            }\r\n            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\r\n                overflow = WEEK;\r\n            }\r\n            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\r\n                overflow = WEEKDAY;\r\n            }\r\n\r\n            getParsingFlags(m).overflow = overflow;\r\n        }\r\n\r\n        return m;\r\n    }\r\n\r\n    // Pick the first defined of two or three arguments.\r\n    function defaults(a, b, c) {\r\n        if (a != null) {\r\n            return a;\r\n        }\r\n        if (b != null) {\r\n            return b;\r\n        }\r\n        return c;\r\n    }\r\n\r\n    function currentDateArray(config) {\r\n        // hooks is actually the exported moment object\r\n        var nowValue = new Date(hooks.now());\r\n        if (config._useUTC) {\r\n            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];\r\n        }\r\n        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\r\n    }\r\n\r\n    // convert an array to a date.\r\n    // the array should mirror the parameters below\r\n    // note: all values past the year are optional and will default to the lowest possible value.\r\n    // [year, month, day , hour, minute, second, millisecond]\r\n    function configFromArray (config) {\r\n        var i, date, input = [], currentDate, expectedWeekday, yearToUse;\r\n\r\n        if (config._d) {\r\n            return;\r\n        }\r\n\r\n        currentDate = currentDateArray(config);\r\n\r\n        //compute day of the year from weeks and weekdays\r\n        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\r\n            dayOfYearFromWeekInfo(config);\r\n        }\r\n\r\n        //if the day of the year is set, figure out what it is\r\n        if (config._dayOfYear != null) {\r\n            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\r\n\r\n            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {\r\n                getParsingFlags(config)._overflowDayOfYear = true;\r\n            }\r\n\r\n            date = createUTCDate(yearToUse, 0, config._dayOfYear);\r\n            config._a[MONTH] = date.getUTCMonth();\r\n            config._a[DATE] = date.getUTCDate();\r\n        }\r\n\r\n        // Default to current date.\r\n        // * if no year, month, day of month are given, default to today\r\n        // * if day of month is given, default month and year\r\n        // * if month is given, default only year\r\n        // * if year is given, don't default anything\r\n        for (i = 0; i < 3 && config._a[i] == null; ++i) {\r\n            config._a[i] = input[i] = currentDate[i];\r\n        }\r\n\r\n        // Zero out whatever was not defaulted, including time\r\n        for (; i < 7; i++) {\r\n            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\r\n        }\r\n\r\n        // Check for 24:00:00.000\r\n        if (config._a[HOUR] === 24 &&\r\n                config._a[MINUTE] === 0 &&\r\n                config._a[SECOND] === 0 &&\r\n                config._a[MILLISECOND] === 0) {\r\n            config._nextDay = true;\r\n            config._a[HOUR] = 0;\r\n        }\r\n\r\n        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\r\n        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();\r\n\r\n        // Apply timezone offset from input. The actual utcOffset can be changed\r\n        // with parseZone.\r\n        if (config._tzm != null) {\r\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\r\n        }\r\n\r\n        if (config._nextDay) {\r\n            config._a[HOUR] = 24;\r\n        }\r\n\r\n        // check for mismatching day of week\r\n        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {\r\n            getParsingFlags(config).weekdayMismatch = true;\r\n        }\r\n    }\r\n\r\n    function dayOfYearFromWeekInfo(config) {\r\n        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;\r\n\r\n        w = config._w;\r\n        if (w.GG != null || w.W != null || w.E != null) {\r\n            dow = 1;\r\n            doy = 4;\r\n\r\n            // TODO: We need to take the current isoWeekYear, but that depends on\r\n            // how we interpret now (local, utc, fixed offset). So create\r\n            // a now version of current config (take local/utc/offset flags, and\r\n            // create now).\r\n            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);\r\n            week = defaults(w.W, 1);\r\n            weekday = defaults(w.E, 1);\r\n            if (weekday < 1 || weekday > 7) {\r\n                weekdayOverflow = true;\r\n            }\r\n        } else {\r\n            dow = config._locale._week.dow;\r\n            doy = config._locale._week.doy;\r\n\r\n            var curWeek = weekOfYear(createLocal(), dow, doy);\r\n\r\n            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\r\n\r\n            // Default to current week.\r\n            week = defaults(w.w, curWeek.week);\r\n\r\n            if (w.d != null) {\r\n                // weekday -- low day numbers are considered next week\r\n                weekday = w.d;\r\n                if (weekday < 0 || weekday > 6) {\r\n                    weekdayOverflow = true;\r\n                }\r\n            } else if (w.e != null) {\r\n                // local weekday -- counting starts from begining of week\r\n                weekday = w.e + dow;\r\n                if (w.e < 0 || w.e > 6) {\r\n                    weekdayOverflow = true;\r\n                }\r\n            } else {\r\n                // default to begining of week\r\n                weekday = dow;\r\n            }\r\n        }\r\n        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\r\n            getParsingFlags(config)._overflowWeeks = true;\r\n        } else if (weekdayOverflow != null) {\r\n            getParsingFlags(config)._overflowWeekday = true;\r\n        } else {\r\n            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\r\n            config._a[YEAR] = temp.year;\r\n            config._dayOfYear = temp.dayOfYear;\r\n        }\r\n    }\r\n\r\n    // iso 8601 regex\r\n    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\r\n    var extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\r\n    var basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\r\n\r\n    var tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/;\r\n\r\n    var isoDates = [\r\n        ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/],\r\n        ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/],\r\n        ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/],\r\n        ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false],\r\n        ['YYYY-DDD', /\\d{4}-\\d{3}/],\r\n        ['YYYY-MM', /\\d{4}-\\d\\d/, false],\r\n        ['YYYYYYMMDD', /[+-]\\d{10}/],\r\n        ['YYYYMMDD', /\\d{8}/],\r\n        // YYYYMM is NOT allowed by the standard\r\n        ['GGGG[W]WWE', /\\d{4}W\\d{3}/],\r\n        ['GGGG[W]WW', /\\d{4}W\\d{2}/, false],\r\n        ['YYYYDDD', /\\d{7}/]\r\n    ];\r\n\r\n    // iso time formats and regexes\r\n    var isoTimes = [\r\n        ['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\r\n        ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/],\r\n        ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/],\r\n        ['HH:mm', /\\d\\d:\\d\\d/],\r\n        ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/],\r\n        ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/],\r\n        ['HHmmss', /\\d\\d\\d\\d\\d\\d/],\r\n        ['HHmm', /\\d\\d\\d\\d/],\r\n        ['HH', /\\d\\d/]\r\n    ];\r\n\r\n    var aspNetJsonRegex = /^\\/?Date\\((\\-?\\d+)/i;\r\n\r\n    // date from iso format\r\n    function configFromISO(config) {\r\n        var i, l,\r\n            string = config._i,\r\n            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\r\n            allowTime, dateFormat, timeFormat, tzFormat;\r\n\r\n        if (match) {\r\n            getParsingFlags(config).iso = true;\r\n\r\n            for (i = 0, l = isoDates.length; i < l; i++) {\r\n                if (isoDates[i][1].exec(match[1])) {\r\n                    dateFormat = isoDates[i][0];\r\n                    allowTime = isoDates[i][2] !== false;\r\n                    break;\r\n                }\r\n            }\r\n            if (dateFormat == null) {\r\n                config._isValid = false;\r\n                return;\r\n            }\r\n            if (match[3]) {\r\n                for (i = 0, l = isoTimes.length; i < l; i++) {\r\n                    if (isoTimes[i][1].exec(match[3])) {\r\n                        // match[2] should be 'T' or space\r\n                        timeFormat = (match[2] || ' ') + isoTimes[i][0];\r\n                        break;\r\n                    }\r\n                }\r\n                if (timeFormat == null) {\r\n                    config._isValid = false;\r\n                    return;\r\n                }\r\n            }\r\n            if (!allowTime && timeFormat != null) {\r\n                config._isValid = false;\r\n                return;\r\n            }\r\n            if (match[4]) {\r\n                if (tzRegex.exec(match[4])) {\r\n                    tzFormat = 'Z';\r\n                } else {\r\n                    config._isValid = false;\r\n                    return;\r\n                }\r\n            }\r\n            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\r\n            configFromStringAndFormat(config);\r\n        } else {\r\n            config._isValid = false;\r\n        }\r\n    }\r\n\r\n    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\r\n    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/;\r\n\r\n    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\r\n        var result = [\r\n            untruncateYear(yearStr),\r\n            defaultLocaleMonthsShort.indexOf(monthStr),\r\n            parseInt(dayStr, 10),\r\n            parseInt(hourStr, 10),\r\n            parseInt(minuteStr, 10)\r\n        ];\r\n\r\n        if (secondStr) {\r\n            result.push(parseInt(secondStr, 10));\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function untruncateYear(yearStr) {\r\n        var year = parseInt(yearStr, 10);\r\n        if (year <= 49) {\r\n            return 2000 + year;\r\n        } else if (year <= 999) {\r\n            return 1900 + year;\r\n        }\r\n        return year;\r\n    }\r\n\r\n    function preprocessRFC2822(s) {\r\n        // Remove comments and folding whitespace and replace multiple-spaces with a single space\r\n        return s.replace(/\\([^)]*\\)|[\\n\\t]/g, ' ').replace(/(\\s\\s+)/g, ' ').replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\r\n    }\r\n\r\n    function checkWeekday(weekdayStr, parsedInput, config) {\r\n        if (weekdayStr) {\r\n            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.\r\n            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),\r\n                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();\r\n            if (weekdayProvided !== weekdayActual) {\r\n                getParsingFlags(config).weekdayMismatch = true;\r\n                config._isValid = false;\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    var obsOffsets = {\r\n        UT: 0,\r\n        GMT: 0,\r\n        EDT: -4 * 60,\r\n        EST: -5 * 60,\r\n        CDT: -5 * 60,\r\n        CST: -6 * 60,\r\n        MDT: -6 * 60,\r\n        MST: -7 * 60,\r\n        PDT: -7 * 60,\r\n        PST: -8 * 60\r\n    };\r\n\r\n    function calculateOffset(obsOffset, militaryOffset, numOffset) {\r\n        if (obsOffset) {\r\n            return obsOffsets[obsOffset];\r\n        } else if (militaryOffset) {\r\n            // the only allowed military tz is Z\r\n            return 0;\r\n        } else {\r\n            var hm = parseInt(numOffset, 10);\r\n            var m = hm % 100, h = (hm - m) / 100;\r\n            return h * 60 + m;\r\n        }\r\n    }\r\n\r\n    // date and time from ref 2822 format\r\n    function configFromRFC2822(config) {\r\n        var match = rfc2822.exec(preprocessRFC2822(config._i));\r\n        if (match) {\r\n            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);\r\n            if (!checkWeekday(match[1], parsedArray, config)) {\r\n                return;\r\n            }\r\n\r\n            config._a = parsedArray;\r\n            config._tzm = calculateOffset(match[8], match[9], match[10]);\r\n\r\n            config._d = createUTCDate.apply(null, config._a);\r\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\r\n\r\n            getParsingFlags(config).rfc2822 = true;\r\n        } else {\r\n            config._isValid = false;\r\n        }\r\n    }\r\n\r\n    // date from iso format or fallback\r\n    function configFromString(config) {\r\n        var matched = aspNetJsonRegex.exec(config._i);\r\n\r\n        if (matched !== null) {\r\n            config._d = new Date(+matched[1]);\r\n            return;\r\n        }\r\n\r\n        configFromISO(config);\r\n        if (config._isValid === false) {\r\n            delete config._isValid;\r\n        } else {\r\n            return;\r\n        }\r\n\r\n        configFromRFC2822(config);\r\n        if (config._isValid === false) {\r\n            delete config._isValid;\r\n        } else {\r\n            return;\r\n        }\r\n\r\n        // Final attempt, use Input Fallback\r\n        hooks.createFromInputFallback(config);\r\n    }\r\n\r\n    hooks.createFromInputFallback = deprecate(\r\n        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +\r\n        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +\r\n        'discouraged and will be removed in an upcoming major release. Please refer to ' +\r\n        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',\r\n        function (config) {\r\n            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\r\n        }\r\n    );\r\n\r\n    // constant that refers to the ISO standard\r\n    hooks.ISO_8601 = function () {};\r\n\r\n    // constant that refers to the RFC 2822 form\r\n    hooks.RFC_2822 = function () {};\r\n\r\n    // date from string and format string\r\n    function configFromStringAndFormat(config) {\r\n        // TODO: Move this to another part of the creation flow to prevent circular deps\r\n        if (config._f === hooks.ISO_8601) {\r\n            configFromISO(config);\r\n            return;\r\n        }\r\n        if (config._f === hooks.RFC_2822) {\r\n            configFromRFC2822(config);\r\n            return;\r\n        }\r\n        config._a = [];\r\n        getParsingFlags(config).empty = true;\r\n\r\n        // This array is used to make a Date, either with `new Date` or `Date.UTC`\r\n        var string = '' + config._i,\r\n            i, parsedInput, tokens, token, skipped,\r\n            stringLength = string.length,\r\n            totalParsedInputLength = 0;\r\n\r\n        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\r\n\r\n        for (i = 0; i < tokens.length; i++) {\r\n            token = tokens[i];\r\n            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\r\n            // console.log('token', token, 'parsedInput', parsedInput,\r\n            //         'regex', getParseRegexForToken(token, config));\r\n            if (parsedInput) {\r\n                skipped = string.substr(0, string.indexOf(parsedInput));\r\n                if (skipped.length > 0) {\r\n                    getParsingFlags(config).unusedInput.push(skipped);\r\n                }\r\n                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\r\n                totalParsedInputLength += parsedInput.length;\r\n            }\r\n            // don't parse if it's not a known token\r\n            if (formatTokenFunctions[token]) {\r\n                if (parsedInput) {\r\n                    getParsingFlags(config).empty = false;\r\n                }\r\n                else {\r\n                    getParsingFlags(config).unusedTokens.push(token);\r\n                }\r\n                addTimeToArrayFromToken(token, parsedInput, config);\r\n            }\r\n            else if (config._strict && !parsedInput) {\r\n                getParsingFlags(config).unusedTokens.push(token);\r\n            }\r\n        }\r\n\r\n        // add remaining unparsed input length to the string\r\n        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\r\n        if (string.length > 0) {\r\n            getParsingFlags(config).unusedInput.push(string);\r\n        }\r\n\r\n        // clear _12h flag if hour is <= 12\r\n        if (config._a[HOUR] <= 12 &&\r\n            getParsingFlags(config).bigHour === true &&\r\n            config._a[HOUR] > 0) {\r\n            getParsingFlags(config).bigHour = undefined;\r\n        }\r\n\r\n        getParsingFlags(config).parsedDateParts = config._a.slice(0);\r\n        getParsingFlags(config).meridiem = config._meridiem;\r\n        // handle meridiem\r\n        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\r\n\r\n        configFromArray(config);\r\n        checkOverflow(config);\r\n    }\r\n\r\n\r\n    function meridiemFixWrap (locale, hour, meridiem) {\r\n        var isPm;\r\n\r\n        if (meridiem == null) {\r\n            // nothing to do\r\n            return hour;\r\n        }\r\n        if (locale.meridiemHour != null) {\r\n            return locale.meridiemHour(hour, meridiem);\r\n        } else if (locale.isPM != null) {\r\n            // Fallback\r\n            isPm = locale.isPM(meridiem);\r\n            if (isPm && hour < 12) {\r\n                hour += 12;\r\n            }\r\n            if (!isPm && hour === 12) {\r\n                hour = 0;\r\n            }\r\n            return hour;\r\n        } else {\r\n            // this is not supposed to happen\r\n            return hour;\r\n        }\r\n    }\r\n\r\n    // date from string and array of format strings\r\n    function configFromStringAndArray(config) {\r\n        var tempConfig,\r\n            bestMoment,\r\n\r\n            scoreToBeat,\r\n            i,\r\n            currentScore;\r\n\r\n        if (config._f.length === 0) {\r\n            getParsingFlags(config).invalidFormat = true;\r\n            config._d = new Date(NaN);\r\n            return;\r\n        }\r\n\r\n        for (i = 0; i < config._f.length; i++) {\r\n            currentScore = 0;\r\n            tempConfig = copyConfig({}, config);\r\n            if (config._useUTC != null) {\r\n                tempConfig._useUTC = config._useUTC;\r\n            }\r\n            tempConfig._f = config._f[i];\r\n            configFromStringAndFormat(tempConfig);\r\n\r\n            if (!isValid(tempConfig)) {\r\n                continue;\r\n            }\r\n\r\n            // if there is any input that was not parsed add a penalty for that format\r\n            currentScore += getParsingFlags(tempConfig).charsLeftOver;\r\n\r\n            //or tokens\r\n            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\r\n\r\n            getParsingFlags(tempConfig).score = currentScore;\r\n\r\n            if (scoreToBeat == null || currentScore < scoreToBeat) {\r\n                scoreToBeat = currentScore;\r\n                bestMoment = tempConfig;\r\n            }\r\n        }\r\n\r\n        extend(config, bestMoment || tempConfig);\r\n    }\r\n\r\n    function configFromObject(config) {\r\n        if (config._d) {\r\n            return;\r\n        }\r\n\r\n        var i = normalizeObjectUnits(config._i);\r\n        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {\r\n            return obj && parseInt(obj, 10);\r\n        });\r\n\r\n        configFromArray(config);\r\n    }\r\n\r\n    function createFromConfig (config) {\r\n        var res = new Moment(checkOverflow(prepareConfig(config)));\r\n        if (res._nextDay) {\r\n            // Adding is smart enough around DST\r\n            res.add(1, 'd');\r\n            res._nextDay = undefined;\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    function prepareConfig (config) {\r\n        var input = config._i,\r\n            format = config._f;\r\n\r\n        config._locale = config._locale || getLocale(config._l);\r\n\r\n        if (input === null || (format === undefined && input === '')) {\r\n            return createInvalid({nullInput: true});\r\n        }\r\n\r\n        if (typeof input === 'string') {\r\n            config._i = input = config._locale.preparse(input);\r\n        }\r\n\r\n        if (isMoment(input)) {\r\n            return new Moment(checkOverflow(input));\r\n        } else if (isDate(input)) {\r\n            config._d = input;\r\n        } else if (isArray(format)) {\r\n            configFromStringAndArray(config);\r\n        } else if (format) {\r\n            configFromStringAndFormat(config);\r\n        }  else {\r\n            configFromInput(config);\r\n        }\r\n\r\n        if (!isValid(config)) {\r\n            config._d = null;\r\n        }\r\n\r\n        return config;\r\n    }\r\n\r\n    function configFromInput(config) {\r\n        var input = config._i;\r\n        if (isUndefined(input)) {\r\n            config._d = new Date(hooks.now());\r\n        } else if (isDate(input)) {\r\n            config._d = new Date(input.valueOf());\r\n        } else if (typeof input === 'string') {\r\n            configFromString(config);\r\n        } else if (isArray(input)) {\r\n            config._a = map(input.slice(0), function (obj) {\r\n                return parseInt(obj, 10);\r\n            });\r\n            configFromArray(config);\r\n        } else if (isObject(input)) {\r\n            configFromObject(config);\r\n        } else if (isNumber(input)) {\r\n            // from milliseconds\r\n            config._d = new Date(input);\r\n        } else {\r\n            hooks.createFromInputFallback(config);\r\n        }\r\n    }\r\n\r\n    function createLocalOrUTC (input, format, locale, strict, isUTC) {\r\n        var c = {};\r\n\r\n        if (locale === true || locale === false) {\r\n            strict = locale;\r\n            locale = undefined;\r\n        }\r\n\r\n        if ((isObject(input) && isObjectEmpty(input)) ||\r\n                (isArray(input) && input.length === 0)) {\r\n            input = undefined;\r\n        }\r\n        // object construction must be done this way.\r\n        // https://github.com/moment/moment/issues/1423\r\n        c._isAMomentObject = true;\r\n        c._useUTC = c._isUTC = isUTC;\r\n        c._l = locale;\r\n        c._i = input;\r\n        c._f = format;\r\n        c._strict = strict;\r\n\r\n        return createFromConfig(c);\r\n    }\r\n\r\n    function createLocal (input, format, locale, strict) {\r\n        return createLocalOrUTC(input, format, locale, strict, false);\r\n    }\r\n\r\n    var prototypeMin = deprecate(\r\n        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',\r\n        function () {\r\n            var other = createLocal.apply(null, arguments);\r\n            if (this.isValid() && other.isValid()) {\r\n                return other < this ? this : other;\r\n            } else {\r\n                return createInvalid();\r\n            }\r\n        }\r\n    );\r\n\r\n    var prototypeMax = deprecate(\r\n        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',\r\n        function () {\r\n            var other = createLocal.apply(null, arguments);\r\n            if (this.isValid() && other.isValid()) {\r\n                return other > this ? this : other;\r\n            } else {\r\n                return createInvalid();\r\n            }\r\n        }\r\n    );\r\n\r\n    // Pick a moment m from moments so that m[fn](other) is true for all\r\n    // other. This relies on the function fn to be transitive.\r\n    //\r\n    // moments should either be an array of moment objects or an array, whose\r\n    // first element is an array of moment objects.\r\n    function pickBy(fn, moments) {\r\n        var res, i;\r\n        if (moments.length === 1 && isArray(moments[0])) {\r\n            moments = moments[0];\r\n        }\r\n        if (!moments.length) {\r\n            return createLocal();\r\n        }\r\n        res = moments[0];\r\n        for (i = 1; i < moments.length; ++i) {\r\n            if (!moments[i].isValid() || moments[i][fn](res)) {\r\n                res = moments[i];\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    // TODO: Use [].sort instead?\r\n    function min () {\r\n        var args = [].slice.call(arguments, 0);\r\n\r\n        return pickBy('isBefore', args);\r\n    }\r\n\r\n    function max () {\r\n        var args = [].slice.call(arguments, 0);\r\n\r\n        return pickBy('isAfter', args);\r\n    }\r\n\r\n    var now = function () {\r\n        return Date.now ? Date.now() : +(new Date());\r\n    };\r\n\r\n    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];\r\n\r\n    function isDurationValid(m) {\r\n        for (var key in m) {\r\n            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        var unitHasDecimal = false;\r\n        for (var i = 0; i < ordering.length; ++i) {\r\n            if (m[ordering[i]]) {\r\n                if (unitHasDecimal) {\r\n                    return false; // only allow non-integers for smallest unit\r\n                }\r\n                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\r\n                    unitHasDecimal = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function isValid$1() {\r\n        return this._isValid;\r\n    }\r\n\r\n    function createInvalid$1() {\r\n        return createDuration(NaN);\r\n    }\r\n\r\n    function Duration (duration) {\r\n        var normalizedInput = normalizeObjectUnits(duration),\r\n            years = normalizedInput.year || 0,\r\n            quarters = normalizedInput.quarter || 0,\r\n            months = normalizedInput.month || 0,\r\n            weeks = normalizedInput.week || 0,\r\n            days = normalizedInput.day || 0,\r\n            hours = normalizedInput.hour || 0,\r\n            minutes = normalizedInput.minute || 0,\r\n            seconds = normalizedInput.second || 0,\r\n            milliseconds = normalizedInput.millisecond || 0;\r\n\r\n        this._isValid = isDurationValid(normalizedInput);\r\n\r\n        // representation for dateAddRemove\r\n        this._milliseconds = +milliseconds +\r\n            seconds * 1e3 + // 1000\r\n            minutes * 6e4 + // 1000 * 60\r\n            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\r\n        // Because of dateAddRemove treats 24 hours as different from a\r\n        // day when working around DST, we need to store them separately\r\n        this._days = +days +\r\n            weeks * 7;\r\n        // It is impossible to translate months into days without knowing\r\n        // which months you are are talking about, so we have to store\r\n        // it separately.\r\n        this._months = +months +\r\n            quarters * 3 +\r\n            years * 12;\r\n\r\n        this._data = {};\r\n\r\n        this._locale = getLocale();\r\n\r\n        this._bubble();\r\n    }\r\n\r\n    function isDuration (obj) {\r\n        return obj instanceof Duration;\r\n    }\r\n\r\n    function absRound (number) {\r\n        if (number < 0) {\r\n            return Math.round(-1 * number) * -1;\r\n        } else {\r\n            return Math.round(number);\r\n        }\r\n    }\r\n\r\n    // FORMATTING\r\n\r\n    function offset (token, separator) {\r\n        addFormatToken(token, 0, 0, function () {\r\n            var offset = this.utcOffset();\r\n            var sign = '+';\r\n            if (offset < 0) {\r\n                offset = -offset;\r\n                sign = '-';\r\n            }\r\n            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);\r\n        });\r\n    }\r\n\r\n    offset('Z', ':');\r\n    offset('ZZ', '');\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('Z',  matchShortOffset);\r\n    addRegexToken('ZZ', matchShortOffset);\r\n    addParseToken(['Z', 'ZZ'], function (input, array, config) {\r\n        config._useUTC = true;\r\n        config._tzm = offsetFromString(matchShortOffset, input);\r\n    });\r\n\r\n    // HELPERS\r\n\r\n    // timezone chunker\r\n    // '+10:00' > ['10',  '00']\r\n    // '-1530'  > ['-15', '30']\r\n    var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\r\n\r\n    function offsetFromString(matcher, string) {\r\n        var matches = (string || '').match(matcher);\r\n\r\n        if (matches === null) {\r\n            return null;\r\n        }\r\n\r\n        var chunk   = matches[matches.length - 1] || [];\r\n        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];\r\n        var minutes = +(parts[1] * 60) + toInt(parts[2]);\r\n\r\n        return minutes === 0 ?\r\n          0 :\r\n          parts[0] === '+' ? minutes : -minutes;\r\n    }\r\n\r\n    // Return a moment from input, that is local/utc/zone equivalent to model.\r\n    function cloneWithOffset(input, model) {\r\n        var res, diff;\r\n        if (model._isUTC) {\r\n            res = model.clone();\r\n            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();\r\n            // Use low-level api, because this fn is low-level api.\r\n            res._d.setTime(res._d.valueOf() + diff);\r\n            hooks.updateOffset(res, false);\r\n            return res;\r\n        } else {\r\n            return createLocal(input).local();\r\n        }\r\n    }\r\n\r\n    function getDateOffset (m) {\r\n        // On Firefox.24 Date#getTimezoneOffset returns a floating point.\r\n        // https://github.com/moment/moment/pull/1871\r\n        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;\r\n    }\r\n\r\n    // HOOKS\r\n\r\n    // This function will be called whenever a moment is mutated.\r\n    // It is intended to keep the offset in sync with the timezone.\r\n    hooks.updateOffset = function () {};\r\n\r\n    // MOMENTS\r\n\r\n    // keepLocalTime = true means only change the timezone, without\r\n    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\r\n    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\r\n    // +0200, so we adjust the time as needed, to be valid.\r\n    //\r\n    // Keeping the time actually adds/subtracts (one hour)\r\n    // from the actual represented time. That is why we call updateOffset\r\n    // a second time. In case it wants us to change the offset again\r\n    // _changeInProgress == true case, then we have to adjust, because\r\n    // there is no such time in the given timezone.\r\n    function getSetOffset (input, keepLocalTime, keepMinutes) {\r\n        var offset = this._offset || 0,\r\n            localAdjust;\r\n        if (!this.isValid()) {\r\n            return input != null ? this : NaN;\r\n        }\r\n        if (input != null) {\r\n            if (typeof input === 'string') {\r\n                input = offsetFromString(matchShortOffset, input);\r\n                if (input === null) {\r\n                    return this;\r\n                }\r\n            } else if (Math.abs(input) < 16 && !keepMinutes) {\r\n                input = input * 60;\r\n            }\r\n            if (!this._isUTC && keepLocalTime) {\r\n                localAdjust = getDateOffset(this);\r\n            }\r\n            this._offset = input;\r\n            this._isUTC = true;\r\n            if (localAdjust != null) {\r\n                this.add(localAdjust, 'm');\r\n            }\r\n            if (offset !== input) {\r\n                if (!keepLocalTime || this._changeInProgress) {\r\n                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);\r\n                } else if (!this._changeInProgress) {\r\n                    this._changeInProgress = true;\r\n                    hooks.updateOffset(this, true);\r\n                    this._changeInProgress = null;\r\n                }\r\n            }\r\n            return this;\r\n        } else {\r\n            return this._isUTC ? offset : getDateOffset(this);\r\n        }\r\n    }\r\n\r\n    function getSetZone (input, keepLocalTime) {\r\n        if (input != null) {\r\n            if (typeof input !== 'string') {\r\n                input = -input;\r\n            }\r\n\r\n            this.utcOffset(input, keepLocalTime);\r\n\r\n            return this;\r\n        } else {\r\n            return -this.utcOffset();\r\n        }\r\n    }\r\n\r\n    function setOffsetToUTC (keepLocalTime) {\r\n        return this.utcOffset(0, keepLocalTime);\r\n    }\r\n\r\n    function setOffsetToLocal (keepLocalTime) {\r\n        if (this._isUTC) {\r\n            this.utcOffset(0, keepLocalTime);\r\n            this._isUTC = false;\r\n\r\n            if (keepLocalTime) {\r\n                this.subtract(getDateOffset(this), 'm');\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    function setOffsetToParsedOffset () {\r\n        if (this._tzm != null) {\r\n            this.utcOffset(this._tzm, false, true);\r\n        } else if (typeof this._i === 'string') {\r\n            var tZone = offsetFromString(matchOffset, this._i);\r\n            if (tZone != null) {\r\n                this.utcOffset(tZone);\r\n            }\r\n            else {\r\n                this.utcOffset(0, true);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    function hasAlignedHourOffset (input) {\r\n        if (!this.isValid()) {\r\n            return false;\r\n        }\r\n        input = input ? createLocal(input).utcOffset() : 0;\r\n\r\n        return (this.utcOffset() - input) % 60 === 0;\r\n    }\r\n\r\n    function isDaylightSavingTime () {\r\n        return (\r\n            this.utcOffset() > this.clone().month(0).utcOffset() ||\r\n            this.utcOffset() > this.clone().month(5).utcOffset()\r\n        );\r\n    }\r\n\r\n    function isDaylightSavingTimeShifted () {\r\n        if (!isUndefined(this._isDSTShifted)) {\r\n            return this._isDSTShifted;\r\n        }\r\n\r\n        var c = {};\r\n\r\n        copyConfig(c, this);\r\n        c = prepareConfig(c);\r\n\r\n        if (c._a) {\r\n            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\r\n            this._isDSTShifted = this.isValid() &&\r\n                compareArrays(c._a, other.toArray()) > 0;\r\n        } else {\r\n            this._isDSTShifted = false;\r\n        }\r\n\r\n        return this._isDSTShifted;\r\n    }\r\n\r\n    function isLocal () {\r\n        return this.isValid() ? !this._isUTC : false;\r\n    }\r\n\r\n    function isUtcOffset () {\r\n        return this.isValid() ? this._isUTC : false;\r\n    }\r\n\r\n    function isUtc () {\r\n        return this.isValid() ? this._isUTC && this._offset === 0 : false;\r\n    }\r\n\r\n    // ASP.NET json date format regex\r\n    var aspNetRegex = /^(\\-|\\+)?(?:(\\d*)[. ])?(\\d+)\\:(\\d+)(?:\\:(\\d+)(\\.\\d*)?)?$/;\r\n\r\n    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\r\n    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\r\n    // and further modified to allow for strings containing both week and day\r\n    var isoRegex = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\r\n\r\n    function createDuration (input, key) {\r\n        var duration = input,\r\n            // matching against regexp is expensive, do it on demand\r\n            match = null,\r\n            sign,\r\n            ret,\r\n            diffRes;\r\n\r\n        if (isDuration(input)) {\r\n            duration = {\r\n                ms : input._milliseconds,\r\n                d  : input._days,\r\n                M  : input._months\r\n            };\r\n        } else if (isNumber(input)) {\r\n            duration = {};\r\n            if (key) {\r\n                duration[key] = input;\r\n            } else {\r\n                duration.milliseconds = input;\r\n            }\r\n        } else if (!!(match = aspNetRegex.exec(input))) {\r\n            sign = (match[1] === '-') ? -1 : 1;\r\n            duration = {\r\n                y  : 0,\r\n                d  : toInt(match[DATE])                         * sign,\r\n                h  : toInt(match[HOUR])                         * sign,\r\n                m  : toInt(match[MINUTE])                       * sign,\r\n                s  : toInt(match[SECOND])                       * sign,\r\n                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match\r\n            };\r\n        } else if (!!(match = isoRegex.exec(input))) {\r\n            sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;\r\n            duration = {\r\n                y : parseIso(match[2], sign),\r\n                M : parseIso(match[3], sign),\r\n                w : parseIso(match[4], sign),\r\n                d : parseIso(match[5], sign),\r\n                h : parseIso(match[6], sign),\r\n                m : parseIso(match[7], sign),\r\n                s : parseIso(match[8], sign)\r\n            };\r\n        } else if (duration == null) {// checks for null or undefined\r\n            duration = {};\r\n        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {\r\n            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));\r\n\r\n            duration = {};\r\n            duration.ms = diffRes.milliseconds;\r\n            duration.M = diffRes.months;\r\n        }\r\n\r\n        ret = new Duration(duration);\r\n\r\n        if (isDuration(input) && hasOwnProp(input, '_locale')) {\r\n            ret._locale = input._locale;\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    createDuration.fn = Duration.prototype;\r\n    createDuration.invalid = createInvalid$1;\r\n\r\n    function parseIso (inp, sign) {\r\n        // We'd normally use ~~inp for this, but unfortunately it also\r\n        // converts floats to ints.\r\n        // inp may be undefined, so careful calling replace on it.\r\n        var res = inp && parseFloat(inp.replace(',', '.'));\r\n        // apply sign while we're at it\r\n        return (isNaN(res) ? 0 : res) * sign;\r\n    }\r\n\r\n    function positiveMomentsDifference(base, other) {\r\n        var res = {milliseconds: 0, months: 0};\r\n\r\n        res.months = other.month() - base.month() +\r\n            (other.year() - base.year()) * 12;\r\n        if (base.clone().add(res.months, 'M').isAfter(other)) {\r\n            --res.months;\r\n        }\r\n\r\n        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));\r\n\r\n        return res;\r\n    }\r\n\r\n    function momentsDifference(base, other) {\r\n        var res;\r\n        if (!(base.isValid() && other.isValid())) {\r\n            return {milliseconds: 0, months: 0};\r\n        }\r\n\r\n        other = cloneWithOffset(other, base);\r\n        if (base.isBefore(other)) {\r\n            res = positiveMomentsDifference(base, other);\r\n        } else {\r\n            res = positiveMomentsDifference(other, base);\r\n            res.milliseconds = -res.milliseconds;\r\n            res.months = -res.months;\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    // TODO: remove 'name' arg after deprecation is removed\r\n    function createAdder(direction, name) {\r\n        return function (val, period) {\r\n            var dur, tmp;\r\n            //invert the arguments, but complain about it\r\n            if (period !== null && !isNaN(+period)) {\r\n                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +\r\n                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');\r\n                tmp = val; val = period; period = tmp;\r\n            }\r\n\r\n            val = typeof val === 'string' ? +val : val;\r\n            dur = createDuration(val, period);\r\n            addSubtract(this, dur, direction);\r\n            return this;\r\n        };\r\n    }\r\n\r\n    function addSubtract (mom, duration, isAdding, updateOffset) {\r\n        var milliseconds = duration._milliseconds,\r\n            days = absRound(duration._days),\r\n            months = absRound(duration._months);\r\n\r\n        if (!mom.isValid()) {\r\n            // No op\r\n            return;\r\n        }\r\n\r\n        updateOffset = updateOffset == null ? true : updateOffset;\r\n\r\n        if (months) {\r\n            setMonth(mom, get(mom, 'Month') + months * isAdding);\r\n        }\r\n        if (days) {\r\n            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);\r\n        }\r\n        if (milliseconds) {\r\n            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\r\n        }\r\n        if (updateOffset) {\r\n            hooks.updateOffset(mom, days || months);\r\n        }\r\n    }\r\n\r\n    var add      = createAdder(1, 'add');\r\n    var subtract = createAdder(-1, 'subtract');\r\n\r\n    function getCalendarFormat(myMoment, now) {\r\n        var diff = myMoment.diff(now, 'days', true);\r\n        return diff < -6 ? 'sameElse' :\r\n                diff < -1 ? 'lastWeek' :\r\n                diff < 0 ? 'lastDay' :\r\n                diff < 1 ? 'sameDay' :\r\n                diff < 2 ? 'nextDay' :\r\n                diff < 7 ? 'nextWeek' : 'sameElse';\r\n    }\r\n\r\n    function calendar$1 (time, formats) {\r\n        // We want to compare the start of today, vs this.\r\n        // Getting start-of-today depends on whether we're local/utc/offset or not.\r\n        var now = time || createLocal(),\r\n            sod = cloneWithOffset(now, this).startOf('day'),\r\n            format = hooks.calendarFormat(this, sod) || 'sameElse';\r\n\r\n        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\r\n\r\n        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));\r\n    }\r\n\r\n    function clone () {\r\n        return new Moment(this);\r\n    }\r\n\r\n    function isAfter (input, units) {\r\n        var localInput = isMoment(input) ? input : createLocal(input);\r\n        if (!(this.isValid() && localInput.isValid())) {\r\n            return false;\r\n        }\r\n        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\r\n        if (units === 'millisecond') {\r\n            return this.valueOf() > localInput.valueOf();\r\n        } else {\r\n            return localInput.valueOf() < this.clone().startOf(units).valueOf();\r\n        }\r\n    }\r\n\r\n    function isBefore (input, units) {\r\n        var localInput = isMoment(input) ? input : createLocal(input);\r\n        if (!(this.isValid() && localInput.isValid())) {\r\n            return false;\r\n        }\r\n        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\r\n        if (units === 'millisecond') {\r\n            return this.valueOf() < localInput.valueOf();\r\n        } else {\r\n            return this.clone().endOf(units).valueOf() < localInput.valueOf();\r\n        }\r\n    }\r\n\r\n    function isBetween (from, to, units, inclusivity) {\r\n        inclusivity = inclusivity || '()';\r\n        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&\r\n            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));\r\n    }\r\n\r\n    function isSame (input, units) {\r\n        var localInput = isMoment(input) ? input : createLocal(input),\r\n            inputMs;\r\n        if (!(this.isValid() && localInput.isValid())) {\r\n            return false;\r\n        }\r\n        units = normalizeUnits(units || 'millisecond');\r\n        if (units === 'millisecond') {\r\n            return this.valueOf() === localInput.valueOf();\r\n        } else {\r\n            inputMs = localInput.valueOf();\r\n            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\r\n        }\r\n    }\r\n\r\n    function isSameOrAfter (input, units) {\r\n        return this.isSame(input, units) || this.isAfter(input,units);\r\n    }\r\n\r\n    function isSameOrBefore (input, units) {\r\n        return this.isSame(input, units) || this.isBefore(input,units);\r\n    }\r\n\r\n    function diff (input, units, asFloat) {\r\n        var that,\r\n            zoneDelta,\r\n            output;\r\n\r\n        if (!this.isValid()) {\r\n            return NaN;\r\n        }\r\n\r\n        that = cloneWithOffset(input, this);\r\n\r\n        if (!that.isValid()) {\r\n            return NaN;\r\n        }\r\n\r\n        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\r\n\r\n        units = normalizeUnits(units);\r\n\r\n        switch (units) {\r\n            case 'year': output = monthDiff(this, that) / 12; break;\r\n            case 'month': output = monthDiff(this, that); break;\r\n            case 'quarter': output = monthDiff(this, that) / 3; break;\r\n            case 'second': output = (this - that) / 1e3; break; // 1000\r\n            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60\r\n            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60\r\n            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst\r\n            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst\r\n            default: output = this - that;\r\n        }\r\n\r\n        return asFloat ? output : absFloor(output);\r\n    }\r\n\r\n    function monthDiff (a, b) {\r\n        // difference in months\r\n        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),\r\n            // b is in (anchor - 1 month, anchor + 1 month)\r\n            anchor = a.clone().add(wholeMonthDiff, 'months'),\r\n            anchor2, adjust;\r\n\r\n        if (b - anchor < 0) {\r\n            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\r\n            // linear across the month\r\n            adjust = (b - anchor) / (anchor - anchor2);\r\n        } else {\r\n            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\r\n            // linear across the month\r\n            adjust = (b - anchor) / (anchor2 - anchor);\r\n        }\r\n\r\n        //check for negative zero, return zero if negative zero\r\n        return -(wholeMonthDiff + adjust) || 0;\r\n    }\r\n\r\n    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\r\n    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\r\n\r\n    function toString () {\r\n        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\r\n    }\r\n\r\n    function toISOString(keepOffset) {\r\n        if (!this.isValid()) {\r\n            return null;\r\n        }\r\n        var utc = keepOffset !== true;\r\n        var m = utc ? this.clone().utc() : this;\r\n        if (m.year() < 0 || m.year() > 9999) {\r\n            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');\r\n        }\r\n        if (isFunction(Date.prototype.toISOString)) {\r\n            // native implementation is ~50x faster, use it when we can\r\n            if (utc) {\r\n                return this.toDate().toISOString();\r\n            } else {\r\n                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));\r\n            }\r\n        }\r\n        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');\r\n    }\r\n\r\n    /**\r\n     * Return a human readable representation of a moment that can\r\n     * also be evaluated to get a new moment which is the same\r\n     *\r\n     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\r\n     */\r\n    function inspect () {\r\n        if (!this.isValid()) {\r\n            return 'moment.invalid(/* ' + this._i + ' */)';\r\n        }\r\n        var func = 'moment';\r\n        var zone = '';\r\n        if (!this.isLocal()) {\r\n            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';\r\n            zone = 'Z';\r\n        }\r\n        var prefix = '[' + func + '(\"]';\r\n        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';\r\n        var datetime = '-MM-DD[T]HH:mm:ss.SSS';\r\n        var suffix = zone + '[\")]';\r\n\r\n        return this.format(prefix + year + datetime + suffix);\r\n    }\r\n\r\n    function format (inputString) {\r\n        if (!inputString) {\r\n            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\r\n        }\r\n        var output = formatMoment(this, inputString);\r\n        return this.localeData().postformat(output);\r\n    }\r\n\r\n    function from (time, withoutSuffix) {\r\n        if (this.isValid() &&\r\n                ((isMoment(time) && time.isValid()) ||\r\n                 createLocal(time).isValid())) {\r\n            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);\r\n        } else {\r\n            return this.localeData().invalidDate();\r\n        }\r\n    }\r\n\r\n    function fromNow (withoutSuffix) {\r\n        return this.from(createLocal(), withoutSuffix);\r\n    }\r\n\r\n    function to (time, withoutSuffix) {\r\n        if (this.isValid() &&\r\n                ((isMoment(time) && time.isValid()) ||\r\n                 createLocal(time).isValid())) {\r\n            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);\r\n        } else {\r\n            return this.localeData().invalidDate();\r\n        }\r\n    }\r\n\r\n    function toNow (withoutSuffix) {\r\n        return this.to(createLocal(), withoutSuffix);\r\n    }\r\n\r\n    // If passed a locale key, it will set the locale for this\r\n    // instance.  Otherwise, it will return the locale configuration\r\n    // variables for this instance.\r\n    function locale (key) {\r\n        var newLocaleData;\r\n\r\n        if (key === undefined) {\r\n            return this._locale._abbr;\r\n        } else {\r\n            newLocaleData = getLocale(key);\r\n            if (newLocaleData != null) {\r\n                this._locale = newLocaleData;\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n\r\n    var lang = deprecate(\r\n        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\r\n        function (key) {\r\n            if (key === undefined) {\r\n                return this.localeData();\r\n            } else {\r\n                return this.locale(key);\r\n            }\r\n        }\r\n    );\r\n\r\n    function localeData () {\r\n        return this._locale;\r\n    }\r\n\r\n    function startOf (units) {\r\n        units = normalizeUnits(units);\r\n        // the following switch intentionally omits break keywords\r\n        // to utilize falling through the cases.\r\n        switch (units) {\r\n            case 'year':\r\n                this.month(0);\r\n                /* falls through */\r\n            case 'quarter':\r\n            case 'month':\r\n                this.date(1);\r\n                /* falls through */\r\n            case 'week':\r\n            case 'isoWeek':\r\n            case 'day':\r\n            case 'date':\r\n                this.hours(0);\r\n                /* falls through */\r\n            case 'hour':\r\n                this.minutes(0);\r\n                /* falls through */\r\n            case 'minute':\r\n                this.seconds(0);\r\n                /* falls through */\r\n            case 'second':\r\n                this.milliseconds(0);\r\n        }\r\n\r\n        // weeks are a special case\r\n        if (units === 'week') {\r\n            this.weekday(0);\r\n        }\r\n        if (units === 'isoWeek') {\r\n            this.isoWeekday(1);\r\n        }\r\n\r\n        // quarters are also special\r\n        if (units === 'quarter') {\r\n            this.month(Math.floor(this.month() / 3) * 3);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    function endOf (units) {\r\n        units = normalizeUnits(units);\r\n        if (units === undefined || units === 'millisecond') {\r\n            return this;\r\n        }\r\n\r\n        // 'date' is an alias for 'day', so it should be considered as such.\r\n        if (units === 'date') {\r\n            units = 'day';\r\n        }\r\n\r\n        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');\r\n    }\r\n\r\n    function valueOf () {\r\n        return this._d.valueOf() - ((this._offset || 0) * 60000);\r\n    }\r\n\r\n    function unix () {\r\n        return Math.floor(this.valueOf() / 1000);\r\n    }\r\n\r\n    function toDate () {\r\n        return new Date(this.valueOf());\r\n    }\r\n\r\n    function toArray () {\r\n        var m = this;\r\n        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\r\n    }\r\n\r\n    function toObject () {\r\n        var m = this;\r\n        return {\r\n            years: m.year(),\r\n            months: m.month(),\r\n            date: m.date(),\r\n            hours: m.hours(),\r\n            minutes: m.minutes(),\r\n            seconds: m.seconds(),\r\n            milliseconds: m.milliseconds()\r\n        };\r\n    }\r\n\r\n    function toJSON () {\r\n        // new Date(NaN).toJSON() === null\r\n        return this.isValid() ? this.toISOString() : null;\r\n    }\r\n\r\n    function isValid$2 () {\r\n        return isValid(this);\r\n    }\r\n\r\n    function parsingFlags () {\r\n        return extend({}, getParsingFlags(this));\r\n    }\r\n\r\n    function invalidAt () {\r\n        return getParsingFlags(this).overflow;\r\n    }\r\n\r\n    function creationData() {\r\n        return {\r\n            input: this._i,\r\n            format: this._f,\r\n            locale: this._locale,\r\n            isUTC: this._isUTC,\r\n            strict: this._strict\r\n        };\r\n    }\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken(0, ['gg', 2], 0, function () {\r\n        return this.weekYear() % 100;\r\n    });\r\n\r\n    addFormatToken(0, ['GG', 2], 0, function () {\r\n        return this.isoWeekYear() % 100;\r\n    });\r\n\r\n    function addWeekYearFormatToken (token, getter) {\r\n        addFormatToken(0, [token, token.length], 0, getter);\r\n    }\r\n\r\n    addWeekYearFormatToken('gggg',     'weekYear');\r\n    addWeekYearFormatToken('ggggg',    'weekYear');\r\n    addWeekYearFormatToken('GGGG',  'isoWeekYear');\r\n    addWeekYearFormatToken('GGGGG', 'isoWeekYear');\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('weekYear', 'gg');\r\n    addUnitAlias('isoWeekYear', 'GG');\r\n\r\n    // PRIORITY\r\n\r\n    addUnitPriority('weekYear', 1);\r\n    addUnitPriority('isoWeekYear', 1);\r\n\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('G',      matchSigned);\r\n    addRegexToken('g',      matchSigned);\r\n    addRegexToken('GG',     match1to2, match2);\r\n    addRegexToken('gg',     match1to2, match2);\r\n    addRegexToken('GGGG',   match1to4, match4);\r\n    addRegexToken('gggg',   match1to4, match4);\r\n    addRegexToken('GGGGG',  match1to6, match6);\r\n    addRegexToken('ggggg',  match1to6, match6);\r\n\r\n    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {\r\n        week[token.substr(0, 2)] = toInt(input);\r\n    });\r\n\r\n    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\r\n        week[token] = hooks.parseTwoDigitYear(input);\r\n    });\r\n\r\n    // MOMENTS\r\n\r\n    function getSetWeekYear (input) {\r\n        return getSetWeekYearHelper.call(this,\r\n                input,\r\n                this.week(),\r\n                this.weekday(),\r\n                this.localeData()._week.dow,\r\n                this.localeData()._week.doy);\r\n    }\r\n\r\n    function getSetISOWeekYear (input) {\r\n        return getSetWeekYearHelper.call(this,\r\n                input, this.isoWeek(), this.isoWeekday(), 1, 4);\r\n    }\r\n\r\n    function getISOWeeksInYear () {\r\n        return weeksInYear(this.year(), 1, 4);\r\n    }\r\n\r\n    function getWeeksInYear () {\r\n        var weekInfo = this.localeData()._week;\r\n        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\r\n    }\r\n\r\n    function getSetWeekYearHelper(input, week, weekday, dow, doy) {\r\n        var weeksTarget;\r\n        if (input == null) {\r\n            return weekOfYear(this, dow, doy).year;\r\n        } else {\r\n            weeksTarget = weeksInYear(input, dow, doy);\r\n            if (week > weeksTarget) {\r\n                week = weeksTarget;\r\n            }\r\n            return setWeekAll.call(this, input, week, weekday, dow, doy);\r\n        }\r\n    }\r\n\r\n    function setWeekAll(weekYear, week, weekday, dow, doy) {\r\n        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\r\n            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\r\n\r\n        this.year(date.getUTCFullYear());\r\n        this.month(date.getUTCMonth());\r\n        this.date(date.getUTCDate());\r\n        return this;\r\n    }\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('Q', 0, 'Qo', 'quarter');\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('quarter', 'Q');\r\n\r\n    // PRIORITY\r\n\r\n    addUnitPriority('quarter', 7);\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('Q', match1);\r\n    addParseToken('Q', function (input, array) {\r\n        array[MONTH] = (toInt(input) - 1) * 3;\r\n    });\r\n\r\n    // MOMENTS\r\n\r\n    function getSetQuarter (input) {\r\n        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\r\n    }\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('D', ['DD', 2], 'Do', 'date');\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('date', 'D');\r\n\r\n    // PRIORITY\r\n    addUnitPriority('date', 9);\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('D',  match1to2);\r\n    addRegexToken('DD', match1to2, match2);\r\n    addRegexToken('Do', function (isStrict, locale) {\r\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\r\n        return isStrict ?\r\n          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :\r\n          locale._dayOfMonthOrdinalParseLenient;\r\n    });\r\n\r\n    addParseToken(['D', 'DD'], DATE);\r\n    addParseToken('Do', function (input, array) {\r\n        array[DATE] = toInt(input.match(match1to2)[0]);\r\n    });\r\n\r\n    // MOMENTS\r\n\r\n    var getSetDayOfMonth = makeGetSet('Date', true);\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('dayOfYear', 'DDD');\r\n\r\n    // PRIORITY\r\n    addUnitPriority('dayOfYear', 4);\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('DDD',  match1to3);\r\n    addRegexToken('DDDD', match3);\r\n    addParseToken(['DDD', 'DDDD'], function (input, array, config) {\r\n        config._dayOfYear = toInt(input);\r\n    });\r\n\r\n    // HELPERS\r\n\r\n    // MOMENTS\r\n\r\n    function getSetDayOfYear (input) {\r\n        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\r\n        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');\r\n    }\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('m', ['mm', 2], 0, 'minute');\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('minute', 'm');\r\n\r\n    // PRIORITY\r\n\r\n    addUnitPriority('minute', 14);\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('m',  match1to2);\r\n    addRegexToken('mm', match1to2, match2);\r\n    addParseToken(['m', 'mm'], MINUTE);\r\n\r\n    // MOMENTS\r\n\r\n    var getSetMinute = makeGetSet('Minutes', false);\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('s', ['ss', 2], 0, 'second');\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('second', 's');\r\n\r\n    // PRIORITY\r\n\r\n    addUnitPriority('second', 15);\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('s',  match1to2);\r\n    addRegexToken('ss', match1to2, match2);\r\n    addParseToken(['s', 'ss'], SECOND);\r\n\r\n    // MOMENTS\r\n\r\n    var getSetSecond = makeGetSet('Seconds', false);\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('S', 0, 0, function () {\r\n        return ~~(this.millisecond() / 100);\r\n    });\r\n\r\n    addFormatToken(0, ['SS', 2], 0, function () {\r\n        return ~~(this.millisecond() / 10);\r\n    });\r\n\r\n    addFormatToken(0, ['SSS', 3], 0, 'millisecond');\r\n    addFormatToken(0, ['SSSS', 4], 0, function () {\r\n        return this.millisecond() * 10;\r\n    });\r\n    addFormatToken(0, ['SSSSS', 5], 0, function () {\r\n        return this.millisecond() * 100;\r\n    });\r\n    addFormatToken(0, ['SSSSSS', 6], 0, function () {\r\n        return this.millisecond() * 1000;\r\n    });\r\n    addFormatToken(0, ['SSSSSSS', 7], 0, function () {\r\n        return this.millisecond() * 10000;\r\n    });\r\n    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {\r\n        return this.millisecond() * 100000;\r\n    });\r\n    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\r\n        return this.millisecond() * 1000000;\r\n    });\r\n\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('millisecond', 'ms');\r\n\r\n    // PRIORITY\r\n\r\n    addUnitPriority('millisecond', 16);\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('S',    match1to3, match1);\r\n    addRegexToken('SS',   match1to3, match2);\r\n    addRegexToken('SSS',  match1to3, match3);\r\n\r\n    var token;\r\n    for (token = 'SSSS'; token.length <= 9; token += 'S') {\r\n        addRegexToken(token, matchUnsigned);\r\n    }\r\n\r\n    function parseMs(input, array) {\r\n        array[MILLISECOND] = toInt(('0.' + input) * 1000);\r\n    }\r\n\r\n    for (token = 'S'; token.length <= 9; token += 'S') {\r\n        addParseToken(token, parseMs);\r\n    }\r\n    // MOMENTS\r\n\r\n    var getSetMillisecond = makeGetSet('Milliseconds', false);\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('z',  0, 0, 'zoneAbbr');\r\n    addFormatToken('zz', 0, 0, 'zoneName');\r\n\r\n    // MOMENTS\r\n\r\n    function getZoneAbbr () {\r\n        return this._isUTC ? 'UTC' : '';\r\n    }\r\n\r\n    function getZoneName () {\r\n        return this._isUTC ? 'Coordinated Universal Time' : '';\r\n    }\r\n\r\n    var proto = Moment.prototype;\r\n\r\n    proto.add               = add;\r\n    proto.calendar          = calendar$1;\r\n    proto.clone             = clone;\r\n    proto.diff              = diff;\r\n    proto.endOf             = endOf;\r\n    proto.format            = format;\r\n    proto.from              = from;\r\n    proto.fromNow           = fromNow;\r\n    proto.to                = to;\r\n    proto.toNow             = toNow;\r\n    proto.get               = stringGet;\r\n    proto.invalidAt         = invalidAt;\r\n    proto.isAfter           = isAfter;\r\n    proto.isBefore          = isBefore;\r\n    proto.isBetween         = isBetween;\r\n    proto.isSame            = isSame;\r\n    proto.isSameOrAfter     = isSameOrAfter;\r\n    proto.isSameOrBefore    = isSameOrBefore;\r\n    proto.isValid           = isValid$2;\r\n    proto.lang              = lang;\r\n    proto.locale            = locale;\r\n    proto.localeData        = localeData;\r\n    proto.max               = prototypeMax;\r\n    proto.min               = prototypeMin;\r\n    proto.parsingFlags      = parsingFlags;\r\n    proto.set               = stringSet;\r\n    proto.startOf           = startOf;\r\n    proto.subtract          = subtract;\r\n    proto.toArray           = toArray;\r\n    proto.toObject          = toObject;\r\n    proto.toDate            = toDate;\r\n    proto.toISOString       = toISOString;\r\n    proto.inspect           = inspect;\r\n    proto.toJSON            = toJSON;\r\n    proto.toString          = toString;\r\n    proto.unix              = unix;\r\n    proto.valueOf           = valueOf;\r\n    proto.creationData      = creationData;\r\n    proto.year       = getSetYear;\r\n    proto.isLeapYear = getIsLeapYear;\r\n    proto.weekYear    = getSetWeekYear;\r\n    proto.isoWeekYear = getSetISOWeekYear;\r\n    proto.quarter = proto.quarters = getSetQuarter;\r\n    proto.month       = getSetMonth;\r\n    proto.daysInMonth = getDaysInMonth;\r\n    proto.week           = proto.weeks        = getSetWeek;\r\n    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;\r\n    proto.weeksInYear    = getWeeksInYear;\r\n    proto.isoWeeksInYear = getISOWeeksInYear;\r\n    proto.date       = getSetDayOfMonth;\r\n    proto.day        = proto.days             = getSetDayOfWeek;\r\n    proto.weekday    = getSetLocaleDayOfWeek;\r\n    proto.isoWeekday = getSetISODayOfWeek;\r\n    proto.dayOfYear  = getSetDayOfYear;\r\n    proto.hour = proto.hours = getSetHour;\r\n    proto.minute = proto.minutes = getSetMinute;\r\n    proto.second = proto.seconds = getSetSecond;\r\n    proto.millisecond = proto.milliseconds = getSetMillisecond;\r\n    proto.utcOffset            = getSetOffset;\r\n    proto.utc                  = setOffsetToUTC;\r\n    proto.local                = setOffsetToLocal;\r\n    proto.parseZone            = setOffsetToParsedOffset;\r\n    proto.hasAlignedHourOffset = hasAlignedHourOffset;\r\n    proto.isDST                = isDaylightSavingTime;\r\n    proto.isLocal              = isLocal;\r\n    proto.isUtcOffset          = isUtcOffset;\r\n    proto.isUtc                = isUtc;\r\n    proto.isUTC                = isUtc;\r\n    proto.zoneAbbr = getZoneAbbr;\r\n    proto.zoneName = getZoneName;\r\n    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);\r\n    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);\r\n    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);\r\n    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);\r\n    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);\r\n\r\n    function createUnix (input) {\r\n        return createLocal(input * 1000);\r\n    }\r\n\r\n    function createInZone () {\r\n        return createLocal.apply(null, arguments).parseZone();\r\n    }\r\n\r\n    function preParsePostFormat (string) {\r\n        return string;\r\n    }\r\n\r\n    var proto$1 = Locale.prototype;\r\n\r\n    proto$1.calendar        = calendar;\r\n    proto$1.longDateFormat  = longDateFormat;\r\n    proto$1.invalidDate     = invalidDate;\r\n    proto$1.ordinal         = ordinal;\r\n    proto$1.preparse        = preParsePostFormat;\r\n    proto$1.postformat      = preParsePostFormat;\r\n    proto$1.relativeTime    = relativeTime;\r\n    proto$1.pastFuture      = pastFuture;\r\n    proto$1.set             = set;\r\n\r\n    proto$1.months            =        localeMonths;\r\n    proto$1.monthsShort       =        localeMonthsShort;\r\n    proto$1.monthsParse       =        localeMonthsParse;\r\n    proto$1.monthsRegex       = monthsRegex;\r\n    proto$1.monthsShortRegex  = monthsShortRegex;\r\n    proto$1.week = localeWeek;\r\n    proto$1.firstDayOfYear = localeFirstDayOfYear;\r\n    proto$1.firstDayOfWeek = localeFirstDayOfWeek;\r\n\r\n    proto$1.weekdays       =        localeWeekdays;\r\n    proto$1.weekdaysMin    =        localeWeekdaysMin;\r\n    proto$1.weekdaysShort  =        localeWeekdaysShort;\r\n    proto$1.weekdaysParse  =        localeWeekdaysParse;\r\n\r\n    proto$1.weekdaysRegex       =        weekdaysRegex;\r\n    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;\r\n    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;\r\n\r\n    proto$1.isPM = localeIsPM;\r\n    proto$1.meridiem = localeMeridiem;\r\n\r\n    function get$1 (format, index, field, setter) {\r\n        var locale = getLocale();\r\n        var utc = createUTC().set(setter, index);\r\n        return locale[field](utc, format);\r\n    }\r\n\r\n    function listMonthsImpl (format, index, field) {\r\n        if (isNumber(format)) {\r\n            index = format;\r\n            format = undefined;\r\n        }\r\n\r\n        format = format || '';\r\n\r\n        if (index != null) {\r\n            return get$1(format, index, field, 'month');\r\n        }\r\n\r\n        var i;\r\n        var out = [];\r\n        for (i = 0; i < 12; i++) {\r\n            out[i] = get$1(format, i, field, 'month');\r\n        }\r\n        return out;\r\n    }\r\n\r\n    // ()\r\n    // (5)\r\n    // (fmt, 5)\r\n    // (fmt)\r\n    // (true)\r\n    // (true, 5)\r\n    // (true, fmt, 5)\r\n    // (true, fmt)\r\n    function listWeekdaysImpl (localeSorted, format, index, field) {\r\n        if (typeof localeSorted === 'boolean') {\r\n            if (isNumber(format)) {\r\n                index = format;\r\n                format = undefined;\r\n            }\r\n\r\n            format = format || '';\r\n        } else {\r\n            format = localeSorted;\r\n            index = format;\r\n            localeSorted = false;\r\n\r\n            if (isNumber(format)) {\r\n                index = format;\r\n                format = undefined;\r\n            }\r\n\r\n            format = format || '';\r\n        }\r\n\r\n        var locale = getLocale(),\r\n            shift = localeSorted ? locale._week.dow : 0;\r\n\r\n        if (index != null) {\r\n            return get$1(format, (index + shift) % 7, field, 'day');\r\n        }\r\n\r\n        var i;\r\n        var out = [];\r\n        for (i = 0; i < 7; i++) {\r\n            out[i] = get$1(format, (i + shift) % 7, field, 'day');\r\n        }\r\n        return out;\r\n    }\r\n\r\n    function listMonths (format, index) {\r\n        return listMonthsImpl(format, index, 'months');\r\n    }\r\n\r\n    function listMonthsShort (format, index) {\r\n        return listMonthsImpl(format, index, 'monthsShort');\r\n    }\r\n\r\n    function listWeekdays (localeSorted, format, index) {\r\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\r\n    }\r\n\r\n    function listWeekdaysShort (localeSorted, format, index) {\r\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\r\n    }\r\n\r\n    function listWeekdaysMin (localeSorted, format, index) {\r\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\r\n    }\r\n\r\n    getSetGlobalLocale('en', {\r\n        dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\r\n        ordinal : function (number) {\r\n            var b = number % 10,\r\n                output = (toInt(number % 100 / 10) === 1) ? 'th' :\r\n                (b === 1) ? 'st' :\r\n                (b === 2) ? 'nd' :\r\n                (b === 3) ? 'rd' : 'th';\r\n            return number + output;\r\n        }\r\n    });\r\n\r\n    // Side effect imports\r\n\r\n    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);\r\n    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);\r\n\r\n    var mathAbs = Math.abs;\r\n\r\n    function abs () {\r\n        var data           = this._data;\r\n\r\n        this._milliseconds = mathAbs(this._milliseconds);\r\n        this._days         = mathAbs(this._days);\r\n        this._months       = mathAbs(this._months);\r\n\r\n        data.milliseconds  = mathAbs(data.milliseconds);\r\n        data.seconds       = mathAbs(data.seconds);\r\n        data.minutes       = mathAbs(data.minutes);\r\n        data.hours         = mathAbs(data.hours);\r\n        data.months        = mathAbs(data.months);\r\n        data.years         = mathAbs(data.years);\r\n\r\n        return this;\r\n    }\r\n\r\n    function addSubtract$1 (duration, input, value, direction) {\r\n        var other = createDuration(input, value);\r\n\r\n        duration._milliseconds += direction * other._milliseconds;\r\n        duration._days         += direction * other._days;\r\n        duration._months       += direction * other._months;\r\n\r\n        return duration._bubble();\r\n    }\r\n\r\n    // supports only 2.0-style add(1, 's') or add(duration)\r\n    function add$1 (input, value) {\r\n        return addSubtract$1(this, input, value, 1);\r\n    }\r\n\r\n    // supports only 2.0-style subtract(1, 's') or subtract(duration)\r\n    function subtract$1 (input, value) {\r\n        return addSubtract$1(this, input, value, -1);\r\n    }\r\n\r\n    function absCeil (number) {\r\n        if (number < 0) {\r\n            return Math.floor(number);\r\n        } else {\r\n            return Math.ceil(number);\r\n        }\r\n    }\r\n\r\n    function bubble () {\r\n        var milliseconds = this._milliseconds;\r\n        var days         = this._days;\r\n        var months       = this._months;\r\n        var data         = this._data;\r\n        var seconds, minutes, hours, years, monthsFromDays;\r\n\r\n        // if we have a mix of positive and negative values, bubble down first\r\n        // check: https://github.com/moment/moment/issues/2166\r\n        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||\r\n                (milliseconds <= 0 && days <= 0 && months <= 0))) {\r\n            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\r\n            days = 0;\r\n            months = 0;\r\n        }\r\n\r\n        // The following code bubbles up values, see the tests for\r\n        // examples of what that means.\r\n        data.milliseconds = milliseconds % 1000;\r\n\r\n        seconds           = absFloor(milliseconds / 1000);\r\n        data.seconds      = seconds % 60;\r\n\r\n        minutes           = absFloor(seconds / 60);\r\n        data.minutes      = minutes % 60;\r\n\r\n        hours             = absFloor(minutes / 60);\r\n        data.hours        = hours % 24;\r\n\r\n        days += absFloor(hours / 24);\r\n\r\n        // convert days to months\r\n        monthsFromDays = absFloor(daysToMonths(days));\r\n        months += monthsFromDays;\r\n        days -= absCeil(monthsToDays(monthsFromDays));\r\n\r\n        // 12 months -> 1 year\r\n        years = absFloor(months / 12);\r\n        months %= 12;\r\n\r\n        data.days   = days;\r\n        data.months = months;\r\n        data.years  = years;\r\n\r\n        return this;\r\n    }\r\n\r\n    function daysToMonths (days) {\r\n        // 400 years have 146097 days (taking into account leap year rules)\r\n        // 400 years have 12 months === 4800\r\n        return days * 4800 / 146097;\r\n    }\r\n\r\n    function monthsToDays (months) {\r\n        // the reverse of daysToMonths\r\n        return months * 146097 / 4800;\r\n    }\r\n\r\n    function as (units) {\r\n        if (!this.isValid()) {\r\n            return NaN;\r\n        }\r\n        var days;\r\n        var months;\r\n        var milliseconds = this._milliseconds;\r\n\r\n        units = normalizeUnits(units);\r\n\r\n        if (units === 'month' || units === 'year') {\r\n            days   = this._days   + milliseconds / 864e5;\r\n            months = this._months + daysToMonths(days);\r\n            return units === 'month' ? months : months / 12;\r\n        } else {\r\n            // handle milliseconds separately because of floating point math errors (issue #1867)\r\n            days = this._days + Math.round(monthsToDays(this._months));\r\n            switch (units) {\r\n                case 'week'   : return days / 7     + milliseconds / 6048e5;\r\n                case 'day'    : return days         + milliseconds / 864e5;\r\n                case 'hour'   : return days * 24    + milliseconds / 36e5;\r\n                case 'minute' : return days * 1440  + milliseconds / 6e4;\r\n                case 'second' : return days * 86400 + milliseconds / 1000;\r\n                // Math.floor prevents floating point math errors here\r\n                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;\r\n                default: throw new Error('Unknown unit ' + units);\r\n            }\r\n        }\r\n    }\r\n\r\n    // TODO: Use this.as('ms')?\r\n    function valueOf$1 () {\r\n        if (!this.isValid()) {\r\n            return NaN;\r\n        }\r\n        return (\r\n            this._milliseconds +\r\n            this._days * 864e5 +\r\n            (this._months % 12) * 2592e6 +\r\n            toInt(this._months / 12) * 31536e6\r\n        );\r\n    }\r\n\r\n    function makeAs (alias) {\r\n        return function () {\r\n            return this.as(alias);\r\n        };\r\n    }\r\n\r\n    var asMilliseconds = makeAs('ms');\r\n    var asSeconds      = makeAs('s');\r\n    var asMinutes      = makeAs('m');\r\n    var asHours        = makeAs('h');\r\n    var asDays         = makeAs('d');\r\n    var asWeeks        = makeAs('w');\r\n    var asMonths       = makeAs('M');\r\n    var asYears        = makeAs('y');\r\n\r\n    function clone$1 () {\r\n        return createDuration(this);\r\n    }\r\n\r\n    function get$2 (units) {\r\n        units = normalizeUnits(units);\r\n        return this.isValid() ? this[units + 's']() : NaN;\r\n    }\r\n\r\n    function makeGetter(name) {\r\n        return function () {\r\n            return this.isValid() ? this._data[name] : NaN;\r\n        };\r\n    }\r\n\r\n    var milliseconds = makeGetter('milliseconds');\r\n    var seconds      = makeGetter('seconds');\r\n    var minutes      = makeGetter('minutes');\r\n    var hours        = makeGetter('hours');\r\n    var days         = makeGetter('days');\r\n    var months       = makeGetter('months');\r\n    var years        = makeGetter('years');\r\n\r\n    function weeks () {\r\n        return absFloor(this.days() / 7);\r\n    }\r\n\r\n    var round = Math.round;\r\n    var thresholds = {\r\n        ss: 44,         // a few seconds to seconds\r\n        s : 45,         // seconds to minute\r\n        m : 45,         // minutes to hour\r\n        h : 22,         // hours to day\r\n        d : 26,         // days to month\r\n        M : 11          // months to year\r\n    };\r\n\r\n    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\r\n    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\r\n        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\r\n    }\r\n\r\n    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {\r\n        var duration = createDuration(posNegDuration).abs();\r\n        var seconds  = round(duration.as('s'));\r\n        var minutes  = round(duration.as('m'));\r\n        var hours    = round(duration.as('h'));\r\n        var days     = round(duration.as('d'));\r\n        var months   = round(duration.as('M'));\r\n        var years    = round(duration.as('y'));\r\n\r\n        var a = seconds <= thresholds.ss && ['s', seconds]  ||\r\n                seconds < thresholds.s   && ['ss', seconds] ||\r\n                minutes <= 1             && ['m']           ||\r\n                minutes < thresholds.m   && ['mm', minutes] ||\r\n                hours   <= 1             && ['h']           ||\r\n                hours   < thresholds.h   && ['hh', hours]   ||\r\n                days    <= 1             && ['d']           ||\r\n                days    < thresholds.d   && ['dd', days]    ||\r\n                months  <= 1             && ['M']           ||\r\n                months  < thresholds.M   && ['MM', months]  ||\r\n                years   <= 1             && ['y']           || ['yy', years];\r\n\r\n        a[2] = withoutSuffix;\r\n        a[3] = +posNegDuration > 0;\r\n        a[4] = locale;\r\n        return substituteTimeAgo.apply(null, a);\r\n    }\r\n\r\n    // This function allows you to set the rounding function for relative time strings\r\n    function getSetRelativeTimeRounding (roundingFunction) {\r\n        if (roundingFunction === undefined) {\r\n            return round;\r\n        }\r\n        if (typeof(roundingFunction) === 'function') {\r\n            round = roundingFunction;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // This function allows you to set a threshold for relative time strings\r\n    function getSetRelativeTimeThreshold (threshold, limit) {\r\n        if (thresholds[threshold] === undefined) {\r\n            return false;\r\n        }\r\n        if (limit === undefined) {\r\n            return thresholds[threshold];\r\n        }\r\n        thresholds[threshold] = limit;\r\n        if (threshold === 's') {\r\n            thresholds.ss = limit - 1;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function humanize (withSuffix) {\r\n        if (!this.isValid()) {\r\n            return this.localeData().invalidDate();\r\n        }\r\n\r\n        var locale = this.localeData();\r\n        var output = relativeTime$1(this, !withSuffix, locale);\r\n\r\n        if (withSuffix) {\r\n            output = locale.pastFuture(+this, output);\r\n        }\r\n\r\n        return locale.postformat(output);\r\n    }\r\n\r\n    var abs$1 = Math.abs;\r\n\r\n    function sign(x) {\r\n        return ((x > 0) - (x < 0)) || +x;\r\n    }\r\n\r\n    function toISOString$1() {\r\n        // for ISO strings we do not use the normal bubbling rules:\r\n        //  * milliseconds bubble up until they become hours\r\n        //  * days do not bubble at all\r\n        //  * months bubble up until they become years\r\n        // This is because there is no context-free conversion between hours and days\r\n        // (think of clock changes)\r\n        // and also not between days and months (28-31 days per month)\r\n        if (!this.isValid()) {\r\n            return this.localeData().invalidDate();\r\n        }\r\n\r\n        var seconds = abs$1(this._milliseconds) / 1000;\r\n        var days         = abs$1(this._days);\r\n        var months       = abs$1(this._months);\r\n        var minutes, hours, years;\r\n\r\n        // 3600 seconds -> 60 minutes -> 1 hour\r\n        minutes           = absFloor(seconds / 60);\r\n        hours             = absFloor(minutes / 60);\r\n        seconds %= 60;\r\n        minutes %= 60;\r\n\r\n        // 12 months -> 1 year\r\n        years  = absFloor(months / 12);\r\n        months %= 12;\r\n\r\n\r\n        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\r\n        var Y = years;\r\n        var M = months;\r\n        var D = days;\r\n        var h = hours;\r\n        var m = minutes;\r\n        var s = seconds ? seconds.toFixed(3).replace(/\\.?0+$/, '') : '';\r\n        var total = this.asSeconds();\r\n\r\n        if (!total) {\r\n            // this is the same as C#'s (Noda) and python (isodate)...\r\n            // but not other JS (goog.date)\r\n            return 'P0D';\r\n        }\r\n\r\n        var totalSign = total < 0 ? '-' : '';\r\n        var ymSign = sign(this._months) !== sign(total) ? '-' : '';\r\n        var daysSign = sign(this._days) !== sign(total) ? '-' : '';\r\n        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';\r\n\r\n        return totalSign + 'P' +\r\n            (Y ? ymSign + Y + 'Y' : '') +\r\n            (M ? ymSign + M + 'M' : '') +\r\n            (D ? daysSign + D + 'D' : '') +\r\n            ((h || m || s) ? 'T' : '') +\r\n            (h ? hmsSign + h + 'H' : '') +\r\n            (m ? hmsSign + m + 'M' : '') +\r\n            (s ? hmsSign + s + 'S' : '');\r\n    }\r\n\r\n    var proto$2 = Duration.prototype;\r\n\r\n    proto$2.isValid        = isValid$1;\r\n    proto$2.abs            = abs;\r\n    proto$2.add            = add$1;\r\n    proto$2.subtract       = subtract$1;\r\n    proto$2.as             = as;\r\n    proto$2.asMilliseconds = asMilliseconds;\r\n    proto$2.asSeconds      = asSeconds;\r\n    proto$2.asMinutes      = asMinutes;\r\n    proto$2.asHours        = asHours;\r\n    proto$2.asDays         = asDays;\r\n    proto$2.asWeeks        = asWeeks;\r\n    proto$2.asMonths       = asMonths;\r\n    proto$2.asYears        = asYears;\r\n    proto$2.valueOf        = valueOf$1;\r\n    proto$2._bubble        = bubble;\r\n    proto$2.clone          = clone$1;\r\n    proto$2.get            = get$2;\r\n    proto$2.milliseconds   = milliseconds;\r\n    proto$2.seconds        = seconds;\r\n    proto$2.minutes        = minutes;\r\n    proto$2.hours          = hours;\r\n    proto$2.days           = days;\r\n    proto$2.weeks          = weeks;\r\n    proto$2.months         = months;\r\n    proto$2.years          = years;\r\n    proto$2.humanize       = humanize;\r\n    proto$2.toISOString    = toISOString$1;\r\n    proto$2.toString       = toISOString$1;\r\n    proto$2.toJSON         = toISOString$1;\r\n    proto$2.locale         = locale;\r\n    proto$2.localeData     = localeData;\r\n\r\n    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);\r\n    proto$2.lang = lang;\r\n\r\n    // Side effect imports\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('X', 0, 0, 'unix');\r\n    addFormatToken('x', 0, 0, 'valueOf');\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('x', matchSigned);\r\n    addRegexToken('X', matchTimestamp);\r\n    addParseToken('X', function (input, array, config) {\r\n        config._d = new Date(parseFloat(input, 10) * 1000);\r\n    });\r\n    addParseToken('x', function (input, array, config) {\r\n        config._d = new Date(toInt(input));\r\n    });\r\n\r\n    // Side effect imports\r\n\r\n\r\n    hooks.version = '2.22.2';\r\n\r\n    setHookCallback(createLocal);\r\n\r\n    hooks.fn                    = proto;\r\n    hooks.min                   = min;\r\n    hooks.max                   = max;\r\n    hooks.now                   = now;\r\n    hooks.utc                   = createUTC;\r\n    hooks.unix                  = createUnix;\r\n    hooks.months                = listMonths;\r\n    hooks.isDate                = isDate;\r\n    hooks.locale                = getSetGlobalLocale;\r\n    hooks.invalid               = createInvalid;\r\n    hooks.duration              = createDuration;\r\n    hooks.isMoment              = isMoment;\r\n    hooks.weekdays              = listWeekdays;\r\n    hooks.parseZone             = createInZone;\r\n    hooks.localeData            = getLocale;\r\n    hooks.isDuration            = isDuration;\r\n    hooks.monthsShort           = listMonthsShort;\r\n    hooks.weekdaysMin           = listWeekdaysMin;\r\n    hooks.defineLocale          = defineLocale;\r\n    hooks.updateLocale          = updateLocale;\r\n    hooks.locales               = listLocales;\r\n    hooks.weekdaysShort         = listWeekdaysShort;\r\n    hooks.normalizeUnits        = normalizeUnits;\r\n    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;\r\n    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\r\n    hooks.calendarFormat        = getCalendarFormat;\r\n    hooks.prototype             = proto;\r\n\r\n    // currently HTML5 input type only supports 24-hour formats\r\n    hooks.HTML5_FMT = {\r\n        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type=\"datetime-local\" />\r\n        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type=\"datetime-local\" step=\"1\" />\r\n        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type=\"datetime-local\" step=\"0.001\" />\r\n        DATE: 'YYYY-MM-DD',                             // <input type=\"date\" />\r\n        TIME: 'HH:mm',                                  // <input type=\"time\" />\r\n        TIME_SECONDS: 'HH:mm:ss',                       // <input type=\"time\" step=\"1\" />\r\n        TIME_MS: 'HH:mm:ss.SSS',                        // <input type=\"time\" step=\"0.001\" />\r\n        WEEK: 'YYYY-[W]WW',                             // <input type=\"week\" />\r\n        MONTH: 'YYYY-MM'                                // <input type=\"month\" />\r\n    };\r\n\r\n    return hooks;\r\n\r\n})));\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvY3J5cHRvbm90ZV91dGlscy9tb21lbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvY3J5cHRvbm90ZV91dGlscy9tb21lbnQuanM/ZjhkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcclxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XHJcbiAgICBnbG9iYWwubW9tZW50ID0gZmFjdG9yeSgpXHJcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIHZhciBob29rQ2FsbGJhY2s7XHJcblxyXG4gICAgZnVuY3Rpb24gaG9va3MgKCkge1xyXG4gICAgICAgIHJldHVybiBob29rQ2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGlzIGlzIGRvbmUgdG8gcmVnaXN0ZXIgdGhlIG1ldGhvZCBjYWxsZWQgd2l0aCBtb21lbnQoKVxyXG4gICAgLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXHJcbiAgICBmdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2sgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaG9va0NhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcclxuICAgICAgICAvLyBJRTggd2lsbCB0cmVhdCB1bmRlZmluZWQgYW5kIG51bGwgYXMgb2JqZWN0IGlmIGl0IHdhc24ndCBmb3JcclxuICAgICAgICAvLyBpbnB1dCAhPSBudWxsXHJcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcclxuICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCA9PT0gMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGs7XHJcbiAgICAgICAgICAgIGZvciAoayBpbiBvYmopIHtcclxuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBOdW1iZXJdJztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBEYXRlIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtYXAoYXJyLCBmbikge1xyXG4gICAgICAgIHZhciByZXMgPSBbXSwgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHJlcy5wdXNoKGZuKGFycltpXSwgaSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcclxuICAgICAgICBmb3IgKHZhciBpIGluIGIpIHtcclxuICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcclxuICAgICAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xyXG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcclxuICAgICAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGE7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZWZhdWx0UGFyc2luZ0ZsYWdzKCkge1xyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBlbXB0eSAgICAgICAgICAgOiBmYWxzZSxcclxuICAgICAgICAgICAgdW51c2VkVG9rZW5zICAgIDogW10sXHJcbiAgICAgICAgICAgIHVudXNlZElucHV0ICAgICA6IFtdLFxyXG4gICAgICAgICAgICBvdmVyZmxvdyAgICAgICAgOiAtMixcclxuICAgICAgICAgICAgY2hhcnNMZWZ0T3ZlciAgIDogMCxcclxuICAgICAgICAgICAgbnVsbElucHV0ICAgICAgIDogZmFsc2UsXHJcbiAgICAgICAgICAgIGludmFsaWRNb250aCAgICA6IG51bGwsXHJcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQgICA6IGZhbHNlLFxyXG4gICAgICAgICAgICB1c2VySW52YWxpZGF0ZWQgOiBmYWxzZSxcclxuICAgICAgICAgICAgaXNvICAgICAgICAgICAgIDogZmFsc2UsXHJcbiAgICAgICAgICAgIHBhcnNlZERhdGVQYXJ0cyA6IFtdLFxyXG4gICAgICAgICAgICBtZXJpZGllbSAgICAgICAgOiBudWxsLFxyXG4gICAgICAgICAgICByZmMyODIyICAgICAgICAgOiBmYWxzZSxcclxuICAgICAgICAgICAgd2Vla2RheU1pc21hdGNoIDogZmFsc2VcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFBhcnNpbmdGbGFncyhtKSB7XHJcbiAgICAgICAgaWYgKG0uX3BmID09IG51bGwpIHtcclxuICAgICAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtLl9wZjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc29tZTtcclxuICAgIGlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xyXG4gICAgICAgIHNvbWUgPSBBcnJheS5wcm90b3R5cGUuc29tZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcclxuICAgICAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XHJcbiAgICAgICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChpIGluIHQgJiYgZnVuLmNhbGwodGhpcywgdFtpXSwgaSwgdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNWYWxpZChtKSB7XHJcbiAgICAgICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSk7XHJcbiAgICAgICAgICAgIHZhciBwYXJzZWRQYXJ0cyA9IHNvbWUuY2FsbChmbGFncy5wYXJzZWREYXRlUGFydHMsIGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIGlzTm93VmFsaWQgPSAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXHJcbiAgICAgICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcclxuICAgICAgICAgICAgICAgICFmbGFncy5lbXB0eSAmJlxyXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxyXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXHJcbiAgICAgICAgICAgICAgICAhZmxhZ3Mud2Vla2RheU1pc21hdGNoICYmXHJcbiAgICAgICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXHJcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxyXG4gICAgICAgICAgICAgICAgIWZsYWdzLnVzZXJJbnZhbGlkYXRlZCAmJlxyXG4gICAgICAgICAgICAgICAgKCFmbGFncy5tZXJpZGllbSB8fCAoZmxhZ3MubWVyaWRpZW0gJiYgcGFyc2VkUGFydHMpKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChtLl9zdHJpY3QpIHtcclxuICAgICAgICAgICAgICAgIGlzTm93VmFsaWQgPSBpc05vd1ZhbGlkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDAgJiZcclxuICAgICAgICAgICAgICAgICAgICBmbGFncy5iaWdIb3VyID09PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4gPT0gbnVsbCB8fCAhT2JqZWN0LmlzRnJvemVuKG0pKSB7XHJcbiAgICAgICAgICAgICAgICBtLl9pc1ZhbGlkID0gaXNOb3dWYWxpZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc05vd1ZhbGlkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQgKGZsYWdzKSB7XHJcbiAgICAgICAgdmFyIG0gPSBjcmVhdGVVVEMoTmFOKTtcclxuICAgICAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBtO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBsdWdpbnMgdGhhdCBhZGQgcHJvcGVydGllcyBzaG91bGQgYWxzbyBhZGQgdGhlIGtleSBoZXJlIChudWxsIHZhbHVlKSxcclxuICAgIC8vIHNvIHdlIGNhbiBwcm9wZXJseSBjbG9uZSBvdXJzZWx2ZXMuXHJcbiAgICB2YXIgbW9tZW50UHJvcGVydGllcyA9IGhvb2tzLm1vbWVudFByb3BlcnRpZXMgPSBbXTtcclxuXHJcbiAgICBmdW5jdGlvbiBjb3B5Q29uZmlnKHRvLCBmcm9tKSB7XHJcbiAgICAgICAgdmFyIGksIHByb3AsIHZhbDtcclxuXHJcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc0FNb21lbnRPYmplY3QpKSB7XHJcbiAgICAgICAgICAgIHRvLl9pc0FNb21lbnRPYmplY3QgPSBmcm9tLl9pc0FNb21lbnRPYmplY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faSkpIHtcclxuICAgICAgICAgICAgdG8uX2kgPSBmcm9tLl9pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2YpKSB7XHJcbiAgICAgICAgICAgIHRvLl9mID0gZnJvbS5fZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sKSkge1xyXG4gICAgICAgICAgICB0by5fbCA9IGZyb20uX2w7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fc3RyaWN0KSkge1xyXG4gICAgICAgICAgICB0by5fc3RyaWN0ID0gZnJvbS5fc3RyaWN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3R6bSkpIHtcclxuICAgICAgICAgICAgdG8uX3R6bSA9IGZyb20uX3R6bTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc1VUQykpIHtcclxuICAgICAgICAgICAgdG8uX2lzVVRDID0gZnJvbS5faXNVVEM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fb2Zmc2V0KSkge1xyXG4gICAgICAgICAgICB0by5fb2Zmc2V0ID0gZnJvbS5fb2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3BmKSkge1xyXG4gICAgICAgICAgICB0by5fcGYgPSBnZXRQYXJzaW5nRmxhZ3MoZnJvbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbG9jYWxlKSkge1xyXG4gICAgICAgICAgICB0by5fbG9jYWxlID0gZnJvbS5fbG9jYWxlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1vbWVudFByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbW9tZW50UHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcHJvcCA9IG1vbWVudFByb3BlcnRpZXNbaV07XHJcbiAgICAgICAgICAgICAgICB2YWwgPSBmcm9tW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9bcHJvcF0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0bztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xyXG5cclxuICAgIC8vIE1vbWVudCBwcm90b3R5cGUgb2JqZWN0XHJcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XHJcbiAgICAgICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xyXG4gICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShjb25maWcuX2QgIT0gbnVsbCA/IGNvbmZpZy5fZC5nZXRUaW1lKCkgOiBOYU4pO1xyXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKE5hTik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcclxuICAgICAgICAvLyBvYmplY3RzLlxyXG4gICAgICAgIGlmICh1cGRhdGVJblByb2dyZXNzID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcclxuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMpO1xyXG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcclxuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgTW9tZW50IHx8IChvYmogIT0gbnVsbCAmJiBvYmouX2lzQU1vbWVudE9iamVjdCAhPSBudWxsKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhYnNGbG9vciAobnVtYmVyKSB7XHJcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcclxuICAgICAgICAgICAgLy8gLTAgLT4gMFxyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcikgfHwgMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0b0ludChhcmd1bWVudEZvckNvZXJjaW9uKSB7XHJcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcclxuICAgICAgICAgICAgdmFsdWUgPSAwO1xyXG5cclxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcclxuICAgIGZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYXJyYXkxLCBhcnJheTIsIGRvbnRDb252ZXJ0KSB7XHJcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxyXG4gICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxyXG4gICAgICAgICAgICBkaWZmcyA9IDAsXHJcbiAgICAgICAgICAgIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICgoZG9udENvbnZlcnQgJiYgYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHx8XHJcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpKSB7XHJcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcclxuICAgICAgICBpZiAoaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxyXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xyXG4gICAgICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xyXG5cclxuICAgICAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSAnXFxuWycgKyBpICsgJ10gJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGFyZ3VtZW50c1swXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9IGtleSArICc6ICcgKyBhcmd1bWVudHNbMF1ba2V5XSArICcsICc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDAsIC0yKTsgLy8gUmVtb3ZlIHRyYWlsaW5nIGNvbW1hIGFuZCBzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB3YXJuKG1zZyArICdcXG5Bcmd1bWVudHM6ICcgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKS5qb2luKCcnKSArICdcXG4nICsgKG5ldyBFcnJvcigpKS5zdGFjayk7XHJcbiAgICAgICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICB9LCBmbik7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRlcHJlY2F0aW9ucyA9IHt9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcclxuICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG5hbWUsIG1zZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZGVwcmVjYXRpb25zW25hbWVdKSB7XHJcbiAgICAgICAgICAgIHdhcm4obXNnKTtcclxuICAgICAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XHJcbiAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgPSBudWxsO1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldCAoY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIHByb3AsIGk7XHJcbiAgICAgICAgZm9yIChpIGluIGNvbmZpZykge1xyXG4gICAgICAgICAgICBwcm9wID0gY29uZmlnW2ldO1xyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XHJcbiAgICAgICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXHJcbiAgICAgICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfZGF5T2ZNb250aE9yZGluYWxQYXJzZS5cclxuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXHJcbiAgICAgICAgdGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKFxyXG4gICAgICAgICAgICAodGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZS5zb3VyY2UgfHwgdGhpcy5fb3JkaW5hbFBhcnNlLnNvdXJjZSkgK1xyXG4gICAgICAgICAgICAgICAgJ3wnICsgKC9cXGR7MSwyfS8pLnNvdXJjZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcclxuICAgICAgICB2YXIgcmVzID0gZXh0ZW5kKHt9LCBwYXJlbnRDb25maWcpLCBwcm9wO1xyXG4gICAgICAgIGZvciAocHJvcCBpbiBjaGlsZENvbmZpZykge1xyXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pICYmIGlzT2JqZWN0KGNoaWxkQ29uZmlnW3Byb3BdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgY2hpbGRDb25maWdbcHJvcF0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZENvbmZpZ1twcm9wXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNbcHJvcF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChwcm9wIGluIHBhcmVudENvbmZpZykge1xyXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChwYXJlbnRDb25maWcsIHByb3ApICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIWhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApICYmXHJcbiAgICAgICAgICAgICAgICAgICAgaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGNoYW5nZXMgdG8gcHJvcGVydGllcyBkb24ndCBtb2RpZnkgcGFyZW50IGNvbmZpZ1xyXG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gZXh0ZW5kKHt9LCByZXNbcHJvcF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gTG9jYWxlKGNvbmZpZykge1xyXG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldChjb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIga2V5cztcclxuXHJcbiAgICBpZiAoT2JqZWN0LmtleXMpIHtcclxuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGtleXMgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgIHZhciBpLCByZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW1RvZGF5IGF0XSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW1llc3RlcmRheSBhdF0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyIChrZXksIG1vbSwgbm93KSB7XHJcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyW2tleV0gfHwgdGhpcy5fY2FsZW5kYXJbJ3NhbWVFbHNlJ107XHJcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KSA/IG91dHB1dC5jYWxsKG1vbSwgbm93KSA6IG91dHB1dDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xyXG4gICAgICAgIExUUyAgOiAnaDptbTpzcyBBJyxcclxuICAgICAgICBMVCAgIDogJ2g6bW0gQScsXHJcbiAgICAgICAgTCAgICA6ICdNTS9ERC9ZWVlZJyxcclxuICAgICAgICBMTCAgIDogJ01NTU0gRCwgWVlZWScsXHJcbiAgICAgICAgTExMICA6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0IChrZXkpIHtcclxuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSxcclxuICAgICAgICAgICAgZm9ybWF0VXBwZXIgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV07XHJcblxyXG4gICAgICAgIGlmIChmb3JtYXQgfHwgIWZvcm1hdFVwcGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gZm9ybWF0VXBwZXIucmVwbGFjZSgvTU1NTXxNTXxERHxkZGRkL2csIGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xyXG5cclxuICAgIGZ1bmN0aW9uIGludmFsaWREYXRlICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcclxuICAgIHZhciBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XHJcblxyXG4gICAgZnVuY3Rpb24gb3JkaW5hbCAobnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXHJcbiAgICAgICAgcGFzdCAgIDogJyVzIGFnbycsXHJcbiAgICAgICAgcyAgOiAnYSBmZXcgc2Vjb25kcycsXHJcbiAgICAgICAgc3MgOiAnJWQgc2Vjb25kcycsXHJcbiAgICAgICAgbSAgOiAnYSBtaW51dGUnLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxyXG4gICAgICAgIGggIDogJ2FuIGhvdXInLFxyXG4gICAgICAgIGhoIDogJyVkIGhvdXJzJyxcclxuICAgICAgICBkICA6ICdhIGRheScsXHJcbiAgICAgICAgZGQgOiAnJWQgZGF5cycsXHJcbiAgICAgICAgTSAgOiAnYSBtb250aCcsXHJcbiAgICAgICAgTU0gOiAnJWQgbW9udGhzJyxcclxuICAgICAgICB5ICA6ICdhIHllYXInLFxyXG4gICAgICAgIHl5IDogJyVkIHllYXJzJ1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUgKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xyXG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcclxuICAgICAgICByZXR1cm4gKGlzRnVuY3Rpb24ob3V0cHV0KSkgP1xyXG4gICAgICAgICAgICBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSA6XHJcbiAgICAgICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xyXG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbZGlmZiA+IDAgPyAnZnV0dXJlJyA6ICdwYXN0J107XHJcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZm9ybWF0KSA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGFsaWFzZXMgPSB7fTtcclxuXHJcbiAgICBmdW5jdGlvbiBhZGRVbml0QWxpYXMgKHVuaXQsIHNob3J0aGFuZCkge1xyXG4gICAgICAgIHZhciBsb3dlckNhc2UgPSB1bml0LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgdW5pdHMgPT09ICdzdHJpbmcnID8gYWxpYXNlc1t1bml0c10gfHwgYWxpYXNlc1t1bml0cy50b0xvd2VyQ2FzZSgpXSA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xyXG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcclxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXHJcbiAgICAgICAgICAgIHByb3A7XHJcblxyXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xyXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChpbnB1dE9iamVjdCwgcHJvcCkpIHtcclxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5wdXRbbm9ybWFsaXplZFByb3BdID0gaW5wdXRPYmplY3RbcHJvcF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHByaW9yaXRpZXMgPSB7fTtcclxuXHJcbiAgICBmdW5jdGlvbiBhZGRVbml0UHJpb3JpdHkodW5pdCwgcHJpb3JpdHkpIHtcclxuICAgICAgICBwcmlvcml0aWVzW3VuaXRdID0gcHJpb3JpdHk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0c09iaikge1xyXG4gICAgICAgIHZhciB1bml0cyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIHUgaW4gdW5pdHNPYmopIHtcclxuICAgICAgICAgICAgdW5pdHMucHVzaCh7dW5pdDogdSwgcHJpb3JpdHk6IHByaW9yaXRpZXNbdV19KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdW5pdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHVuaXRzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcclxuICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxyXG4gICAgICAgICAgICB6ZXJvc1RvRmlsbCA9IHRhcmdldExlbmd0aCAtIGFic051bWJlci5sZW5ndGgsXHJcbiAgICAgICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcclxuICAgICAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXHJcbiAgICAgICAgICAgIE1hdGgucG93KDEwLCBNYXRoLm1heCgwLCB6ZXJvc1RvRmlsbCkpLnRvU3RyaW5nKCkuc3Vic3RyKDEpICsgYWJzTnVtYmVyO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBmb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KFtIaF1tbShzcyk/fE1vfE1NP00/TT98RG98REREb3xERD9EP0Q/fGRkZD9kP3xkbz98d1tvfHddP3xXW298V10/fFFvP3xZWVlZWVl8WVlZWVl8WVlZWXxZWXxnZyhnZ2c/KT98R0coR0dHPyk/fGV8RXxhfEF8aGg/fEhIP3xraz98bW0/fHNzP3xTezEsOX18eHxYfHp6P3xaWj98LikvZztcclxuXHJcbiAgICB2YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcclxuXHJcbiAgICB2YXIgZm9ybWF0RnVuY3Rpb25zID0ge307XHJcblxyXG4gICAgdmFyIGZvcm1hdFRva2VuRnVuY3Rpb25zID0ge307XHJcblxyXG4gICAgLy8gdG9rZW46ICAgICdNJ1xyXG4gICAgLy8gcGFkZGVkOiAgIFsnTU0nLCAyXVxyXG4gICAgLy8gb3JkaW5hbDogICdNbydcclxuICAgIC8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxyXG4gICAgZnVuY3Rpb24gYWRkRm9ybWF0VG9rZW4gKHRva2VuLCBwYWRkZWQsIG9yZGluYWwsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIGZ1bmMgPSBjYWxsYmFjaztcclxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2FsbGJhY2tdKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b2tlbikge1xyXG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFkZGVkKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gemVyb0ZpbGwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBwYWRkZWRbMV0sIHBhZGRlZFsyXSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcmRpbmFsKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW29yZGluYWxdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcclxuICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XHJcbiAgICAgICAgdmFyIGFycmF5ID0gZm9ybWF0Lm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpLCBpLCBsZW5ndGg7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV0pIHtcclxuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGFycmF5W2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcclxuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnLCBpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dCArPSBpc0Z1bmN0aW9uKGFycmF5W2ldKSA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpIDogYXJyYXlbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxyXG4gICAgZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xyXG4gICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxvY2FsZURhdGEoKSk7XHJcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xyXG4gICAgICAgIHZhciBpID0gNTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxvY2FsRm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKTtcclxuICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGkgLT0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmb3JtYXQ7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1hdGNoMSAgICAgICAgID0gL1xcZC87ICAgICAgICAgICAgLy8gICAgICAgMCAtIDlcclxuICAgIHZhciBtYXRjaDIgICAgICAgICA9IC9cXGRcXGQvOyAgICAgICAgICAvLyAgICAgIDAwIC0gOTlcclxuICAgIHZhciBtYXRjaDMgICAgICAgICA9IC9cXGR7M30vOyAgICAgICAgIC8vICAgICAwMDAgLSA5OTlcclxuICAgIHZhciBtYXRjaDQgICAgICAgICA9IC9cXGR7NH0vOyAgICAgICAgIC8vICAgIDAwMDAgLSA5OTk5XHJcbiAgICB2YXIgbWF0Y2g2ICAgICAgICAgPSAvWystXT9cXGR7Nn0vOyAgICAvLyAtOTk5OTk5IC0gOTk5OTk5XHJcbiAgICB2YXIgbWF0Y2gxdG8yICAgICAgPSAvXFxkXFxkPy87ICAgICAgICAgLy8gICAgICAgMCAtIDk5XHJcbiAgICB2YXIgbWF0Y2gzdG80ICAgICAgPSAvXFxkXFxkXFxkXFxkPy87ICAgICAvLyAgICAgOTk5IC0gOTk5OVxyXG4gICAgdmFyIG1hdGNoNXRvNiAgICAgID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vOyAvLyAgIDk5OTk5IC0gOTk5OTk5XHJcbiAgICB2YXIgbWF0Y2gxdG8zICAgICAgPSAvXFxkezEsM30vOyAgICAgICAvLyAgICAgICAwIC0gOTk5XHJcbiAgICB2YXIgbWF0Y2gxdG80ICAgICAgPSAvXFxkezEsNH0vOyAgICAgICAvLyAgICAgICAwIC0gOTk5OVxyXG4gICAgdmFyIG1hdGNoMXRvNiAgICAgID0gL1srLV0/XFxkezEsNn0vOyAgLy8gLTk5OTk5OSAtIDk5OTk5OVxyXG5cclxuICAgIHZhciBtYXRjaFVuc2lnbmVkICA9IC9cXGQrLzsgICAgICAgICAgIC8vICAgICAgIDAgLSBpbmZcclxuICAgIHZhciBtYXRjaFNpZ25lZCAgICA9IC9bKy1dP1xcZCsvOyAgICAgIC8vICAgIC1pbmYgLSBpbmZcclxuXHJcbiAgICB2YXIgbWF0Y2hPZmZzZXQgICAgPSAvWnxbKy1dXFxkXFxkOj9cXGRcXGQvZ2k7IC8vICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxyXG4gICAgdmFyIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naTsgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcclxuXHJcbiAgICB2YXIgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vOyAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xyXG5cclxuICAgIC8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxyXG4gICAgLy8gaW5jbHVkZXMgc2NvdHRpc2ggZ2FlbGljIHR3byB3b3JkIGFuZCBoeXBoZW5hdGVkIG1vbnRoc1xyXG4gICAgdmFyIG1hdGNoV29yZCA9IC9bMC05XXswLDI1Nn1bJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkYwN1xcdUZGMTAtXFx1RkZFRl17MSwyNTZ9fFtcXHUwNjAwLVxcdTA2RkZcXC9dezEsMjU2fShcXHMqP1tcXHUwNjAwLVxcdTA2RkZdezEsMjU2fSl7MSwyfS9pO1xyXG5cclxuICAgIHZhciByZWdleGVzID0ge307XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkUmVnZXhUb2tlbiAodG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xyXG4gICAgICAgIHJlZ2V4ZXNbdG9rZW5dID0gaXNGdW5jdGlvbihyZWdleCkgPyByZWdleCA6IGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlRGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4KSA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4gKHRva2VuLCBjb25maWcpIHtcclxuICAgICAgICBpZiAoIWhhc093blByb3AocmVnZXhlcywgdG9rZW4pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuZXNjYXBlRm9ybWF0KHRva2VuKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XHJcbiAgICBmdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlZ2V4RXNjYXBlKHMucmVwbGFjZSgnXFxcXCcsICcnKS5yZXBsYWNlKC9cXFxcKFxcWyl8XFxcXChcXF0pfFxcWyhbXlxcXVxcW10qKVxcXXxcXFxcKC4pL2csIGZ1bmN0aW9uIChtYXRjaGVkLCBwMSwgcDIsIHAzLCBwNCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcclxuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdG9rZW5zID0ge307XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIGksIGZ1bmMgPSBjYWxsYmFjaztcclxuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0b2tlbiA9IFt0b2tlbl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc051bWJlcihjYWxsYmFjaykpIHtcclxuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIGFycmF5W2NhbGxiYWNrXSA9IHRvSW50KGlucHV0KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2VuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xyXG4gICAgICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XHJcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xyXG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgWUVBUiA9IDA7XHJcbiAgICB2YXIgTU9OVEggPSAxO1xyXG4gICAgdmFyIERBVEUgPSAyO1xyXG4gICAgdmFyIEhPVVIgPSAzO1xyXG4gICAgdmFyIE1JTlVURSA9IDQ7XHJcbiAgICB2YXIgU0VDT05EID0gNTtcclxuICAgIHZhciBNSUxMSVNFQ09ORCA9IDY7XHJcbiAgICB2YXIgV0VFSyA9IDc7XHJcbiAgICB2YXIgV0VFS0RBWSA9IDg7XHJcblxyXG4gICAgLy8gRk9STUFUVElOR1xyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKCdZJywgMCwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB5ID0gdGhpcy55ZWFyKCk7XHJcbiAgICAgICAgcmV0dXJuIHkgPD0gOTk5OSA/ICcnICsgeSA6ICcrJyArIHk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVknLCAgIDRdLCAgICAgICAwLCAneWVhcicpO1xyXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWScsICA1XSwgICAgICAgMCwgJ3llYXInKTtcclxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVlZJywgNiwgdHJ1ZV0sIDAsICd5ZWFyJyk7XHJcblxyXG4gICAgLy8gQUxJQVNFU1xyXG5cclxuICAgIGFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XHJcblxyXG4gICAgLy8gUFJJT1JJVElFU1xyXG5cclxuICAgIGFkZFVuaXRQcmlvcml0eSgneWVhcicsIDEpO1xyXG5cclxuICAgIC8vIFBBUlNJTkdcclxuXHJcbiAgICBhZGRSZWdleFRva2VuKCdZJywgICAgICBtYXRjaFNpZ25lZCk7XHJcbiAgICBhZGRSZWdleFRva2VuKCdZWScsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XHJcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XHJcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWScsICBtYXRjaDF0bzYsIG1hdGNoNik7XHJcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWVknLCBtYXRjaDF0bzYsIG1hdGNoNik7XHJcblxyXG4gICAgYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcclxuICAgIGFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XHJcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBpbnB1dC5sZW5ndGggPT09IDIgPyBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCkgOiB0b0ludChpbnB1dCk7XHJcbiAgICB9KTtcclxuICAgIGFkZFBhcnNlVG9rZW4oJ1lZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xyXG4gICAgICAgIGFycmF5W1lFQVJdID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xyXG4gICAgfSk7XHJcbiAgICBhZGRQYXJzZVRva2VuKCdZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xyXG4gICAgICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEhFTFBFUlNcclxuXHJcbiAgICBmdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcclxuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcclxuICAgICAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSE9PS1NcclxuXHJcbiAgICBob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE1PTUVOVFNcclxuXHJcbiAgICB2YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0SXNMZWFwWWVhciAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1ha2VHZXRTZXQgKHVuaXQsIGtlZXBUaW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc2V0JDEodGhpcywgdW5pdCwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCB1bml0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0IChtb20sIHVuaXQpIHtcclxuICAgICAgICByZXR1cm4gbW9tLmlzVmFsaWQoKSA/XHJcbiAgICAgICAgICAgIG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpIDogTmFOO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldCQxIChtb20sIHVuaXQsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKG1vbS5pc1ZhbGlkKCkgJiYgIWlzTmFOKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBpZiAodW5pdCA9PT0gJ0Z1bGxZZWFyJyAmJiBpc0xlYXBZZWFyKG1vbS55ZWFyKCkpICYmIG1vbS5tb250aCgpID09PSAxICYmIG1vbS5kYXRlKCkgPT09IDI5KSB7XHJcbiAgICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUsIG1vbS5tb250aCgpLCBkYXlzSW5Nb250aCh2YWx1ZSwgbW9tLm1vbnRoKCkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTU9NRU5UU1xyXG5cclxuICAgIGZ1bmN0aW9uIHN0cmluZ0dldCAodW5pdHMpIHtcclxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBzdHJpbmdTZXQgKHVuaXRzLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplT2JqZWN0VW5pdHModW5pdHMpO1xyXG4gICAgICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmlvcml0aXplZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpc1twcmlvcml0aXplZFtpXS51bml0XSh1bml0c1twcmlvcml0aXplZFtpXS51bml0XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10odmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1vZChuLCB4KSB7XHJcbiAgICAgICAgcmV0dXJuICgobiAlIHgpICsgeCkgJSB4O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpbmRleE9mO1xyXG5cclxuICAgIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xyXG4gICAgICAgIGluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgICAgIC8vIEkga25vd1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSBvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcclxuICAgICAgICBpZiAoaXNOYU4oeWVhcikgfHwgaXNOYU4obW9udGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtb2RNb250aCA9IG1vZChtb250aCwgMTIpO1xyXG4gICAgICAgIHllYXIgKz0gKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XHJcbiAgICAgICAgcmV0dXJuIG1vZE1vbnRoID09PSAxID8gKGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IDI4KSA6ICgzMSAtIG1vZE1vbnRoICUgNyAlIDIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZPUk1BVFRJTkdcclxuXHJcbiAgICBhZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzU2hvcnQodGhpcywgZm9ybWF0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFMSUFTRVNcclxuXHJcbiAgICBhZGRVbml0QWxpYXMoJ21vbnRoJywgJ00nKTtcclxuXHJcbiAgICAvLyBQUklPUklUWVxyXG5cclxuICAgIGFkZFVuaXRQcmlvcml0eSgnbW9udGgnLCA4KTtcclxuXHJcbiAgICAvLyBQQVJTSU5HXHJcblxyXG4gICAgYWRkUmVnZXhUb2tlbignTScsICAgIG1hdGNoMXRvMik7XHJcbiAgICBhZGRSZWdleFRva2VuKCdNTScsICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xyXG4gICAgYWRkUmVnZXhUb2tlbignTU1NJywgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcclxuICAgIH0pO1xyXG4gICAgYWRkUmVnZXhUb2tlbignTU1NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XHJcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcclxuICAgIH0pO1xyXG5cclxuICAgIGFkZFBhcnNlVG9rZW4oWydNTU0nLCAnTU1NTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XHJcbiAgICAgICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XHJcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXHJcbiAgICAgICAgaWYgKG1vbnRoICE9IG51bGwpIHtcclxuICAgICAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZE1vbnRoID0gaW5wdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gTE9DQUxFU1xyXG5cclxuICAgIHZhciBNT05USFNfSU5fRk9STUFUID0gL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccykrTU1NTT8vO1xyXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKTtcclxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSwgZm9ybWF0KSB7XHJcbiAgICAgICAgaWYgKCFtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHMgOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXSA6XHJcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1sodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPSAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyk7XHJcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNTaG9ydCAobSwgZm9ybWF0KSB7XHJcbiAgICAgICAgaWYgKCFtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0IDpcclxuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0WydzdGFuZGFsb25lJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV0gOlxyXG4gICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFtNT05USFNfSU5fRk9STUFULnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcclxuICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gbW9udGhOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCB1c2VkXHJcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRocyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc3RyaWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XHJcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xyXG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlIChtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XHJcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVE9ETzogYWRkIHNvcnRpbmdcclxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyXHJcbiAgICAgICAgLy8gc2VlIHNvcnRpbmcgaW4gY29tcHV0ZU1vbnRoc1BhcnNlXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XHJcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xyXG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcclxuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XHJcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NTScgJiYgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTScgJiYgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBNT01FTlRTXHJcblxyXG4gICAgZnVuY3Rpb24gc2V0TW9udGggKG1vbSwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgZGF5T2ZNb250aDtcclxuXHJcbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgIC8vIE5vIG9wXHJcbiAgICAgICAgICAgIHJldHVybiBtb207XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAoL15cXGQrJC8udGVzdCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb207XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xyXG4gICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyAnTW9udGgnXSh2YWx1ZSwgZGF5T2ZNb250aCk7XHJcbiAgICAgICAgcmV0dXJuIG1vbTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTZXRNb250aCAodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCAnTW9udGgnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGggKCkge1xyXG4gICAgICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XHJcbiAgICBmdW5jdGlvbiBtb250aHNTaG9ydFJlZ2V4IChpc1N0cmljdCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XHJcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcclxuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXg7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1Nob3J0UmVnZXgnKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cclxuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xyXG4gICAgZnVuY3Rpb24gbW9udGhzUmVnZXggKGlzU3RyaWN0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcclxuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xyXG4gICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXg7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IGRlZmF1bHRNb250aHNSZWdleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNSZWdleDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZU1vbnRoc1BhcnNlICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXHJcbiAgICAgICAgICAgIGksIG1vbTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcclxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XHJcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XHJcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XHJcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xyXG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XHJcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxyXG4gICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcclxuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcclxuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcclxuICAgICAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XHJcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDI0OyBpKyspIHtcclxuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcclxuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gdGhpcy5fbW9udGhzUmVnZXg7XHJcbiAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcclxuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUgKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XHJcbiAgICAgICAgLy8gY2FuJ3QganVzdCBhcHBseSgpIHRvIGNyZWF0ZSBhIGRhdGU6XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzE4MTM0OFxyXG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xyXG5cclxuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcclxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xyXG4gICAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XHJcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcclxuXHJcbiAgICAgICAgLy8gdGhlIERhdGUuVVRDIGZ1bmN0aW9uIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxyXG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCAmJiBpc0Zpbml0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpKSB7XHJcbiAgICAgICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXHJcbiAgICBmdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcclxuICAgICAgICB2YXIgLy8gZmlyc3Qtd2VlayBkYXkgLS0gd2hpY2ggamFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgKDQgZm9yIGlzbywgMSBmb3Igb3RoZXIpXHJcbiAgICAgICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXHJcbiAgICAgICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcclxuICAgICAgICAgICAgZndkbHcgPSAoNyArIGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgZndkKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xyXG5cclxuICAgICAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxyXG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XHJcbiAgICAgICAgdmFyIGxvY2FsV2Vla2RheSA9ICg3ICsgd2Vla2RheSAtIGRvdykgJSA3LFxyXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcclxuICAgICAgICAgICAgZGF5T2ZZZWFyID0gMSArIDcgKiAod2VlayAtIDEpICsgbG9jYWxXZWVrZGF5ICsgd2Vla09mZnNldCxcclxuICAgICAgICAgICAgcmVzWWVhciwgcmVzRGF5T2ZZZWFyO1xyXG5cclxuICAgICAgICBpZiAoZGF5T2ZZZWFyIDw9IDApIHtcclxuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xyXG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlzSW5ZZWFyKHJlc1llYXIpICsgZGF5T2ZZZWFyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyKSkge1xyXG4gICAgICAgICAgICByZXNZZWFyID0geWVhciArIDE7XHJcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhciAtIGRheXNJblllYXIoeWVhcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzWWVhciA9IHllYXI7XHJcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXHJcbiAgICAgICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB3ZWVrT2ZZZWFyKG1vbSwgZG93LCBkb3kpIHtcclxuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldChtb20ueWVhcigpLCBkb3csIGRveSksXHJcbiAgICAgICAgICAgIHdlZWsgPSBNYXRoLmZsb29yKChtb20uZGF5T2ZZZWFyKCkgLSB3ZWVrT2Zmc2V0IC0gMSkgLyA3KSArIDEsXHJcbiAgICAgICAgICAgIHJlc1dlZWssIHJlc1llYXI7XHJcblxyXG4gICAgICAgIGlmICh3ZWVrIDwgMSkge1xyXG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSAtIDE7XHJcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrICsgd2Vla3NJblllYXIocmVzWWVhciwgZG93LCBkb3kpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAod2VlayA+IHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KSkge1xyXG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayAtIHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KTtcclxuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgKyAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpO1xyXG4gICAgICAgICAgICByZXNXZWVrID0gd2VlaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHdlZWs6IHJlc1dlZWssXHJcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXJcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XHJcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxyXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0TmV4dCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyICsgMSwgZG93LCBkb3kpO1xyXG4gICAgICAgIHJldHVybiAoZGF5c0luWWVhcih5ZWFyKSAtIHdlZWtPZmZzZXQgKyB3ZWVrT2Zmc2V0TmV4dCkgLyA3O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZPUk1BVFRJTkdcclxuXHJcbiAgICBhZGRGb3JtYXRUb2tlbigndycsIFsnd3cnLCAyXSwgJ3dvJywgJ3dlZWsnKTtcclxuICAgIGFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xyXG5cclxuICAgIC8vIEFMSUFTRVNcclxuXHJcbiAgICBhZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xyXG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrJywgJ1cnKTtcclxuXHJcbiAgICAvLyBQUklPUklUSUVTXHJcblxyXG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrJywgNSk7XHJcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWsnLCA1KTtcclxuXHJcbiAgICAvLyBQQVJTSU5HXHJcblxyXG4gICAgYWRkUmVnZXhUb2tlbigndycsICBtYXRjaDF0bzIpO1xyXG4gICAgYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XHJcbiAgICBhZGRSZWdleFRva2VuKCdXJywgIG1hdGNoMXRvMik7XHJcbiAgICBhZGRSZWdleFRva2VuKCdXVycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcclxuXHJcbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ3cnLCAnd3cnLCAnVycsICdXVyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcclxuICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAxKV0gPSB0b0ludChpbnB1dCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBIRUxQRVJTXHJcblxyXG4gICAgLy8gTE9DQUxFU1xyXG5cclxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWsgKG1vbSkge1xyXG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbSwgdGhpcy5fd2Vlay5kb3csIHRoaXMuX3dlZWsuZG95KS53ZWVrO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcclxuICAgICAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZlllYXIgKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRveTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNT01FTlRTXHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2VlayAoaW5wdXQpIHtcclxuICAgICAgICB2YXIgd2VlayA9IHRoaXMubG9jYWxlRGF0YSgpLndlZWsodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWsgKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIHdlZWsgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLndlZWs7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZPUk1BVFRJTkdcclxuXHJcbiAgICBhZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcclxuXHJcbiAgICBhZGRGb3JtYXRUb2tlbignZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzTWluKHRoaXMsIGZvcm1hdCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZGRGb3JtYXRUb2tlbignZGRkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKCdlJywgMCwgMCwgJ3dlZWtkYXknKTtcclxuICAgIGFkZEZvcm1hdFRva2VuKCdFJywgMCwgMCwgJ2lzb1dlZWtkYXknKTtcclxuXHJcbiAgICAvLyBBTElBU0VTXHJcblxyXG4gICAgYWRkVW5pdEFsaWFzKCdkYXknLCAnZCcpO1xyXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcclxuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XHJcblxyXG4gICAgLy8gUFJJT1JJVFlcclxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5JywgMTEpO1xyXG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrZGF5JywgMTEpO1xyXG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrZGF5JywgMTEpO1xyXG5cclxuICAgIC8vIFBBUlNJTkdcclxuXHJcbiAgICBhZGRSZWdleFRva2VuKCdkJywgICAgbWF0Y2gxdG8yKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ2UnLCAgICBtYXRjaDF0bzIpO1xyXG4gICAgYWRkUmVnZXhUb2tlbignRScsICAgIG1hdGNoMXRvMik7XHJcbiAgICBhZGRSZWdleFRva2VuKCdkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcclxuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpO1xyXG4gICAgfSk7XHJcbiAgICBhZGRSZWdleFRva2VuKCdkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xyXG4gICAgfSk7XHJcbiAgICBhZGRSZWdleFRva2VuKCdkZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xyXG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNSZWdleChpc1N0cmljdCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2RkJywgJ2RkZCcsICdkZGRkJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xyXG4gICAgICAgIHZhciB3ZWVrZGF5ID0gY29uZmlnLl9sb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcclxuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGEgd2Vla2RheSBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWRcclxuICAgICAgICBpZiAod2Vla2RheSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZFdlZWtkYXkgPSBpbnB1dDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xyXG4gICAgICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSEVMUEVSU1xyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc05hTihpbnB1dCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcclxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTE9DQUxFU1xyXG5cclxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXMgPSAnU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXknLnNwbGl0KCdfJyk7XHJcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5cyAobSwgZm9ybWF0KSB7XHJcbiAgICAgICAgaWYgKCFtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKSA/IHRoaXMuX3dlZWtkYXlzIDpcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzWydzdGFuZGFsb25lJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKSA/IHRoaXMuX3dlZWtkYXlzW20uZGF5KCldIDpcclxuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNbdGhpcy5fd2Vla2RheXMuaXNGb3JtYXQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20uZGF5KCldO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyk7XHJcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0IChtKSB7XHJcbiAgICAgICAgcmV0dXJuIChtKSA/IHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c1Nob3J0O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyk7XHJcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbiAobSkge1xyXG4gICAgICAgIHJldHVybiAobSkgPyB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzTWluO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlJDEod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XHJcbiAgICAgICAgdmFyIGksIGlpLCBtb20sIGxsYyA9IHdlZWtkYXlOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHtcclxuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzdHJpY3QpIHtcclxuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XHJcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XHJcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcclxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcclxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNQYXJzZSAod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XHJcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlJDEuY2FsbCh0aGlzLCB3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcclxuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XHJcblxyXG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XHJcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLCAnaScpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJywgJ2knKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJywgJ2knKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcclxuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcclxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGRkJyAmJiB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZCcgJiYgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGQnICYmIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTU9NRU5UU1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mV2VlayAoaW5wdXQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XHJcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGlucHV0IC0gZGF5LCAnZCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayAoaW5wdXQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHdlZWtkYXkgPSAodGhpcy5kYXkoKSArIDcgLSB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3cpICUgNztcclxuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYmVoYXZlcyB0aGUgc2FtZSBhcyBtb21lbnQjZGF5IGV4Y2VwdFxyXG4gICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXHJcbiAgICAgICAgLy8gYXMgYSBzZXR0ZXIsIHN1bmRheSBzaG91bGQgYmVsb25nIHRvIHRoZSBwcmV2aW91cyB3ZWVrLlxyXG5cclxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgd2Vla2RheSA9IHBhcnNlSXNvV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyB3ZWVrZGF5IDogd2Vla2RheSAtIDcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSgpIHx8IDc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBkZWZhdWx0V2Vla2RheXNSZWdleCA9IG1hdGNoV29yZDtcclxuICAgIGZ1bmN0aW9uIHdlZWtkYXlzUmVnZXggKGlzU3RyaWN0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xyXG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcclxuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzUmVnZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzUmVnZXg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xyXG4gICAgZnVuY3Rpb24gd2Vla2RheXNTaG9ydFJlZ2V4IChpc1N0cmljdCkge1xyXG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcclxuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1Nob3J0UmVnZXgnKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cclxuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4ID0gbWF0Y2hXb3JkO1xyXG4gICAgZnVuY3Rpb24gd2Vla2RheXNNaW5SZWdleCAoaXNTdHJpY3QpIHtcclxuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XHJcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xyXG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXZWVrZGF5c1BhcnNlICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBtaW5QaWVjZXMgPSBbXSwgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxyXG4gICAgICAgICAgICBpLCBtb20sIG1pbnAsIHNob3J0cCwgbG9uZ3A7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcclxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xyXG4gICAgICAgICAgICBtaW5wID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcclxuICAgICAgICAgICAgc2hvcnRwID0gdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpO1xyXG4gICAgICAgICAgICBsb25ncCA9IHRoaXMud2Vla2RheXMobW9tLCAnJyk7XHJcbiAgICAgICAgICAgIG1pblBpZWNlcy5wdXNoKG1pbnApO1xyXG4gICAgICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHNob3J0cCk7XHJcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XHJcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobWlucCk7XHJcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2goc2hvcnRwKTtcclxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgd2Vla2RheSAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxyXG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cclxuICAgICAgICBtaW5QaWVjZXMuc29ydChjbXBMZW5SZXYpO1xyXG4gICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcclxuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcclxuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xyXG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcclxuICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xyXG4gICAgICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XHJcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcclxuICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcclxuXHJcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xyXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcclxuICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWluUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGT1JNQVRUSU5HXHJcblxyXG4gICAgZnVuY3Rpb24gaEZvcm1hdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24ga0Zvcm1hdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpIHx8IDI0O1xyXG4gICAgfVxyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xyXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2gnLCBbJ2hoJywgMl0sIDAsIGhGb3JtYXQpO1xyXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKCdobW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKCdobW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcclxuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZGRGb3JtYXRUb2tlbignSG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcclxuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gbWVyaWRpZW0gKHRva2VuLCBsb3dlcmNhc2UpIHtcclxuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubWVyaWRpZW0odGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgbG93ZXJjYXNlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBtZXJpZGllbSgnYScsIHRydWUpO1xyXG4gICAgbWVyaWRpZW0oJ0EnLCBmYWxzZSk7XHJcblxyXG4gICAgLy8gQUxJQVNFU1xyXG5cclxuICAgIGFkZFVuaXRBbGlhcygnaG91cicsICdoJyk7XHJcblxyXG4gICAgLy8gUFJJT1JJVFlcclxuICAgIGFkZFVuaXRQcmlvcml0eSgnaG91cicsIDEzKTtcclxuXHJcbiAgICAvLyBQQVJTSU5HXHJcblxyXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbSAoaXNTdHJpY3QsIGxvY2FsZSkge1xyXG4gICAgICAgIHJldHVybiBsb2NhbGUuX21lcmlkaWVtUGFyc2U7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkUmVnZXhUb2tlbignYScsICBtYXRjaE1lcmlkaWVtKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCAgbWF0Y2hNZXJpZGllbSk7XHJcbiAgICBhZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XHJcbiAgICBhZGRSZWdleFRva2VuKCdoJywgIG1hdGNoMXRvMik7XHJcbiAgICBhZGRSZWdleFRva2VuKCdrJywgIG1hdGNoMXRvMik7XHJcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ2hoJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xyXG4gICAgYWRkUmVnZXhUb2tlbigna2snLCBtYXRjaDF0bzIsIG1hdGNoMik7XHJcblxyXG4gICAgYWRkUmVnZXhUb2tlbignaG1tJywgbWF0Y2gzdG80KTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbXNzJywgbWF0Y2g1dG82KTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XHJcbiAgICBhZGRSZWdleFRva2VuKCdIbW1zcycsIG1hdGNoNXRvNik7XHJcblxyXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XHJcbiAgICBhZGRQYXJzZVRva2VuKFsnaycsICdrayddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcclxuICAgICAgICB2YXIga0lucHV0ID0gdG9JbnQoaW5wdXQpO1xyXG4gICAgICAgIGFycmF5W0hPVVJdID0ga0lucHV0ID09PSAyNCA/IDAgOiBrSW5wdXQ7XHJcbiAgICB9KTtcclxuICAgIGFkZFBhcnNlVG9rZW4oWydhJywgJ0EnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XHJcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XHJcbiAgICAgICAgY29uZmlnLl9tZXJpZGllbSA9IGlucHV0O1xyXG4gICAgfSk7XHJcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcclxuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0KTtcclxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcclxuICAgIH0pO1xyXG4gICAgYWRkUGFyc2VUb2tlbignaG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XHJcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XHJcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcclxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcclxuICAgIH0pO1xyXG4gICAgYWRkUGFyc2VUb2tlbignaG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcclxuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XHJcbiAgICAgICAgdmFyIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xyXG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcclxuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcclxuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcclxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcclxuICAgIH0pO1xyXG4gICAgYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XHJcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XHJcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcclxuICAgIH0pO1xyXG4gICAgYWRkUGFyc2VUb2tlbignSG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcclxuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XHJcbiAgICAgICAgdmFyIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xyXG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcclxuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcclxuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIExPQ0FMRVNcclxuXHJcbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xyXG4gICAgICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcclxuICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cclxuICAgICAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaTtcclxuICAgIGZ1bmN0aW9uIGxvY2FsZU1lcmlkaWVtIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VycyA+IDExKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYW0nIDogJ0FNJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIE1PTUVOVFNcclxuXHJcbiAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcclxuICAgIC8vIHNwZWNpZmllZCB3aGljaCBob3VyIHRoZXkgd2FudC4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXHJcbiAgICAvLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcclxuICAgIC8vIHRoaXMgcnVsZS5cclxuICAgIHZhciBnZXRTZXRIb3VyID0gbWFrZUdldFNldCgnSG91cnMnLCB0cnVlKTtcclxuXHJcbiAgICB2YXIgYmFzZUNvbmZpZyA9IHtcclxuICAgICAgICBjYWxlbmRhcjogZGVmYXVsdENhbGVuZGFyLFxyXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0OiBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQsXHJcbiAgICAgICAgaW52YWxpZERhdGU6IGRlZmF1bHRJbnZhbGlkRGF0ZSxcclxuICAgICAgICBvcmRpbmFsOiBkZWZhdWx0T3JkaW5hbCxcclxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSxcclxuICAgICAgICByZWxhdGl2ZVRpbWU6IGRlZmF1bHRSZWxhdGl2ZVRpbWUsXHJcblxyXG4gICAgICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcclxuICAgICAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxyXG5cclxuICAgICAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcclxuXHJcbiAgICAgICAgd2Vla2RheXM6IGRlZmF1bHRMb2NhbGVXZWVrZGF5cyxcclxuICAgICAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxyXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LFxyXG5cclxuICAgICAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsb2NhbGUgY29uZmlnIGZpbGVzXHJcbiAgICB2YXIgbG9jYWxlcyA9IHt9O1xyXG4gICAgdmFyIGxvY2FsZUZhbWlsaWVzID0ge307XHJcbiAgICB2YXIgZ2xvYmFsTG9jYWxlO1xyXG5cclxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZShrZXkpIHtcclxuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XHJcbiAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxyXG4gICAgLy8gc3Vic3RyaW5nIGZyb20gbW9zdCBzcGVjaWZpYyB0byBsZWFzdCwgYnV0IG1vdmUgdG8gdGhlIG5leHQgYXJyYXkgaXRlbSBpZiBpdCdzIGEgbW9yZSBzcGVjaWZpYyB2YXJpYW50IHRoYW4gdGhlIGN1cnJlbnQgcm9vdFxyXG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XHJcbiAgICAgICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xyXG5cclxuICAgICAgICB3aGlsZSAoaSA8IG5hbWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBzcGxpdCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpXSkuc3BsaXQoJy0nKTtcclxuICAgICAgICAgICAgaiA9IHNwbGl0Lmxlbmd0aDtcclxuICAgICAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpICsgMV0pO1xyXG4gICAgICAgICAgICBuZXh0ID0gbmV4dCA/IG5leHQuc3BsaXQoJy0nKSA6IG51bGw7XHJcbiAgICAgICAgICAgIHdoaWxlIChqID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lmxlbmd0aCA+PSBqICYmIGNvbXBhcmVBcnJheXMoc3BsaXQsIG5leHQsIHRydWUpID49IGogLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgbmV4dCBhcnJheSBpdGVtIGlzIGJldHRlciB0aGFuIGEgc2hhbGxvd2VyIHN1YnN0cmluZyBvZiB0aGlzIG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgai0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcclxuICAgICAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcclxuICAgICAgICAvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byByZWdpc3RlciBhbmQgbG9hZCBhbGwgdGhlIGxvY2FsZXMgaW4gTm9kZVxyXG4gICAgICAgIGlmICghbG9jYWxlc1tuYW1lXSAmJiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpICYmXHJcbiAgICAgICAgICAgICAgICBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcclxuICAgICAgICAgICAgICAgIHZhciBhbGlhc2VkUmVxdWlyZSA9IHJlcXVpcmU7XHJcbiAgICAgICAgICAgICAgICBhbGlhc2VkUmVxdWlyZSgnLi9sb2NhbGUvJyArIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG9sZExvY2FsZSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxvY2FsZSBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsb2NhbGUuICBJZlxyXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcclxuICAgIC8vIGxvY2FsZSBrZXkuXHJcbiAgICBmdW5jdGlvbiBnZXRTZXRHbG9iYWxMb2NhbGUgKGtleSwgdmFsdWVzKSB7XHJcbiAgICAgICAgdmFyIGRhdGE7XHJcbiAgICAgICAgaWYgKGtleSkge1xyXG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWVzKSkge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IGdldExvY2FsZShrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBtb21lbnQuZHVyYXRpb24uX2xvY2FsZSA9IG1vbWVudC5fbG9jYWxlID0gZGF0YTtcclxuICAgICAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vd2FybiB1c2VyIGlmIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGJ1dCB0aGUgbG9jYWxlIGNvdWxkIG5vdCBiZSBzZXRcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0xvY2FsZSAnICsga2V5ICsgICcgbm90IGZvdW5kLiBEaWQgeW91IGZvcmdldCB0byBsb2FkIGl0PycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgY29uZmlnKSB7XHJcbiAgICAgICAgaWYgKGNvbmZpZyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgbG9jYWxlLCBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xyXG4gICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XHJcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZSgnZGVmaW5lTG9jYWxlT3ZlcnJpZGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdhbiBleGlzdGluZyBsb2NhbGUuIG1vbWVudC5kZWZpbmVMb2NhbGUobG9jYWxlTmFtZSwgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb25maWcpIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGNyZWF0aW5nIGEgbmV3IGxvY2FsZSAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJyk7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW25hbWVdLl9jb25maWc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXS5fY29uZmlnO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGNvbmZpZy5wYXJlbnRMb2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGUuX2NvbmZpZztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUobWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSk7XHJcblxyXG4gICAgICAgICAgICBpZiAobG9jYWxlRmFtaWxpZXNbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZpbmVMb2NhbGUoeC5uYW1lLCB4LmNvbmZpZyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXHJcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGxvY2FsZSBBRlRFUiBhbGwgY2hpbGQgbG9jYWxlcyBoYXZlIGJlZW5cclxuICAgICAgICAgICAgLy8gY3JlYXRlZCwgc28gd2Ugd29uJ3QgZW5kIHVwIHdpdGggdGhlIGNoaWxkIGxvY2FsZSBzZXQuXHJcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcclxuXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcclxuICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVMb2NhbGUobmFtZSwgY29uZmlnKSB7XHJcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHRtcExvY2FsZSwgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcclxuICAgICAgICAgICAgLy8gTUVSR0VcclxuICAgICAgICAgICAgdG1wTG9jYWxlID0gbG9hZExvY2FsZShuYW1lKTtcclxuICAgICAgICAgICAgaWYgKHRtcExvY2FsZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSB0bXBMb2NhbGUuX2NvbmZpZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpO1xyXG4gICAgICAgICAgICBsb2NhbGUgPSBuZXcgTG9jYWxlKGNvbmZpZyk7XHJcbiAgICAgICAgICAgIGxvY2FsZS5wYXJlbnRMb2NhbGUgPSBsb2NhbGVzW25hbWVdO1xyXG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xyXG5cclxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXHJcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBwYXNzIG51bGwgZm9yIGNvbmZpZyB0byB1bnVwZGF0ZSwgdXNlZnVsIGZvciB0ZXN0c1xyXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmV0dXJucyBsb2NhbGUgZGF0YVxyXG4gICAgZnVuY3Rpb24gZ2V0TG9jYWxlIChrZXkpIHtcclxuICAgICAgICB2YXIgbG9jYWxlO1xyXG5cclxuICAgICAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XHJcbiAgICAgICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNBcnJheShrZXkpKSB7XHJcbiAgICAgICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcclxuICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShrZXkpO1xyXG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGtleSA9IFtrZXldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxpc3RMb2NhbGVzKCkge1xyXG4gICAgICAgIHJldHVybiBrZXlzKGxvY2FsZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcclxuICAgICAgICB2YXIgb3ZlcmZsb3c7XHJcbiAgICAgICAgdmFyIGEgPSBtLl9hO1xyXG5cclxuICAgICAgICBpZiAoYSAmJiBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPT09IC0yKSB7XHJcbiAgICAgICAgICAgIG92ZXJmbG93ID1cclxuICAgICAgICAgICAgICAgIGFbTU9OVEhdICAgICAgIDwgMCB8fCBhW01PTlRIXSAgICAgICA+IDExICA/IE1PTlRIIDpcclxuICAgICAgICAgICAgICAgIGFbREFURV0gICAgICAgIDwgMSB8fCBhW0RBVEVdICAgICAgICA+IGRheXNJbk1vbnRoKGFbWUVBUl0sIGFbTU9OVEhdKSA/IERBVEUgOlxyXG4gICAgICAgICAgICAgICAgYVtIT1VSXSAgICAgICAgPCAwIHx8IGFbSE9VUl0gICAgICAgID4gMjQgfHwgKGFbSE9VUl0gPT09IDI0ICYmIChhW01JTlVURV0gIT09IDAgfHwgYVtTRUNPTkRdICE9PSAwIHx8IGFbTUlMTElTRUNPTkRdICE9PSAwKSkgPyBIT1VSIDpcclxuICAgICAgICAgICAgICAgIGFbTUlOVVRFXSAgICAgIDwgMCB8fCBhW01JTlVURV0gICAgICA+IDU5ICA/IE1JTlVURSA6XHJcbiAgICAgICAgICAgICAgICBhW1NFQ09ORF0gICAgICA8IDAgfHwgYVtTRUNPTkRdICAgICAgPiA1OSAgPyBTRUNPTkQgOlxyXG4gICAgICAgICAgICAgICAgYVtNSUxMSVNFQ09ORF0gPCAwIHx8IGFbTUlMTElTRUNPTkRdID4gOTk5ID8gTUlMTElTRUNPTkQgOlxyXG4gICAgICAgICAgICAgICAgLTE7XHJcblxyXG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJiAob3ZlcmZsb3cgPCBZRUFSIHx8IG92ZXJmbG93ID4gREFURSkpIHtcclxuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtzICYmIG92ZXJmbG93ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla2RheSAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFS0RBWTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXHJcbiAgICBmdW5jdGlvbiBkZWZhdWx0cyhhLCBiLCBjKSB7XHJcbiAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcclxuICAgICAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxyXG4gICAgICAgIHZhciBub3dWYWx1ZSA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcclxuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW25vd1ZhbHVlLmdldEZ1bGxZZWFyKCksIG5vd1ZhbHVlLmdldE1vbnRoKCksIG5vd1ZhbHVlLmdldERhdGUoKV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29udmVydCBhbiBhcnJheSB0byBhIGRhdGUuXHJcbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xyXG4gICAgLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXHJcbiAgICAvLyBbeWVhciwgbW9udGgsIGRheSAsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF1cclxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIGksIGRhdGUsIGlucHV0ID0gW10sIGN1cnJlbnREYXRlLCBleHBlY3RlZFdlZWtkYXksIHllYXJUb1VzZTtcclxuXHJcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKTtcclxuXHJcbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xyXG4gICAgICAgIGlmIChjb25maWcuX3cgJiYgY29uZmlnLl9hW0RBVEVdID09IG51bGwgJiYgY29uZmlnLl9hW01PTlRIXSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXHJcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgeWVhclRvVXNlID0gZGVmYXVsdHMoY29uZmlnLl9hW1lFQVJdLCBjdXJyZW50RGF0ZVtZRUFSXSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHwgY29uZmlnLl9kYXlPZlllYXIgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKHllYXJUb1VzZSwgMCwgY29uZmlnLl9kYXlPZlllYXIpO1xyXG4gICAgICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xyXG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxyXG4gICAgICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcclxuICAgICAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXHJcbiAgICAgICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xyXG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXHJcbiAgICAgICAgZm9yICg7IGkgPCA3OyBpKyspIHtcclxuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSAoY29uZmlnLl9hW2ldID09IG51bGwpID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXHJcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcclxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXHJcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbU0VDT05EXSA9PT0gMCAmJlxyXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb25maWcuX25leHREYXkgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KG51bGwsIGlucHV0KTtcclxuICAgICAgICBleHBlY3RlZFdlZWtkYXkgPSBjb25maWcuX3VzZVVUQyA/IGNvbmZpZy5fZC5nZXRVVENEYXkoKSA6IGNvbmZpZy5fZC5nZXREYXkoKTtcclxuXHJcbiAgICAgICAgLy8gQXBwbHkgdGltZXpvbmUgb2Zmc2V0IGZyb20gaW5wdXQuIFRoZSBhY3R1YWwgdXRjT2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXHJcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXHJcbiAgICAgICAgaWYgKGNvbmZpZy5fdHptICE9IG51bGwpIHtcclxuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjb25maWcuX25leHREYXkpIHtcclxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjaGVjayBmb3IgbWlzbWF0Y2hpbmcgZGF5IG9mIHdlZWtcclxuICAgICAgICBpZiAoY29uZmlnLl93ICYmIHR5cGVvZiBjb25maWcuX3cuZCAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uZmlnLl93LmQgIT09IGV4cGVjdGVkV2Vla2RheSkge1xyXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcCwgd2Vla2RheU92ZXJmbG93O1xyXG5cclxuICAgICAgICB3ID0gY29uZmlnLl93O1xyXG4gICAgICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZG93ID0gMTtcclxuICAgICAgICAgICAgZG95ID0gNDtcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE86IFdlIG5lZWQgdG8gdGFrZSB0aGUgY3VycmVudCBpc29XZWVrWWVhciwgYnV0IHRoYXQgZGVwZW5kcyBvblxyXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXHJcbiAgICAgICAgICAgIC8vIGEgbm93IHZlcnNpb24gb2YgY3VycmVudCBjb25maWcgKHRha2UgbG9jYWwvdXRjL29mZnNldCBmbGFncywgYW5kXHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBub3cpLlxyXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcclxuICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcuVywgMSk7XHJcbiAgICAgICAgICAgIHdlZWtkYXkgPSBkZWZhdWx0cyh3LkUsIDEpO1xyXG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcclxuICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkb3cgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3c7XHJcbiAgICAgICAgICAgIGRveSA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRveTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjdXJXZWVrID0gd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCBkb3csIGRveSk7XHJcblxyXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgY3VyV2Vlay55ZWFyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCB3ZWVrLlxyXG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCBjdXJXZWVrLndlZWspO1xyXG5cclxuICAgICAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcclxuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XHJcbiAgICAgICAgICAgICAgICBpZiAod2Vla2RheSA8IDAgfHwgd2Vla2RheSA+IDYpIHtcclxuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2luaW5nIG9mIHdlZWtcclxuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XHJcbiAgICAgICAgICAgICAgICBpZiAody5lIDwgMCB8fCB3LmUgPiA2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xyXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcclxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla3MgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xyXG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XHJcbiAgICAgICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdGVtcC5kYXlPZlllYXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGlzbyA4NjAxIHJlZ2V4XHJcbiAgICAvLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcclxuICAgIHZhciBleHRlbmRlZElzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzpcXGRcXGQtXFxkXFxkfFdcXGRcXGQtXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86OlxcZFxcZCg/OjpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xyXG4gICAgdmFyIGJhc2ljSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pKD86XFxkXFxkXFxkXFxkfFdcXGRcXGRcXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xyXG5cclxuICAgIHZhciB0elJlZ2V4ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vO1xyXG5cclxuICAgIHZhciBpc29EYXRlcyA9IFtcclxuICAgICAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcclxuICAgICAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcclxuICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcclxuICAgICAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXHJcbiAgICAgICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXHJcbiAgICAgICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXHJcbiAgICAgICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXHJcbiAgICAgICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcclxuICAgICAgICAvLyBZWVlZTU0gaXMgTk9UIGFsbG93ZWQgYnkgdGhlIHN0YW5kYXJkXHJcbiAgICAgICAgWydHR0dHW1ddV1dFJywgL1xcZHs0fVdcXGR7M30vXSxcclxuICAgICAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxyXG4gICAgICAgIFsnWVlZWURERCcsIC9cXGR7N30vXVxyXG4gICAgXTtcclxuXHJcbiAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXHJcbiAgICB2YXIgaXNvVGltZXMgPSBbXHJcbiAgICAgICAgWydISDptbTpzcy5TU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxyXG4gICAgICAgIFsnSEg6bW06c3MsU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZCxcXGQrL10sXHJcbiAgICAgICAgWydISDptbTpzcycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZC9dLFxyXG4gICAgICAgIFsnSEg6bW0nLCAvXFxkXFxkOlxcZFxcZC9dLFxyXG4gICAgICAgIFsnSEhtbXNzLlNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkXFwuXFxkKy9dLFxyXG4gICAgICAgIFsnSEhtbXNzLFNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkLFxcZCsvXSxcclxuICAgICAgICBbJ0hIbW1zcycsIC9cXGRcXGRcXGRcXGRcXGRcXGQvXSxcclxuICAgICAgICBbJ0hIbW0nLCAvXFxkXFxkXFxkXFxkL10sXHJcbiAgICAgICAgWydISCcsIC9cXGRcXGQvXVxyXG4gICAgXTtcclxuXHJcbiAgICB2YXIgYXNwTmV0SnNvblJlZ2V4ID0gL15cXC8/RGF0ZVxcKChcXC0/XFxkKykvaTtcclxuXHJcbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxyXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlTTyhjb25maWcpIHtcclxuICAgICAgICB2YXIgaSwgbCxcclxuICAgICAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxyXG4gICAgICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxyXG4gICAgICAgICAgICBhbGxvd1RpbWUsIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIHR6Rm9ybWF0O1xyXG5cclxuICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaXNvID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29EYXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc29EYXRlc1tpXVsxXS5leGVjKG1hdGNoWzFdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBpc29EYXRlc1tpXVswXTtcclxuICAgICAgICAgICAgICAgICAgICBhbGxvd1RpbWUgPSBpc29EYXRlc1tpXVsyXSAhPT0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGVGb3JtYXQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvVGltZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMobWF0Y2hbM10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoWzJdIHNob3VsZCBiZSAnVCcgb3Igc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZUZvcm1hdCA9IChtYXRjaFsyXSB8fCAnICcpICsgaXNvVGltZXNbaV1bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aW1lRm9ybWF0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFhbGxvd1RpbWUgJiYgdGltZUZvcm1hdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWF0Y2hbNF0pIHtcclxuICAgICAgICAgICAgICAgIGlmICh0elJlZ2V4LmV4ZWMobWF0Y2hbNF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHpGb3JtYXQgPSAnWic7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25maWcuX2YgPSBkYXRlRm9ybWF0ICsgKHRpbWVGb3JtYXQgfHwgJycpICsgKHR6Rm9ybWF0IHx8ICcnKTtcclxuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXHJcbiAgICB2YXIgcmZjMjgyMiA9IC9eKD86KE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksP1xccyk/KFxcZHsxLDJ9KVxccyhKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYylcXHMoXFxkezIsNH0pXFxzKFxcZFxcZCk6KFxcZFxcZCkoPzo6KFxcZFxcZCkpP1xccyg/OihVVHxHTVR8W0VDTVBdW1NEXVQpfChbWnpdKXwoWystXVxcZHs0fSkpJC87XHJcblxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyh5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cikge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXHJcbiAgICAgICAgICAgIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpLFxyXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQuaW5kZXhPZihtb250aFN0ciksXHJcbiAgICAgICAgICAgIHBhcnNlSW50KGRheVN0ciwgMTApLFxyXG4gICAgICAgICAgICBwYXJzZUludChob3VyU3RyLCAxMCksXHJcbiAgICAgICAgICAgIHBhcnNlSW50KG1pbnV0ZVN0ciwgMTApXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgaWYgKHNlY29uZFN0cikge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChzZWNvbmRTdHIsIDEwKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpIHtcclxuICAgICAgICB2YXIgeWVhciA9IHBhcnNlSW50KHllYXJTdHIsIDEwKTtcclxuICAgICAgICBpZiAoeWVhciA8PSA0OSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMjAwMCArIHllYXI7XHJcbiAgICAgICAgfSBlbHNlIGlmICh5ZWFyIDw9IDk5OSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTkwMCArIHllYXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB5ZWFyO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByZXByb2Nlc3NSRkMyODIyKHMpIHtcclxuICAgICAgICAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxyXG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1xcKFteKV0qXFwpfFtcXG5cXHRdL2csICcgJykucmVwbGFjZSgvKFxcc1xccyspL2csICcgJykucmVwbGFjZSgvXlxcc1xccyovLCAnJykucmVwbGFjZSgvXFxzXFxzKiQvLCAnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2hlY2tXZWVrZGF5KHdlZWtkYXlTdHIsIHBhcnNlZElucHV0LCBjb25maWcpIHtcclxuICAgICAgICBpZiAod2Vla2RheVN0cikge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIHRoZSB2YW5pbGxhIEpTIERhdGUgb2JqZWN0IHdpdGggYW4gaW5kZXBlbnRlbnQgZGF5LW9mLXdlZWsgY2hlY2suXHJcbiAgICAgICAgICAgIHZhciB3ZWVrZGF5UHJvdmlkZWQgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydC5pbmRleE9mKHdlZWtkYXlTdHIpLFxyXG4gICAgICAgICAgICAgICAgd2Vla2RheUFjdHVhbCA9IG5ldyBEYXRlKHBhcnNlZElucHV0WzBdLCBwYXJzZWRJbnB1dFsxXSwgcGFyc2VkSW5wdXRbMl0pLmdldERheSgpO1xyXG4gICAgICAgICAgICBpZiAod2Vla2RheVByb3ZpZGVkICE9PSB3ZWVrZGF5QWN0dWFsKSB7XHJcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG9ic09mZnNldHMgPSB7XHJcbiAgICAgICAgVVQ6IDAsXHJcbiAgICAgICAgR01UOiAwLFxyXG4gICAgICAgIEVEVDogLTQgKiA2MCxcclxuICAgICAgICBFU1Q6IC01ICogNjAsXHJcbiAgICAgICAgQ0RUOiAtNSAqIDYwLFxyXG4gICAgICAgIENTVDogLTYgKiA2MCxcclxuICAgICAgICBNRFQ6IC02ICogNjAsXHJcbiAgICAgICAgTVNUOiAtNyAqIDYwLFxyXG4gICAgICAgIFBEVDogLTcgKiA2MCxcclxuICAgICAgICBQU1Q6IC04ICogNjBcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KG9ic09mZnNldCwgbWlsaXRhcnlPZmZzZXQsIG51bU9mZnNldCkge1xyXG4gICAgICAgIGlmIChvYnNPZmZzZXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9ic09mZnNldHNbb2JzT2Zmc2V0XTtcclxuICAgICAgICB9IGVsc2UgaWYgKG1pbGl0YXJ5T2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIC8vIHRoZSBvbmx5IGFsbG93ZWQgbWlsaXRhcnkgdHogaXMgWlxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgaG0gPSBwYXJzZUludChudW1PZmZzZXQsIDEwKTtcclxuICAgICAgICAgICAgdmFyIG0gPSBobSAlIDEwMCwgaCA9IChobSAtIG0pIC8gMTAwO1xyXG4gICAgICAgICAgICByZXR1cm4gaCAqIDYwICsgbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZGF0ZSBhbmQgdGltZSBmcm9tIHJlZiAyODIyIGZvcm1hdFxyXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoID0gcmZjMjgyMi5leGVjKHByZXByb2Nlc3NSRkMyODIyKGNvbmZpZy5faSkpO1xyXG4gICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICB2YXIgcGFyc2VkQXJyYXkgPSBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKG1hdGNoWzRdLCBtYXRjaFszXSwgbWF0Y2hbMl0sIG1hdGNoWzVdLCBtYXRjaFs2XSwgbWF0Y2hbN10pO1xyXG4gICAgICAgICAgICBpZiAoIWNoZWNrV2Vla2RheShtYXRjaFsxXSwgcGFyc2VkQXJyYXksIGNvbmZpZykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uZmlnLl9hID0gcGFyc2VkQXJyYXk7XHJcbiAgICAgICAgICAgIGNvbmZpZy5fdHptID0gY2FsY3VsYXRlT2Zmc2V0KG1hdGNoWzhdLCBtYXRjaFs5XSwgbWF0Y2hbMTBdKTtcclxuXHJcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGNyZWF0ZVVUQ0RhdGUuYXBwbHkobnVsbCwgY29uZmlnLl9hKTtcclxuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcclxuXHJcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnJmYzI4MjIgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdCBvciBmYWxsYmFja1xyXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcclxuICAgICAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XHJcblxyXG4gICAgICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xyXG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcclxuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZpbmFsIGF0dGVtcHQsIHVzZSBJbnB1dCBGYWxsYmFja1xyXG4gICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XHJcbiAgICB9XHJcblxyXG4gICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2sgPSBkZXByZWNhdGUoXHJcbiAgICAgICAgJ3ZhbHVlIHByb3ZpZGVkIGlzIG5vdCBpbiBhIHJlY29nbml6ZWQgUkZDMjgyMiBvciBJU08gZm9ybWF0LiBtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZSgpLCAnICtcclxuICAgICAgICAnd2hpY2ggaXMgbm90IHJlbGlhYmxlIGFjcm9zcyBhbGwgYnJvd3NlcnMgYW5kIHZlcnNpb25zLiBOb24gUkZDMjgyMi9JU08gZGF0ZSBmb3JtYXRzIGFyZSAnICtcclxuICAgICAgICAnZGlzY291cmFnZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhbiB1cGNvbWluZyBtYWpvciByZWxlYXNlLiBQbGVhc2UgcmVmZXIgdG8gJyArXHJcbiAgICAgICAgJ2h0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvanMtZGF0ZS8gZm9yIG1vcmUgaW5mby4nLFxyXG4gICAgICAgIGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoY29uZmlnLl9pICsgKGNvbmZpZy5fdXNlVVRDID8gJyBVVEMnIDogJycpKTtcclxuICAgICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBJU08gc3RhbmRhcmRcclxuICAgIGhvb2tzLklTT184NjAxID0gZnVuY3Rpb24gKCkge307XHJcblxyXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIFJGQyAyODIyIGZvcm1cclxuICAgIGhvb2tzLlJGQ18yODIyID0gZnVuY3Rpb24gKCkge307XHJcblxyXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xyXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcclxuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xyXG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLklTT184NjAxKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5SRkNfMjgyMikge1xyXG4gICAgICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbmZpZy5fYSA9IFtdO1xyXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcclxuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXHJcbiAgICAgICAgICAgIGksIHBhcnNlZElucHV0LCB0b2tlbnMsIHRva2VuLCBza2lwcGVkLFxyXG4gICAgICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxyXG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgdG9rZW5zID0gZXhwYW5kRm9ybWF0KGNvbmZpZy5fZiwgY29uZmlnLl9sb2NhbGUpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpIHx8IFtdO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xyXG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fCBbXSlbMF07XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd0b2tlbicsIHRva2VuLCAncGFyc2VkSW5wdXQnLCBwYXJzZWRJbnB1dCxcclxuICAgICAgICAgICAgLy8gICAgICAgICAncmVnZXgnLCBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpO1xyXG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxyXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXHJcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XHJcbiAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXHJcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxyXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXHJcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA+IDApIHtcclxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnBhcnNlZERhdGVQYXJ0cyA9IGNvbmZpZy5fYS5zbGljZSgwKTtcclxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5tZXJpZGllbSA9IGNvbmZpZy5fbWVyaWRpZW07XHJcbiAgICAgICAgLy8gaGFuZGxlIG1lcmlkaWVtXHJcbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKGNvbmZpZy5fbG9jYWxlLCBjb25maWcuX2FbSE9VUl0sIGNvbmZpZy5fbWVyaWRpZW0pO1xyXG5cclxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcclxuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcCAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xyXG4gICAgICAgIHZhciBpc1BtO1xyXG5cclxuICAgICAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBub3RoaW5nIHRvIGRvXHJcbiAgICAgICAgICAgIHJldHVybiBob3VyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobG9jYWxlLm1lcmlkaWVtSG91ciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gRmFsbGJhY2tcclxuICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcclxuICAgICAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XHJcbiAgICAgICAgICAgICAgICBob3VyICs9IDEyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xyXG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXHJcbiAgICAgICAgICAgIHJldHVybiBob3VyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBhcnJheSBvZiBmb3JtYXQgc3RyaW5nc1xyXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xyXG4gICAgICAgIHZhciB0ZW1wQ29uZmlnLFxyXG4gICAgICAgICAgICBiZXN0TW9tZW50LFxyXG5cclxuICAgICAgICAgICAgc2NvcmVUb0JlYXQsXHJcbiAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZTtcclxuXHJcbiAgICAgICAgaWYgKGNvbmZpZy5fZi5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWcuX2YubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY3VycmVudFNjb3JlID0gMDtcclxuICAgICAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XHJcbiAgICAgICAgICAgIGlmIChjb25maWcuX3VzZVVUQyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9mID0gY29uZmlnLl9mW2ldO1xyXG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKHRlbXBDb25maWcpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcclxuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5jaGFyc0xlZnRPdmVyO1xyXG5cclxuICAgICAgICAgICAgLy9vciB0b2tlbnNcclxuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XHJcblxyXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2NvcmVUb0JlYXQgPT0gbnVsbCB8fCBjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xyXG4gICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XHJcbiAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xyXG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpO1xyXG4gICAgICAgIGNvbmZpZy5fYSA9IG1hcChbaS55ZWFyLCBpLm1vbnRoLCBpLmRheSB8fCBpLmRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXSwgZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIHBhcnNlSW50KG9iaiwgMTApO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnIChjb25maWcpIHtcclxuICAgICAgICB2YXIgcmVzID0gbmV3IE1vbWVudChjaGVja092ZXJmbG93KHByZXBhcmVDb25maWcoY29uZmlnKSkpO1xyXG4gICAgICAgIGlmIChyZXMuX25leHREYXkpIHtcclxuICAgICAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXHJcbiAgICAgICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcclxuICAgICAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcmVwYXJlQ29uZmlnIChjb25maWcpIHtcclxuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXHJcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcclxuXHJcbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBnZXRMb2NhbGUoY29uZmlnLl9sKTtcclxuXHJcbiAgICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IChmb3JtYXQgPT09IHVuZGVmaW5lZCAmJiBpbnB1dCA9PT0gJycpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vbWVudChjaGVja092ZXJmbG93KGlucHV0KSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShmb3JtYXQpKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XHJcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcclxuICAgICAgICB9ICBlbHNlIHtcclxuICAgICAgICAgICAgY29uZmlnRnJvbUlucHV0KGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzVmFsaWQoY29uZmlnKSkge1xyXG4gICAgICAgICAgICBjb25maWcuX2QgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xyXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChpbnB1dCkpIHtcclxuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xyXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dC52YWx1ZU9mKCkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nKGNvbmZpZyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xyXG4gICAgICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWxPclVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XHJcbiAgICAgICAgdmFyIGMgPSB7fTtcclxuXHJcbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gdHJ1ZSB8fCBsb2NhbGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHN0cmljdCA9IGxvY2FsZTtcclxuICAgICAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKChpc09iamVjdChpbnB1dCkgJiYgaXNPYmplY3RFbXB0eShpbnB1dCkpIHx8XHJcbiAgICAgICAgICAgICAgICAoaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKSkge1xyXG4gICAgICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcclxuICAgICAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xyXG4gICAgICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XHJcbiAgICAgICAgYy5fbCA9IGxvY2FsZTtcclxuICAgICAgICBjLl9pID0gaW5wdXQ7XHJcbiAgICAgICAgYy5fZiA9IGZvcm1hdDtcclxuICAgICAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XHJcblxyXG4gICAgICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHByb3RvdHlwZU1pbiA9IGRlcHJlY2F0ZShcclxuICAgICAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxyXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIHZhciBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXHJcbiAgICAgICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcclxuICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBQaWNrIGEgbW9tZW50IG0gZnJvbSBtb21lbnRzIHNvIHRoYXQgbVtmbl0ob3RoZXIpIGlzIHRydWUgZm9yIGFsbFxyXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxyXG4gICAgLy9cclxuICAgIC8vIG1vbWVudHMgc2hvdWxkIGVpdGhlciBiZSBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cyBvciBhbiBhcnJheSwgd2hvc2VcclxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXHJcbiAgICBmdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcclxuICAgICAgICB2YXIgcmVzLCBpO1xyXG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XHJcbiAgICAgICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xyXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICghbW9tZW50c1tpXS5pc1ZhbGlkKCkgfHwgbW9tZW50c1tpXVtmbl0ocmVzKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XHJcbiAgICBmdW5jdGlvbiBtaW4gKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xyXG5cclxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1heCAoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XHJcblxyXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbm93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArKG5ldyBEYXRlKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgb3JkZXJpbmcgPSBbJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCAnbWlsbGlzZWNvbmQnXTtcclxuXHJcbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uVmFsaWQobSkge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBtKSB7XHJcbiAgICAgICAgICAgIGlmICghKGluZGV4T2YuY2FsbChvcmRlcmluZywga2V5KSAhPT0gLTEgJiYgKG1ba2V5XSA9PSBudWxsIHx8ICFpc05hTihtW2tleV0pKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHVuaXRIYXNEZWNpbWFsID0gZmFsc2U7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlcmluZy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAobVtvcmRlcmluZ1tpXV0pIHtcclxuICAgICAgICAgICAgICAgIGlmICh1bml0SGFzRGVjaW1hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gb25seSBhbGxvdyBub24taW50ZWdlcnMgZm9yIHNtYWxsZXN0IHVuaXRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KG1bb3JkZXJpbmdbaV1dKSAhPT0gdG9JbnQobVtvcmRlcmluZ1tpXV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pdEhhc0RlY2ltYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVmFsaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52YWxpZCQxKCkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbihOYU4pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIER1cmF0aW9uIChkdXJhdGlvbikge1xyXG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXHJcbiAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcclxuICAgICAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxyXG4gICAgICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcclxuICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCAwLFxyXG4gICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxyXG4gICAgICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXHJcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXHJcbiAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXHJcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xyXG5cclxuICAgICAgICB0aGlzLl9pc1ZhbGlkID0gaXNEdXJhdGlvblZhbGlkKG5vcm1hbGl6ZWRJbnB1dCk7XHJcblxyXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXHJcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gK21pbGxpc2Vjb25kcyArXHJcbiAgICAgICAgICAgIHNlY29uZHMgKiAxZTMgKyAvLyAxMDAwXHJcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcclxuICAgICAgICAgICAgaG91cnMgKiAxMDAwICogNjAgKiA2MDsgLy91c2luZyAxMDAwICogNjAgKiA2MCBpbnN0ZWFkIG9mIDM2ZTUgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yOTc4XHJcbiAgICAgICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXHJcbiAgICAgICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxyXG4gICAgICAgIHRoaXMuX2RheXMgPSArZGF5cyArXHJcbiAgICAgICAgICAgIHdlZWtzICogNztcclxuICAgICAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRvIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xyXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXHJcbiAgICAgICAgLy8gaXQgc2VwYXJhdGVseS5cclxuICAgICAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICtcclxuICAgICAgICAgICAgcXVhcnRlcnMgKiAzICtcclxuICAgICAgICAgICAgeWVhcnMgKiAxMjtcclxuXHJcbiAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xyXG5cclxuICAgICAgICB0aGlzLl9sb2NhbGUgPSBnZXRMb2NhbGUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5fYnViYmxlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvbiAob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFic1JvdW5kIChudW1iZXIpIHtcclxuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgtMSAqIG51bWJlcikgKiAtMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBGT1JNQVRUSU5HXHJcblxyXG4gICAgZnVuY3Rpb24gb2Zmc2V0ICh0b2tlbiwgc2VwYXJhdG9yKSB7XHJcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gJysnO1xyXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcclxuICAgICAgICAgICAgICAgIHNpZ24gPSAnLSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICsgc2VwYXJhdG9yICsgemVyb0ZpbGwofn4ob2Zmc2V0KSAlIDYwLCAyKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBvZmZzZXQoJ1onLCAnOicpO1xyXG4gICAgb2Zmc2V0KCdaWicsICcnKTtcclxuXHJcbiAgICAvLyBQQVJTSU5HXHJcblxyXG4gICAgYWRkUmVnZXhUb2tlbignWicsICBtYXRjaFNob3J0T2Zmc2V0KTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XHJcbiAgICBhZGRQYXJzZVRva2VuKFsnWicsICdaWiddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcclxuICAgICAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XHJcbiAgICAgICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEhFTFBFUlNcclxuXHJcbiAgICAvLyB0aW1lem9uZSBjaHVua2VyXHJcbiAgICAvLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cclxuICAgIC8vICctMTUzMCcgID4gWyctMTUnLCAnMzAnXVxyXG4gICAgdmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xyXG5cclxuICAgIGZ1bmN0aW9uIG9mZnNldEZyb21TdHJpbmcobWF0Y2hlciwgc3RyaW5nKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKTtcclxuXHJcbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY2h1bmsgICA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXTtcclxuICAgICAgICB2YXIgcGFydHMgICA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XHJcbiAgICAgICAgdmFyIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbWludXRlcyA9PT0gMCA/XHJcbiAgICAgICAgICAwIDpcclxuICAgICAgICAgIHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cclxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcclxuICAgICAgICB2YXIgcmVzLCBkaWZmO1xyXG4gICAgICAgIGlmIChtb2RlbC5faXNVVEMpIHtcclxuICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcclxuICAgICAgICAgICAgZGlmZiA9IChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KSA/IGlucHV0LnZhbHVlT2YoKSA6IGNyZWF0ZUxvY2FsKGlucHV0KS52YWx1ZU9mKCkpIC0gcmVzLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgLy8gVXNlIGxvdy1sZXZlbCBhcGksIGJlY2F1c2UgdGhpcyBmbiBpcyBsb3ctbGV2ZWwgYXBpLlxyXG4gICAgICAgICAgICByZXMuX2Quc2V0VGltZShyZXMuX2QudmFsdWVPZigpICsgZGlmZik7XHJcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldERhdGVPZmZzZXQgKG0pIHtcclxuICAgICAgICAvLyBPbiBGaXJlZm94LjI0IERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyBhIGZsb2F0aW5nIHBvaW50LlxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxyXG4gICAgICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkgLyAxNSkgKiAxNTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBIT09LU1xyXG5cclxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cclxuICAgIC8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxyXG4gICAgaG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XHJcblxyXG4gICAgLy8gTU9NRU5UU1xyXG5cclxuICAgIC8vIGtlZXBMb2NhbFRpbWUgPSB0cnVlIG1lYW5zIG9ubHkgY2hhbmdlIHRoZSB0aW1lem9uZSwgd2l0aG91dFxyXG4gICAgLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cclxuICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcclxuICAgIC8vICswMjAwLCBzbyB3ZSBhZGp1c3QgdGhlIHRpbWUgYXMgbmVlZGVkLCB0byBiZSB2YWxpZC5cclxuICAgIC8vXHJcbiAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcclxuICAgIC8vIGZyb20gdGhlIGFjdHVhbCByZXByZXNlbnRlZCB0aW1lLiBUaGF0IGlzIHdoeSB3ZSBjYWxsIHVwZGF0ZU9mZnNldFxyXG4gICAgLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxyXG4gICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXHJcbiAgICAvLyB0aGVyZSBpcyBubyBzdWNoIHRpbWUgaW4gdGhlIGdpdmVuIHRpbWV6b25lLlxyXG4gICAgZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0IChpbnB1dCwga2VlcExvY2FsVGltZSwga2VlcE1pbnV0ZXMpIHtcclxuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXHJcbiAgICAgICAgICAgIGxvY2FsQWRqdXN0O1xyXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2ICYmICFrZWVwTWludXRlcykge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xyXG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBjcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSwgMSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTZXRab25lIChpbnB1dCwga2VlcExvY2FsVGltZSkge1xyXG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dCA9IC1pbnB1dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyAoa2VlcExvY2FsVGltZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb0xvY2FsIChrZWVwTG9jYWxUaW1lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzVVRDKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3R6bSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHZhciB0Wm9uZSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpO1xyXG4gICAgICAgICAgICBpZiAodFpvbmUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodFpvbmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFzQWxpZ25lZEhvdXJPZmZzZXQgKGlucHV0KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlucHV0ID0gaW5wdXQgPyBjcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xyXG5cclxuICAgICAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSAoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCgwKS51dGNPZmZzZXQoKSB8fFxyXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDUpLnV0Y09mZnNldCgpXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQgKCkge1xyXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5faXNEU1RTaGlmdGVkKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGMgPSB7fTtcclxuXHJcbiAgICAgICAgY29weUNvbmZpZyhjLCB0aGlzKTtcclxuICAgICAgICBjID0gcHJlcGFyZUNvbmZpZyhjKTtcclxuXHJcbiAgICAgICAgaWYgKGMuX2EpIHtcclxuICAgICAgICAgICAgdmFyIG90aGVyID0gYy5faXNVVEMgPyBjcmVhdGVVVEMoYy5fYSkgOiBjcmVhdGVMb2NhbChjLl9hKTtcclxuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gdGhpcy5pc1ZhbGlkKCkgJiZcclxuICAgICAgICAgICAgICAgIGNvbXBhcmVBcnJheXMoYy5fYSwgb3RoZXIudG9BcnJheSgpKSA+IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzTG9jYWwgKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzVXRjT2Zmc2V0ICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyA6IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzVXRjICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcclxuICAgIHZhciBhc3BOZXRSZWdleCA9IC9eKFxcLXxcXCspPyg/OihcXGQqKVsuIF0pPyhcXGQrKVxcOihcXGQrKSg/OlxcOihcXGQrKShcXC5cXGQqKT8pPyQvO1xyXG5cclxuICAgIC8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXHJcbiAgICAvLyBzb21ld2hhdCBtb3JlIGluIGxpbmUgd2l0aCA0LjQuMy4yIDIwMDQgc3BlYywgYnV0IGFsbG93cyBkZWNpbWFsIGFueXdoZXJlXHJcbiAgICAvLyBhbmQgZnVydGhlciBtb2RpZmllZCB0byBhbGxvdyBmb3Igc3RyaW5ncyBjb250YWluaW5nIGJvdGggd2VlayBhbmQgZGF5XHJcbiAgICB2YXIgaXNvUmVnZXggPSAvXigtfFxcKyk/UCg/OihbLStdP1swLTksLl0qKVkpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVcpPyg/OihbLStdP1swLTksLl0qKUQpPyg/OlQoPzooWy0rXT9bMC05LC5dKilIKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilTKT8pPyQvO1xyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uIChpbnB1dCwga2V5KSB7XHJcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXHJcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXHJcbiAgICAgICAgICAgIG1hdGNoID0gbnVsbCxcclxuICAgICAgICAgICAgc2lnbixcclxuICAgICAgICAgICAgcmV0LFxyXG4gICAgICAgICAgICBkaWZmUmVzO1xyXG5cclxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcclxuICAgICAgICAgICAgZHVyYXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICBtcyA6IGlucHV0Ll9taWxsaXNlY29uZHMsXHJcbiAgICAgICAgICAgICAgICBkICA6IGlucHV0Ll9kYXlzLFxyXG4gICAgICAgICAgICAgICAgTSAgOiBpbnB1dC5fbW9udGhzXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcclxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcclxuICAgICAgICAgICAgaWYgKGtleSkge1xyXG4gICAgICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9IGlucHV0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gaW5wdXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XHJcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgeSAgOiAwLFxyXG4gICAgICAgICAgICAgICAgZCAgOiB0b0ludChtYXRjaFtEQVRFXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxyXG4gICAgICAgICAgICAgICAgaCAgOiB0b0ludChtYXRjaFtIT1VSXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxyXG4gICAgICAgICAgICAgICAgbSAgOiB0b0ludChtYXRjaFtNSU5VVEVdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxyXG4gICAgICAgICAgICAgICAgcyAgOiB0b0ludChtYXRjaFtTRUNPTkRdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxyXG4gICAgICAgICAgICAgICAgbXMgOiB0b0ludChhYnNSb3VuZChtYXRjaFtNSUxMSVNFQ09ORF0gKiAxMDAwKSkgKiBzaWduIC8vIHRoZSBtaWxsaXNlY29uZCBkZWNpbWFsIHBvaW50IGlzIGluY2x1ZGVkIGluIHRoZSBtYXRjaFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcclxuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogKG1hdGNoWzFdID09PSAnKycpID8gMSA6IDE7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgeSA6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcclxuICAgICAgICAgICAgICAgIE0gOiBwYXJzZUlzbyhtYXRjaFszXSwgc2lnbiksXHJcbiAgICAgICAgICAgICAgICB3IDogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxyXG4gICAgICAgICAgICAgICAgZCA6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcclxuICAgICAgICAgICAgICAgIGggOiBwYXJzZUlzbyhtYXRjaFs2XSwgc2lnbiksXHJcbiAgICAgICAgICAgICAgICBtIDogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxyXG4gICAgICAgICAgICAgICAgcyA6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkgey8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcclxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiYgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKSkge1xyXG4gICAgICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UoY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKSk7XHJcblxyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xyXG4gICAgICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xyXG4gICAgICAgICAgICBkdXJhdGlvbi5NID0gZGlmZlJlcy5tb250aHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xyXG5cclxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xyXG4gICAgICAgICAgICByZXQuX2xvY2FsZSA9IGlucHV0Ll9sb2NhbGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xyXG4gICAgY3JlYXRlRHVyYXRpb24uaW52YWxpZCA9IGNyZWF0ZUludmFsaWQkMTtcclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZUlzbyAoaW5wLCBzaWduKSB7XHJcbiAgICAgICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cclxuICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cclxuICAgICAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXHJcbiAgICAgICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XHJcbiAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxyXG4gICAgICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XHJcblxyXG4gICAgICAgIHJlcy5tb250aHMgPSBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICtcclxuICAgICAgICAgICAgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xyXG4gICAgICAgIGlmIChiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykuaXNBZnRlcihvdGhlcikpIHtcclxuICAgICAgICAgICAgLS1yZXMubW9udGhzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICsoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xyXG4gICAgICAgIHZhciByZXM7XHJcbiAgICAgICAgaWYgKCEoYmFzZS5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG90aGVyID0gY2xvbmVXaXRoT2Zmc2V0KG90aGVyLCBiYXNlKTtcclxuICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcclxuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XHJcbiAgICAgICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcclxuICAgICAgICAgICAgcmVzLm1vbnRocyA9IC1yZXMubW9udGhzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiByZW1vdmUgJ25hbWUnIGFyZyBhZnRlciBkZXByZWNhdGlvbiBpcyByZW1vdmVkXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XHJcbiAgICAgICAgICAgIHZhciBkdXIsIHRtcDtcclxuICAgICAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XHJcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XHJcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUobmFtZSwgJ21vbWVudCgpLicgKyBuYW1lICArICcocGVyaW9kLCBudW1iZXIpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbW9tZW50KCkuJyArIG5hbWUgKyAnKG51bWJlciwgcGVyaW9kKS4gJyArXHJcbiAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvYWRkLWludmVydGVkLXBhcmFtLyBmb3IgbW9yZSBpbmZvLicpO1xyXG4gICAgICAgICAgICAgICAgdG1wID0gdmFsOyB2YWwgPSBwZXJpb2Q7IHBlcmlvZCA9IHRtcDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyArdmFsIDogdmFsO1xyXG4gICAgICAgICAgICBkdXIgPSBjcmVhdGVEdXJhdGlvbih2YWwsIHBlcmlvZCk7XHJcbiAgICAgICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdCAobW9tLCBkdXJhdGlvbiwgaXNBZGRpbmcsIHVwZGF0ZU9mZnNldCkge1xyXG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxyXG4gICAgICAgICAgICBkYXlzID0gYWJzUm91bmQoZHVyYXRpb24uX2RheXMpLFxyXG4gICAgICAgICAgICBtb250aHMgPSBhYnNSb3VuZChkdXJhdGlvbi5fbW9udGhzKTtcclxuXHJcbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgIC8vIE5vIG9wXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcclxuXHJcbiAgICAgICAgaWYgKG1vbnRocykge1xyXG4gICAgICAgICAgICBzZXRNb250aChtb20sIGdldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGF5cykge1xyXG4gICAgICAgICAgICBzZXQkMShtb20sICdEYXRlJywgZ2V0KG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtaWxsaXNlY29uZHMpIHtcclxuICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUobW9tLl9kLnZhbHVlT2YoKSArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVwZGF0ZU9mZnNldCkge1xyXG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBhZGQgICAgICA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKTtcclxuICAgIHZhciBzdWJ0cmFjdCA9IGNyZWF0ZUFkZGVyKC0xLCAnc3VidHJhY3QnKTtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XHJcbiAgICAgICAgdmFyIGRpZmYgPSBteU1vbWVudC5kaWZmKG5vdywgJ2RheXMnLCB0cnVlKTtcclxuICAgICAgICByZXR1cm4gZGlmZiA8IC02ID8gJ3NhbWVFbHNlJyA6XHJcbiAgICAgICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcclxuICAgICAgICAgICAgICAgIGRpZmYgPCAwID8gJ2xhc3REYXknIDpcclxuICAgICAgICAgICAgICAgIGRpZmYgPCAxID8gJ3NhbWVEYXknIDpcclxuICAgICAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcclxuICAgICAgICAgICAgICAgIGRpZmYgPCA3ID8gJ25leHRXZWVrJyA6ICdzYW1lRWxzZSc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2FsZW5kYXIkMSAodGltZSwgZm9ybWF0cykge1xyXG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY29tcGFyZSB0aGUgc3RhcnQgb2YgdG9kYXksIHZzIHRoaXMuXHJcbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXHJcbiAgICAgICAgdmFyIG5vdyA9IHRpbWUgfHwgY3JlYXRlTG9jYWwoKSxcclxuICAgICAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXHJcbiAgICAgICAgICAgIGZvcm1hdCA9IGhvb2tzLmNhbGVuZGFyRm9ybWF0KHRoaXMsIHNvZCkgfHwgJ3NhbWVFbHNlJztcclxuXHJcbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdHMgJiYgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKSA/IGZvcm1hdHNbZm9ybWF0XS5jYWxsKHRoaXMsIG5vdykgOiBmb3JtYXRzW2Zvcm1hdF0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQob3V0cHV0IHx8IHRoaXMubG9jYWxlRGF0YSgpLmNhbGVuZGFyKGZvcm1hdCwgdGhpcywgY3JlYXRlTG9jYWwobm93KSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNsb25lICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0FmdGVyIChpbnB1dCwgdW5pdHMpIHtcclxuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xyXG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHMoIWlzVW5kZWZpbmVkKHVuaXRzKSA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XHJcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsb2NhbElucHV0LnZhbHVlT2YoKSA8IHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcclxuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xyXG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHMoIWlzVW5kZWZpbmVkKHVuaXRzKSA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XHJcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0JldHdlZW4gKGZyb20sIHRvLCB1bml0cywgaW5jbHVzaXZpdHkpIHtcclxuICAgICAgICBpbmNsdXNpdml0eSA9IGluY2x1c2l2aXR5IHx8ICcoKSc7XHJcbiAgICAgICAgcmV0dXJuIChpbmNsdXNpdml0eVswXSA9PT0gJygnID8gdGhpcy5pc0FmdGVyKGZyb20sIHVuaXRzKSA6ICF0aGlzLmlzQmVmb3JlKGZyb20sIHVuaXRzKSkgJiZcclxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzFdID09PSAnKScgPyB0aGlzLmlzQmVmb3JlKHRvLCB1bml0cykgOiAhdGhpcy5pc0FmdGVyKHRvLCB1bml0cykpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzU2FtZSAoaW5wdXQsIHVuaXRzKSB7XHJcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KSxcclxuICAgICAgICAgICAgaW5wdXRNcztcclxuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzIHx8ICdtaWxsaXNlY29uZCcpO1xyXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPT09IGxvY2FsSW5wdXQudmFsdWVPZigpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc1NhbWVPckFmdGVyIChpbnB1dCwgdW5pdHMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQWZ0ZXIoaW5wdXQsdW5pdHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQmVmb3JlKGlucHV0LHVuaXRzKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkaWZmIChpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcclxuICAgICAgICB2YXIgdGhhdCxcclxuICAgICAgICAgICAgem9uZURlbHRhLFxyXG4gICAgICAgICAgICBvdXRwdXQ7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoYXQgPSBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIHRoaXMpO1xyXG5cclxuICAgICAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB6b25lRGVsdGEgPSAodGhhdC51dGNPZmZzZXQoKSAtIHRoaXMudXRjT2Zmc2V0KCkpICogNmU0O1xyXG5cclxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcclxuXHJcbiAgICAgICAgc3dpdGNoICh1bml0cykge1xyXG4gICAgICAgICAgICBjYXNlICd5ZWFyJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpIC8gMTI7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdtb250aCc6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KTsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAzOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDFlMzsgYnJlYWs7IC8vIDEwMDBcclxuICAgICAgICAgICAgY2FzZSAnbWludXRlJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDZlNDsgYnJlYWs7IC8vIDEwMDAgKiA2MFxyXG4gICAgICAgICAgICBjYXNlICdob3VyJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDM2ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MFxyXG4gICAgICAgICAgICBjYXNlICdkYXknOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gODY0ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XHJcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gNjA0OGU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDcsIG5lZ2F0ZSBkc3RcclxuICAgICAgICAgICAgZGVmYXVsdDogb3V0cHV0ID0gdGhpcyAtIHRoYXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbW9udGhEaWZmIChhLCBiKSB7XHJcbiAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcclxuICAgICAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIpICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXHJcbiAgICAgICAgICAgIC8vIGIgaXMgaW4gKGFuY2hvciAtIDEgbW9udGgsIGFuY2hvciArIDEgbW9udGgpXHJcbiAgICAgICAgICAgIGFuY2hvciA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYsICdtb250aHMnKSxcclxuICAgICAgICAgICAgYW5jaG9yMiwgYWRqdXN0O1xyXG5cclxuICAgICAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcclxuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XHJcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXHJcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiArIDEsICdtb250aHMnKTtcclxuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcclxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jaGVjayBmb3IgbmVnYXRpdmUgemVybywgcmV0dXJuIHplcm8gaWYgbmVnYXRpdmUgemVyb1xyXG4gICAgICAgIHJldHVybiAtKHdob2xlTW9udGhEaWZmICsgYWRqdXN0KSB8fCAwO1xyXG4gICAgfVxyXG5cclxuICAgIGhvb2tzLmRlZmF1bHRGb3JtYXQgPSAnWVlZWS1NTS1ERFRISDptbTpzc1onO1xyXG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA9ICdZWVlZLU1NLUREVEhIOm1tOnNzW1pdJztcclxuXHJcbiAgICBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sb2NhbGUoJ2VuJykuZm9ybWF0KCdkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWicpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRvSVNPU3RyaW5nKGtlZXBPZmZzZXQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdXRjID0ga2VlcE9mZnNldCAhPT0gdHJ1ZTtcclxuICAgICAgICB2YXIgbSA9IHV0YyA/IHRoaXMuY2xvbmUoKS51dGMoKSA6IHRoaXM7XHJcbiAgICAgICAgaWYgKG0ueWVhcigpIDwgMCB8fCBtLnllYXIoKSA+IDk5OTkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCB1dGMgPyAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyA6ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xyXG4gICAgICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXMgfjUweCBmYXN0ZXIsIHVzZSBpdCB3aGVuIHdlIGNhblxyXG4gICAgICAgICAgICBpZiAodXRjKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpICsgdGhpcy51dGNPZmZzZXQoKSAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKCdaJywgZm9ybWF0TW9tZW50KG0sICdaJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgdXRjID8gJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBodW1hbiByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIG1vbWVudCB0aGF0IGNhblxyXG4gICAgICogYWxzbyBiZSBldmFsdWF0ZWQgdG8gZ2V0IGEgbmV3IG1vbWVudCB3aGljaCBpcyB0aGUgc2FtZVxyXG4gICAgICpcclxuICAgICAqIEBsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC9kb2NzL2FwaS91dGlsLmh0bWwjdXRpbF9jdXN0b21faW5zcGVjdF9mdW5jdGlvbl9vbl9vYmplY3RzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGluc3BlY3QgKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdtb21lbnQuaW52YWxpZCgvKiAnICsgdGhpcy5faSArICcgKi8pJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGZ1bmMgPSAnbW9tZW50JztcclxuICAgICAgICB2YXIgem9uZSA9ICcnO1xyXG4gICAgICAgIGlmICghdGhpcy5pc0xvY2FsKCkpIHtcclxuICAgICAgICAgICAgZnVuYyA9IHRoaXMudXRjT2Zmc2V0KCkgPT09IDAgPyAnbW9tZW50LnV0YycgOiAnbW9tZW50LnBhcnNlWm9uZSc7XHJcbiAgICAgICAgICAgIHpvbmUgPSAnWic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcmVmaXggPSAnWycgKyBmdW5jICsgJyhcIl0nO1xyXG4gICAgICAgIHZhciB5ZWFyID0gKDAgPD0gdGhpcy55ZWFyKCkgJiYgdGhpcy55ZWFyKCkgPD0gOTk5OSkgPyAnWVlZWScgOiAnWVlZWVlZJztcclxuICAgICAgICB2YXIgZGF0ZXRpbWUgPSAnLU1NLUREW1RdSEg6bW06c3MuU1NTJztcclxuICAgICAgICB2YXIgc3VmZml4ID0gem9uZSArICdbXCIpXSc7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChwcmVmaXggKyB5ZWFyICsgZGF0ZXRpbWUgKyBzdWZmaXgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGZvcm1hdCAoaW5wdXRTdHJpbmcpIHtcclxuICAgICAgICBpZiAoIWlucHV0U3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGlucHV0U3RyaW5nID0gdGhpcy5pc1V0YygpID8gaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA6IGhvb2tzLmRlZmF1bHRGb3JtYXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRNb21lbnQodGhpcywgaW5wdXRTdHJpbmcpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZnJvbSAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxyXG4gICAgICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcclxuICAgICAgICAgICAgICAgICBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7dG86IHRoaXMsIGZyb206IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbShjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0byAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxyXG4gICAgICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcclxuICAgICAgICAgICAgICAgICBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7ZnJvbTogdGhpcywgdG86IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0b05vdyAod2l0aG91dFN1ZmZpeCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcclxuICAgIC8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuICAgIC8vIHZhcmlhYmxlcyBmb3IgdGhpcyBpbnN0YW5jZS5cclxuICAgIGZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XHJcbiAgICAgICAgdmFyIG5ld0xvY2FsZURhdGE7XHJcblxyXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlLl9hYmJyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBnZXRMb2NhbGUoa2V5KTtcclxuICAgICAgICAgICAgaWYgKG5ld0xvY2FsZURhdGEgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGxhbmcgPSBkZXByZWNhdGUoXHJcbiAgICAgICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcclxuICAgICAgICBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIGZ1bmN0aW9uIGxvY2FsZURhdGEgKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3RhcnRPZiAodW5pdHMpIHtcclxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcclxuICAgICAgICAvLyB0aGUgZm9sbG93aW5nIHN3aXRjaCBpbnRlbnRpb25hbGx5IG9taXRzIGJyZWFrIGtleXdvcmRzXHJcbiAgICAgICAgLy8gdG8gdXRpbGl6ZSBmYWxsaW5nIHRocm91Z2ggdGhlIGNhc2VzLlxyXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcclxuICAgICAgICAgICAgY2FzZSAneWVhcic6XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKDApO1xyXG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcclxuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRlKDEpO1xyXG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcclxuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XHJcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5ob3VycygwKTtcclxuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgICAgICAgICAgY2FzZSAnaG91cic6XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pbnV0ZXMoMCk7XHJcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXHJcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZHMoMCk7XHJcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXHJcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcygwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHdlZWtzIGFyZSBhIHNwZWNpYWwgY2FzZVxyXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3dlZWsnKSB7XHJcbiAgICAgICAgICAgIHRoaXMud2Vla2RheSgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVuaXRzID09PSAnaXNvV2VlaycpIHtcclxuICAgICAgICAgICAgdGhpcy5pc29XZWVrZGF5KDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcXVhcnRlcnMgYXJlIGFsc28gc3BlY2lhbFxyXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW9udGgoTWF0aC5mbG9vcih0aGlzLm1vbnRoKCkgLyAzKSAqIDMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZW5kT2YgKHVuaXRzKSB7XHJcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XHJcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAnZGF0ZScgaXMgYW4gYWxpYXMgZm9yICdkYXknLCBzbyBpdCBzaG91bGQgYmUgY29uc2lkZXJlZCBhcyBzdWNoLlxyXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ2RhdGUnKSB7XHJcbiAgICAgICAgICAgIHVuaXRzID0gJ2RheSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mKHVuaXRzKS5hZGQoMSwgKHVuaXRzID09PSAnaXNvV2VlaycgPyAnd2VlaycgOiB1bml0cykpLnN1YnRyYWN0KDEsICdtcycpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHZhbHVlT2YgKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kLnZhbHVlT2YoKSAtICgodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVuaXggKCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpIC8gMTAwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdG9EYXRlICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRvQXJyYXkgKCkge1xyXG4gICAgICAgIHZhciBtID0gdGhpcztcclxuICAgICAgICByZXR1cm4gW20ueWVhcigpLCBtLm1vbnRoKCksIG0uZGF0ZSgpLCBtLmhvdXIoKSwgbS5taW51dGUoKSwgbS5zZWNvbmQoKSwgbS5taWxsaXNlY29uZCgpXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0b09iamVjdCAoKSB7XHJcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHllYXJzOiBtLnllYXIoKSxcclxuICAgICAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXHJcbiAgICAgICAgICAgIGRhdGU6IG0uZGF0ZSgpLFxyXG4gICAgICAgICAgICBob3VyczogbS5ob3VycygpLFxyXG4gICAgICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcclxuICAgICAgICAgICAgc2Vjb25kczogbS5zZWNvbmRzKCksXHJcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdG9KU09OICgpIHtcclxuICAgICAgICAvLyBuZXcgRGF0ZShOYU4pLnRvSlNPTigpID09PSBudWxsXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDIgKCkge1xyXG4gICAgICAgIHJldHVybiBpc1ZhbGlkKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNpbmdGbGFncyAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpbnZhbGlkQXQgKCkge1xyXG4gICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlucHV0OiB0aGlzLl9pLFxyXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXHJcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxyXG4gICAgICAgICAgICBpc1VUQzogdGhpcy5faXNVVEMsXHJcbiAgICAgICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGT1JNQVRUSU5HXHJcblxyXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydnZycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2Vla1llYXIoKSAlIDEwMDtcclxuICAgIH0pO1xyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnR0cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XHJcbiAgICB9KTtcclxuXHJcbiAgICBmdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuICh0b2tlbiwgZ2V0dGVyKSB7XHJcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAgICAgJ3dlZWtZZWFyJyk7XHJcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnZycsICAgICd3ZWVrWWVhcicpO1xyXG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHRycsICAnaXNvV2Vla1llYXInKTtcclxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XHJcblxyXG4gICAgLy8gQUxJQVNFU1xyXG5cclxuICAgIGFkZFVuaXRBbGlhcygnd2Vla1llYXInLCAnZ2cnKTtcclxuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcclxuXHJcbiAgICAvLyBQUklPUklUWVxyXG5cclxuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla1llYXInLCAxKTtcclxuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla1llYXInLCAxKTtcclxuXHJcblxyXG4gICAgLy8gUEFSU0lOR1xyXG5cclxuICAgIGFkZFJlZ2V4VG9rZW4oJ0cnLCAgICAgIG1hdGNoU2lnbmVkKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ2cnLCAgICAgIG1hdGNoU2lnbmVkKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2dnJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcclxuXHJcbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcclxuICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAyKV0gPSB0b0ludChpbnB1dCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnJywgJ0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xyXG4gICAgICAgIHdlZWtbdG9rZW5dID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gTU9NRU5UU1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFyIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXHJcbiAgICAgICAgICAgICAgICBpbnB1dCxcclxuICAgICAgICAgICAgICAgIHRoaXMud2VlaygpLFxyXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3kpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWtZZWFyIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXHJcbiAgICAgICAgICAgICAgICBpbnB1dCwgdGhpcy5pc29XZWVrKCksIHRoaXMuaXNvV2Vla2RheSgpLCAxLCA0KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRJU09XZWVrc0luWWVhciAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCAxLCA0KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRXZWVrc0luWWVhciAoKSB7XHJcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XHJcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXJIZWxwZXIoaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XHJcbiAgICAgICAgdmFyIHdlZWtzVGFyZ2V0O1xyXG4gICAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKHRoaXMsIGRvdywgZG95KS55ZWFyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHdlZWtzVGFyZ2V0ID0gd2Vla3NJblllYXIoaW5wdXQsIGRvdywgZG95KTtcclxuICAgICAgICAgICAgaWYgKHdlZWsgPiB3ZWVrc1RhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgd2VlayA9IHdlZWtzVGFyZ2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzZXRXZWVrQWxsLmNhbGwodGhpcywgaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0V2Vla0FsbCh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcclxuICAgICAgICB2YXIgZGF5T2ZZZWFyRGF0YSA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpLFxyXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcclxuXHJcbiAgICAgICAgdGhpcy55ZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XHJcbiAgICAgICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xyXG4gICAgICAgIHRoaXMuZGF0ZShkYXRlLmdldFVUQ0RhdGUoKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRk9STUFUVElOR1xyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKCdRJywgMCwgJ1FvJywgJ3F1YXJ0ZXInKTtcclxuXHJcbiAgICAvLyBBTElBU0VTXHJcblxyXG4gICAgYWRkVW5pdEFsaWFzKCdxdWFydGVyJywgJ1EnKTtcclxuXHJcbiAgICAvLyBQUklPUklUWVxyXG5cclxuICAgIGFkZFVuaXRQcmlvcml0eSgncXVhcnRlcicsIDcpO1xyXG5cclxuICAgIC8vIFBBUlNJTkdcclxuXHJcbiAgICBhZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcclxuICAgIGFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XHJcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIE1PTUVOVFNcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTZXRRdWFydGVyIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyB0aGlzLm1vbnRoKCkgJSAzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGT1JNQVRUSU5HXHJcblxyXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XHJcblxyXG4gICAgLy8gQUxJQVNFU1xyXG5cclxuICAgIGFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XHJcblxyXG4gICAgLy8gUFJJT1JJVFlcclxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF0ZScsIDkpO1xyXG5cclxuICAgIC8vIFBBUlNJTkdcclxuXHJcbiAgICBhZGRSZWdleFRva2VuKCdEJywgIG1hdGNoMXRvMik7XHJcbiAgICBhZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcclxuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXHJcbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID9cclxuICAgICAgICAgIChsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2UpIDpcclxuICAgICAgICAgIGxvY2FsZS5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQ7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZGRQYXJzZVRva2VuKFsnRCcsICdERCddLCBEQVRFKTtcclxuICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xyXG4gICAgICAgIGFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQubWF0Y2gobWF0Y2gxdG8yKVswXSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBNT01FTlRTXHJcblxyXG4gICAgdmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XHJcblxyXG4gICAgLy8gRk9STUFUVElOR1xyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XHJcblxyXG4gICAgLy8gQUxJQVNFU1xyXG5cclxuICAgIGFkZFVuaXRBbGlhcygnZGF5T2ZZZWFyJywgJ0RERCcpO1xyXG5cclxuICAgIC8vIFBSSU9SSVRZXHJcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RheU9mWWVhcicsIDQpO1xyXG5cclxuICAgIC8vIFBBUlNJTkdcclxuXHJcbiAgICBhZGRSZWdleFRva2VuKCdEREQnLCAgbWF0Y2gxdG8zKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xyXG4gICAgYWRkUGFyc2VUb2tlbihbJ0RERCcsICdEREREJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xyXG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSEVMUEVSU1xyXG5cclxuICAgIC8vIE1PTUVOVFNcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIgKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIGRheU9mWWVhciA9IE1hdGgucm91bmQoKHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKSAtIHRoaXMuY2xvbmUoKS5zdGFydE9mKCd5ZWFyJykpIC8gODY0ZTUpICsgMTtcclxuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIGRheU9mWWVhciksICdkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRk9STUFUVElOR1xyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKCdtJywgWydtbScsIDJdLCAwLCAnbWludXRlJyk7XHJcblxyXG4gICAgLy8gQUxJQVNFU1xyXG5cclxuICAgIGFkZFVuaXRBbGlhcygnbWludXRlJywgJ20nKTtcclxuXHJcbiAgICAvLyBQUklPUklUWVxyXG5cclxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWludXRlJywgMTQpO1xyXG5cclxuICAgIC8vIFBBUlNJTkdcclxuXHJcbiAgICBhZGRSZWdleFRva2VuKCdtJywgIG1hdGNoMXRvMik7XHJcbiAgICBhZGRSZWdleFRva2VuKCdtbScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcclxuICAgIGFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XHJcblxyXG4gICAgLy8gTU9NRU5UU1xyXG5cclxuICAgIHZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xyXG5cclxuICAgIC8vIEZPUk1BVFRJTkdcclxuXHJcbiAgICBhZGRGb3JtYXRUb2tlbigncycsIFsnc3MnLCAyXSwgMCwgJ3NlY29uZCcpO1xyXG5cclxuICAgIC8vIEFMSUFTRVNcclxuXHJcbiAgICBhZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XHJcblxyXG4gICAgLy8gUFJJT1JJVFlcclxuXHJcbiAgICBhZGRVbml0UHJpb3JpdHkoJ3NlY29uZCcsIDE1KTtcclxuXHJcbiAgICAvLyBQQVJTSU5HXHJcblxyXG4gICAgYWRkUmVnZXhUb2tlbigncycsICBtYXRjaDF0bzIpO1xyXG4gICAgYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XHJcbiAgICBhZGRQYXJzZVRva2VuKFsncycsICdzcyddLCBTRUNPTkQpO1xyXG5cclxuICAgIC8vIE1PTUVOVFNcclxuXHJcbiAgICB2YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcclxuXHJcbiAgICAvLyBGT1JNQVRUSU5HXHJcblxyXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwMCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XHJcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDtcclxuICAgIH0pO1xyXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDtcclxuICAgIH0pO1xyXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwO1xyXG4gICAgfSk7XHJcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDtcclxuICAgIH0pO1xyXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDtcclxuICAgIH0pO1xyXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDAwO1xyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIC8vIEFMSUFTRVNcclxuXHJcbiAgICBhZGRVbml0QWxpYXMoJ21pbGxpc2Vjb25kJywgJ21zJyk7XHJcblxyXG4gICAgLy8gUFJJT1JJVFlcclxuXHJcbiAgICBhZGRVbml0UHJpb3JpdHkoJ21pbGxpc2Vjb25kJywgMTYpO1xyXG5cclxuICAgIC8vIFBBUlNJTkdcclxuXHJcbiAgICBhZGRSZWdleFRva2VuKCdTJywgICAgbWF0Y2gxdG8zLCBtYXRjaDEpO1xyXG4gICAgYWRkUmVnZXhUb2tlbignU1MnLCAgIG1hdGNoMXRvMywgbWF0Y2gyKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTUycsICBtYXRjaDF0bzMsIG1hdGNoMyk7XHJcblxyXG4gICAgdmFyIHRva2VuO1xyXG4gICAgZm9yICh0b2tlbiA9ICdTU1NTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xyXG4gICAgICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XHJcbiAgICAgICAgYXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHRva2VuID0gJ1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XHJcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgcGFyc2VNcyk7XHJcbiAgICB9XHJcbiAgICAvLyBNT01FTlRTXHJcblxyXG4gICAgdmFyIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xyXG5cclxuICAgIC8vIEZPUk1BVFRJTkdcclxuXHJcbiAgICBhZGRGb3JtYXRUb2tlbigneicsICAwLCAwLCAnem9uZUFiYnInKTtcclxuICAgIGFkZEZvcm1hdFRva2VuKCd6eicsIDAsIDAsICd6b25lTmFtZScpO1xyXG5cclxuICAgIC8vIE1PTUVOVFNcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRab25lQWJiciAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRab25lTmFtZSAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwcm90byA9IE1vbWVudC5wcm90b3R5cGU7XHJcblxyXG4gICAgcHJvdG8uYWRkICAgICAgICAgICAgICAgPSBhZGQ7XHJcbiAgICBwcm90by5jYWxlbmRhciAgICAgICAgICA9IGNhbGVuZGFyJDE7XHJcbiAgICBwcm90by5jbG9uZSAgICAgICAgICAgICA9IGNsb25lO1xyXG4gICAgcHJvdG8uZGlmZiAgICAgICAgICAgICAgPSBkaWZmO1xyXG4gICAgcHJvdG8uZW5kT2YgICAgICAgICAgICAgPSBlbmRPZjtcclxuICAgIHByb3RvLmZvcm1hdCAgICAgICAgICAgID0gZm9ybWF0O1xyXG4gICAgcHJvdG8uZnJvbSAgICAgICAgICAgICAgPSBmcm9tO1xyXG4gICAgcHJvdG8uZnJvbU5vdyAgICAgICAgICAgPSBmcm9tTm93O1xyXG4gICAgcHJvdG8udG8gICAgICAgICAgICAgICAgPSB0bztcclxuICAgIHByb3RvLnRvTm93ICAgICAgICAgICAgID0gdG9Ob3c7XHJcbiAgICBwcm90by5nZXQgICAgICAgICAgICAgICA9IHN0cmluZ0dldDtcclxuICAgIHByb3RvLmludmFsaWRBdCAgICAgICAgID0gaW52YWxpZEF0O1xyXG4gICAgcHJvdG8uaXNBZnRlciAgICAgICAgICAgPSBpc0FmdGVyO1xyXG4gICAgcHJvdG8uaXNCZWZvcmUgICAgICAgICAgPSBpc0JlZm9yZTtcclxuICAgIHByb3RvLmlzQmV0d2VlbiAgICAgICAgID0gaXNCZXR3ZWVuO1xyXG4gICAgcHJvdG8uaXNTYW1lICAgICAgICAgICAgPSBpc1NhbWU7XHJcbiAgICBwcm90by5pc1NhbWVPckFmdGVyICAgICA9IGlzU2FtZU9yQWZ0ZXI7XHJcbiAgICBwcm90by5pc1NhbWVPckJlZm9yZSAgICA9IGlzU2FtZU9yQmVmb3JlO1xyXG4gICAgcHJvdG8uaXNWYWxpZCAgICAgICAgICAgPSBpc1ZhbGlkJDI7XHJcbiAgICBwcm90by5sYW5nICAgICAgICAgICAgICA9IGxhbmc7XHJcbiAgICBwcm90by5sb2NhbGUgICAgICAgICAgICA9IGxvY2FsZTtcclxuICAgIHByb3RvLmxvY2FsZURhdGEgICAgICAgID0gbG9jYWxlRGF0YTtcclxuICAgIHByb3RvLm1heCAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWF4O1xyXG4gICAgcHJvdG8ubWluICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNaW47XHJcbiAgICBwcm90by5wYXJzaW5nRmxhZ3MgICAgICA9IHBhcnNpbmdGbGFncztcclxuICAgIHByb3RvLnNldCAgICAgICAgICAgICAgID0gc3RyaW5nU2V0O1xyXG4gICAgcHJvdG8uc3RhcnRPZiAgICAgICAgICAgPSBzdGFydE9mO1xyXG4gICAgcHJvdG8uc3VidHJhY3QgICAgICAgICAgPSBzdWJ0cmFjdDtcclxuICAgIHByb3RvLnRvQXJyYXkgICAgICAgICAgID0gdG9BcnJheTtcclxuICAgIHByb3RvLnRvT2JqZWN0ICAgICAgICAgID0gdG9PYmplY3Q7XHJcbiAgICBwcm90by50b0RhdGUgICAgICAgICAgICA9IHRvRGF0ZTtcclxuICAgIHByb3RvLnRvSVNPU3RyaW5nICAgICAgID0gdG9JU09TdHJpbmc7XHJcbiAgICBwcm90by5pbnNwZWN0ICAgICAgICAgICA9IGluc3BlY3Q7XHJcbiAgICBwcm90by50b0pTT04gICAgICAgICAgICA9IHRvSlNPTjtcclxuICAgIHByb3RvLnRvU3RyaW5nICAgICAgICAgID0gdG9TdHJpbmc7XHJcbiAgICBwcm90by51bml4ICAgICAgICAgICAgICA9IHVuaXg7XHJcbiAgICBwcm90by52YWx1ZU9mICAgICAgICAgICA9IHZhbHVlT2Y7XHJcbiAgICBwcm90by5jcmVhdGlvbkRhdGEgICAgICA9IGNyZWF0aW9uRGF0YTtcclxuICAgIHByb3RvLnllYXIgICAgICAgPSBnZXRTZXRZZWFyO1xyXG4gICAgcHJvdG8uaXNMZWFwWWVhciA9IGdldElzTGVhcFllYXI7XHJcbiAgICBwcm90by53ZWVrWWVhciAgICA9IGdldFNldFdlZWtZZWFyO1xyXG4gICAgcHJvdG8uaXNvV2Vla1llYXIgPSBnZXRTZXRJU09XZWVrWWVhcjtcclxuICAgIHByb3RvLnF1YXJ0ZXIgPSBwcm90by5xdWFydGVycyA9IGdldFNldFF1YXJ0ZXI7XHJcbiAgICBwcm90by5tb250aCAgICAgICA9IGdldFNldE1vbnRoO1xyXG4gICAgcHJvdG8uZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aDtcclxuICAgIHByb3RvLndlZWsgICAgICAgICAgID0gcHJvdG8ud2Vla3MgICAgICAgID0gZ2V0U2V0V2VlaztcclxuICAgIHByb3RvLmlzb1dlZWsgICAgICAgID0gcHJvdG8uaXNvV2Vla3MgICAgID0gZ2V0U2V0SVNPV2VlaztcclxuICAgIHByb3RvLndlZWtzSW5ZZWFyICAgID0gZ2V0V2Vla3NJblllYXI7XHJcbiAgICBwcm90by5pc29XZWVrc0luWWVhciA9IGdldElTT1dlZWtzSW5ZZWFyO1xyXG4gICAgcHJvdG8uZGF0ZSAgICAgICA9IGdldFNldERheU9mTW9udGg7XHJcbiAgICBwcm90by5kYXkgICAgICAgID0gcHJvdG8uZGF5cyAgICAgICAgICAgICA9IGdldFNldERheU9mV2VlaztcclxuICAgIHByb3RvLndlZWtkYXkgICAgPSBnZXRTZXRMb2NhbGVEYXlPZldlZWs7XHJcbiAgICBwcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xyXG4gICAgcHJvdG8uZGF5T2ZZZWFyICA9IGdldFNldERheU9mWWVhcjtcclxuICAgIHByb3RvLmhvdXIgPSBwcm90by5ob3VycyA9IGdldFNldEhvdXI7XHJcbiAgICBwcm90by5taW51dGUgPSBwcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xyXG4gICAgcHJvdG8uc2Vjb25kID0gcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcclxuICAgIHByb3RvLm1pbGxpc2Vjb25kID0gcHJvdG8ubWlsbGlzZWNvbmRzID0gZ2V0U2V0TWlsbGlzZWNvbmQ7XHJcbiAgICBwcm90by51dGNPZmZzZXQgICAgICAgICAgICA9IGdldFNldE9mZnNldDtcclxuICAgIHByb3RvLnV0YyAgICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9VVEM7XHJcbiAgICBwcm90by5sb2NhbCAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvTG9jYWw7XHJcbiAgICBwcm90by5wYXJzZVpvbmUgICAgICAgICAgICA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xyXG4gICAgcHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcclxuICAgIHByb3RvLmlzRFNUICAgICAgICAgICAgICAgID0gaXNEYXlsaWdodFNhdmluZ1RpbWU7XHJcbiAgICBwcm90by5pc0xvY2FsICAgICAgICAgICAgICA9IGlzTG9jYWw7XHJcbiAgICBwcm90by5pc1V0Y09mZnNldCAgICAgICAgICA9IGlzVXRjT2Zmc2V0O1xyXG4gICAgcHJvdG8uaXNVdGMgICAgICAgICAgICAgICAgPSBpc1V0YztcclxuICAgIHByb3RvLmlzVVRDICAgICAgICAgICAgICAgID0gaXNVdGM7XHJcbiAgICBwcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xyXG4gICAgcHJvdG8uem9uZU5hbWUgPSBnZXRab25lTmFtZTtcclxuICAgIHByb3RvLmRhdGVzICA9IGRlcHJlY2F0ZSgnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLCBnZXRTZXREYXlPZk1vbnRoKTtcclxuICAgIHByb3RvLm1vbnRocyA9IGRlcHJlY2F0ZSgnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJywgZ2V0U2V0TW9udGgpO1xyXG4gICAgcHJvdG8ueWVhcnMgID0gZGVwcmVjYXRlKCd5ZWFycyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgeWVhciBpbnN0ZWFkJywgZ2V0U2V0WWVhcik7XHJcbiAgICBwcm90by56b25lICAgPSBkZXByZWNhdGUoJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL3pvbmUvJywgZ2V0U2V0Wm9uZSk7XHJcbiAgICBwcm90by5pc0RTVFNoaWZ0ZWQgPSBkZXByZWNhdGUoJ2lzRFNUU2hpZnRlZCBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kc3Qtc2hpZnRlZC8gZm9yIG1vcmUgaW5mb3JtYXRpb24nLCBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVuaXggKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5ab25lICgpIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcmVQYXJzZVBvc3RGb3JtYXQgKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHByb3RvJDEgPSBMb2NhbGUucHJvdG90eXBlO1xyXG5cclxuICAgIHByb3RvJDEuY2FsZW5kYXIgICAgICAgID0gY2FsZW5kYXI7XHJcbiAgICBwcm90byQxLmxvbmdEYXRlRm9ybWF0ICA9IGxvbmdEYXRlRm9ybWF0O1xyXG4gICAgcHJvdG8kMS5pbnZhbGlkRGF0ZSAgICAgPSBpbnZhbGlkRGF0ZTtcclxuICAgIHByb3RvJDEub3JkaW5hbCAgICAgICAgID0gb3JkaW5hbDtcclxuICAgIHByb3RvJDEucHJlcGFyc2UgICAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xyXG4gICAgcHJvdG8kMS5wb3N0Zm9ybWF0ICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XHJcbiAgICBwcm90byQxLnJlbGF0aXZlVGltZSAgICA9IHJlbGF0aXZlVGltZTtcclxuICAgIHByb3RvJDEucGFzdEZ1dHVyZSAgICAgID0gcGFzdEZ1dHVyZTtcclxuICAgIHByb3RvJDEuc2V0ICAgICAgICAgICAgID0gc2V0O1xyXG5cclxuICAgIHByb3RvJDEubW9udGhzICAgICAgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzO1xyXG4gICAgcHJvdG8kMS5tb250aHNTaG9ydCAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNTaG9ydDtcclxuICAgIHByb3RvJDEubW9udGhzUGFyc2UgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzUGFyc2U7XHJcbiAgICBwcm90byQxLm1vbnRoc1JlZ2V4ICAgICAgID0gbW9udGhzUmVnZXg7XHJcbiAgICBwcm90byQxLm1vbnRoc1Nob3J0UmVnZXggID0gbW9udGhzU2hvcnRSZWdleDtcclxuICAgIHByb3RvJDEud2VlayA9IGxvY2FsZVdlZWs7XHJcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XHJcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlRmlyc3REYXlPZldlZWs7XHJcblxyXG4gICAgcHJvdG8kMS53ZWVrZGF5cyAgICAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5cztcclxuICAgIHByb3RvJDEud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XHJcbiAgICBwcm90byQxLndlZWtkYXlzU2hvcnQgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzU2hvcnQ7XHJcbiAgICBwcm90byQxLndlZWtkYXlzUGFyc2UgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzUGFyc2U7XHJcblxyXG4gICAgcHJvdG8kMS53ZWVrZGF5c1JlZ2V4ICAgICAgID0gICAgICAgIHdlZWtkYXlzUmVnZXg7XHJcbiAgICBwcm90byQxLndlZWtkYXlzU2hvcnRSZWdleCAgPSAgICAgICAgd2Vla2RheXNTaG9ydFJlZ2V4O1xyXG4gICAgcHJvdG8kMS53ZWVrZGF5c01pblJlZ2V4ICAgID0gICAgICAgIHdlZWtkYXlzTWluUmVnZXg7XHJcblxyXG4gICAgcHJvdG8kMS5pc1BNID0gbG9jYWxlSXNQTTtcclxuICAgIHByb3RvJDEubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXQkMSAoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xyXG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKTtcclxuICAgICAgICB2YXIgdXRjID0gY3JlYXRlVVRDKCkuc2V0KHNldHRlciwgaW5kZXgpO1xyXG4gICAgICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzSW1wbCAoZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcclxuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xyXG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcclxuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xyXG5cclxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCBpbmRleCwgZmllbGQsICdtb250aCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIG91dCA9IFtdO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XHJcbiAgICAgICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgaSwgZmllbGQsICdtb250aCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vICgpXHJcbiAgICAvLyAoNSlcclxuICAgIC8vIChmbXQsIDUpXHJcbiAgICAvLyAoZm10KVxyXG4gICAgLy8gKHRydWUpXHJcbiAgICAvLyAodHJ1ZSwgNSlcclxuICAgIC8vICh0cnVlLCBmbXQsIDUpXHJcbiAgICAvLyAodHJ1ZSwgZm10KVxyXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzSW1wbCAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxlU29ydGVkID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9ybWF0ID0gbG9jYWxlU29ydGVkO1xyXG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcclxuICAgICAgICAgICAgbG9jYWxlU29ydGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcclxuICAgICAgICAgICAgc2hpZnQgPSBsb2NhbGVTb3J0ZWQgPyBsb2NhbGUuX3dlZWsuZG93IDogMDtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgKGluZGV4ICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBvdXQgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XHJcbiAgICAgICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgKGkgKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHMgKGZvcm1hdCwgaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRocycpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHNTaG9ydCAoZm9ybWF0LCBpbmRleCkge1xyXG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXMgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xyXG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzU2hvcnQgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xyXG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzU2hvcnQnKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNNaW4gKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xyXG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U2V0R2xvYmFsTG9jYWxlKCdlbicsIHtcclxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcclxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xyXG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxyXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRvSW50KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcclxuICAgICAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxyXG4gICAgICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XHJcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXHJcblxyXG4gICAgaG9va3MubGFuZyA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmcgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGUgaW5zdGVhZC4nLCBnZXRTZXRHbG9iYWxMb2NhbGUpO1xyXG4gICAgaG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nRGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZURhdGEgaW5zdGVhZC4nLCBnZXRMb2NhbGUpO1xyXG5cclxuICAgIHZhciBtYXRoQWJzID0gTWF0aC5hYnM7XHJcblxyXG4gICAgZnVuY3Rpb24gYWJzICgpIHtcclxuICAgICAgICB2YXIgZGF0YSAgICAgICAgICAgPSB0aGlzLl9kYXRhO1xyXG5cclxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XHJcbiAgICAgICAgdGhpcy5fZGF5cyAgICAgICAgID0gbWF0aEFicyh0aGlzLl9kYXlzKTtcclxuICAgICAgICB0aGlzLl9tb250aHMgICAgICAgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XHJcblxyXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzICA9IG1hdGhBYnMoZGF0YS5taWxsaXNlY29uZHMpO1xyXG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgICA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcclxuICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICAgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XHJcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcclxuICAgICAgICBkYXRhLm1vbnRocyAgICAgICAgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcclxuICAgICAgICBkYXRhLnllYXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdCQxIChkdXJhdGlvbiwgaW5wdXQsIHZhbHVlLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xyXG5cclxuICAgICAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XHJcbiAgICAgICAgZHVyYXRpb24uX2RheXMgICAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fZGF5cztcclxuICAgICAgICBkdXJhdGlvbi5fbW9udGhzICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9tb250aHM7XHJcblxyXG4gICAgICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxyXG4gICAgZnVuY3Rpb24gYWRkJDEgKGlucHV0LCB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcclxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0JDEgKGlucHV0LCB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgLTEpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFic0NlaWwgKG51bWJlcikge1xyXG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBidWJibGUgKCkge1xyXG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XHJcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IHRoaXMuX2RheXM7XHJcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IHRoaXMuX21vbnRocztcclxuICAgICAgICB2YXIgZGF0YSAgICAgICAgID0gdGhpcy5fZGF0YTtcclxuICAgICAgICB2YXIgc2Vjb25kcywgbWludXRlcywgaG91cnMsIHllYXJzLCBtb250aHNGcm9tRGF5cztcclxuXHJcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIG1peCBvZiBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgdmFsdWVzLCBidWJibGUgZG93biBmaXJzdFxyXG4gICAgICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxyXG4gICAgICAgIGlmICghKChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XHJcbiAgICAgICAgICAgICAgICAobWlsbGlzZWNvbmRzIDw9IDAgJiYgZGF5cyA8PSAwICYmIG1vbnRocyA8PSAwKSkpIHtcclxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xyXG4gICAgICAgICAgICBkYXlzID0gMDtcclxuICAgICAgICAgICAgbW9udGhzID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcclxuICAgICAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXHJcbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xyXG5cclxuICAgICAgICBzZWNvbmRzICAgICAgICAgICA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xyXG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgID0gc2Vjb25kcyAlIDYwO1xyXG5cclxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XHJcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgPSBtaW51dGVzICUgNjA7XHJcblxyXG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcclxuICAgICAgICBkYXRhLmhvdXJzICAgICAgICA9IGhvdXJzICUgMjQ7XHJcblxyXG4gICAgICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XHJcblxyXG4gICAgICAgIC8vIGNvbnZlcnQgZGF5cyB0byBtb250aHNcclxuICAgICAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XHJcbiAgICAgICAgbW9udGhzICs9IG1vbnRoc0Zyb21EYXlzO1xyXG4gICAgICAgIGRheXMgLT0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzRnJvbURheXMpKTtcclxuXHJcbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxyXG4gICAgICAgIHllYXJzID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xyXG4gICAgICAgIG1vbnRocyAlPSAxMjtcclxuXHJcbiAgICAgICAgZGF0YS5kYXlzICAgPSBkYXlzO1xyXG4gICAgICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xyXG4gICAgICAgIGRhdGEueWVhcnMgID0geWVhcnM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRheXNUb01vbnRocyAoZGF5cykge1xyXG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcclxuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxMiBtb250aHMgPT09IDQ4MDBcclxuICAgICAgICByZXR1cm4gZGF5cyAqIDQ4MDAgLyAxNDYwOTc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbW9udGhzVG9EYXlzIChtb250aHMpIHtcclxuICAgICAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcclxuICAgICAgICByZXR1cm4gbW9udGhzICogMTQ2MDk3IC8gNDgwMDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhcyAodW5pdHMpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkYXlzO1xyXG4gICAgICAgIHZhciBtb250aHM7XHJcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcclxuXHJcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XHJcblxyXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3llYXInKSB7XHJcbiAgICAgICAgICAgIGRheXMgICA9IHRoaXMuX2RheXMgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xyXG4gICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMgKyBkYXlzVG9Nb250aHMoZGF5cyk7XHJcbiAgICAgICAgICAgIHJldHVybiB1bml0cyA9PT0gJ21vbnRoJyA/IG1vbnRocyA6IG1vbnRocyAvIDEyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcclxuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBNYXRoLnJvdW5kKG1vbnRoc1RvRGF5cyh0aGlzLl9tb250aHMpKTtcclxuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnd2VlaycgICA6IHJldHVybiBkYXlzIC8gNyAgICAgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdkYXknICAgIDogcmV0dXJuIGRheXMgICAgICAgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnaG91cicgICA6IHJldHVybiBkYXlzICogMjQgICAgKyBtaWxsaXNlY29uZHMgLyAzNmU1O1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJyA6IHJldHVybiBkYXlzICogMTQ0MCAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzZWNvbmQnIDogcmV0dXJuIGRheXMgKiA4NjQwMCArIG1pbGxpc2Vjb25kcyAvIDEwMDA7XHJcbiAgICAgICAgICAgICAgICAvLyBNYXRoLmZsb29yIHByZXZlbnRzIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIGhlcmVcclxuICAgICAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignVW5rbm93biB1bml0ICcgKyB1bml0cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XHJcbiAgICBmdW5jdGlvbiB2YWx1ZU9mJDEgKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcclxuICAgICAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcclxuICAgICAgICAgICAgKHRoaXMuX21vbnRocyAlIDEyKSAqIDI1OTJlNiArXHJcbiAgICAgICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1ha2VBcyAoYWxpYXMpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYXNNaWxsaXNlY29uZHMgPSBtYWtlQXMoJ21zJyk7XHJcbiAgICB2YXIgYXNTZWNvbmRzICAgICAgPSBtYWtlQXMoJ3MnKTtcclxuICAgIHZhciBhc01pbnV0ZXMgICAgICA9IG1ha2VBcygnbScpO1xyXG4gICAgdmFyIGFzSG91cnMgICAgICAgID0gbWFrZUFzKCdoJyk7XHJcbiAgICB2YXIgYXNEYXlzICAgICAgICAgPSBtYWtlQXMoJ2QnKTtcclxuICAgIHZhciBhc1dlZWtzICAgICAgICA9IG1ha2VBcygndycpO1xyXG4gICAgdmFyIGFzTW9udGhzICAgICAgID0gbWFrZUFzKCdNJyk7XHJcbiAgICB2YXIgYXNZZWFycyAgICAgICAgPSBtYWtlQXMoJ3knKTtcclxuXHJcbiAgICBmdW5jdGlvbiBjbG9uZSQxICgpIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24odGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0JDIgKHVuaXRzKSB7XHJcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpc1t1bml0cyArICdzJ10oKSA6IE5hTjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtYWtlR2V0dGVyKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9kYXRhW25hbWVdIDogTmFOO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ21pbGxpc2Vjb25kcycpO1xyXG4gICAgdmFyIHNlY29uZHMgICAgICA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKTtcclxuICAgIHZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XHJcbiAgICB2YXIgaG91cnMgICAgICAgID0gbWFrZUdldHRlcignaG91cnMnKTtcclxuICAgIHZhciBkYXlzICAgICAgICAgPSBtYWtlR2V0dGVyKCdkYXlzJyk7XHJcbiAgICB2YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XHJcbiAgICB2YXIgeWVhcnMgICAgICAgID0gbWFrZUdldHRlcigneWVhcnMnKTtcclxuXHJcbiAgICBmdW5jdGlvbiB3ZWVrcyAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcclxuICAgIHZhciB0aHJlc2hvbGRzID0ge1xyXG4gICAgICAgIHNzOiA0NCwgICAgICAgICAvLyBhIGZldyBzZWNvbmRzIHRvIHNlY29uZHNcclxuICAgICAgICBzIDogNDUsICAgICAgICAgLy8gc2Vjb25kcyB0byBtaW51dGVcclxuICAgICAgICBtIDogNDUsICAgICAgICAgLy8gbWludXRlcyB0byBob3VyXHJcbiAgICAgICAgaCA6IDIyLCAgICAgICAgIC8vIGhvdXJzIHRvIGRheVxyXG4gICAgICAgIGQgOiAyNiwgICAgICAgICAvLyBkYXlzIHRvIG1vbnRoXHJcbiAgICAgICAgTSA6IDExICAgICAgICAgIC8vIG1vbnRocyB0byB5ZWFyXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXHJcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xyXG4gICAgICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSQxIChwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgbG9jYWxlKSB7XHJcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpO1xyXG4gICAgICAgIHZhciBzZWNvbmRzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpO1xyXG4gICAgICAgIHZhciBtaW51dGVzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpO1xyXG4gICAgICAgIHZhciBob3VycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpO1xyXG4gICAgICAgIHZhciBkYXlzICAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpO1xyXG4gICAgICAgIHZhciBtb250aHMgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpO1xyXG4gICAgICAgIHZhciB5ZWFycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpO1xyXG5cclxuICAgICAgICB2YXIgYSA9IHNlY29uZHMgPD0gdGhyZXNob2xkcy5zcyAmJiBbJ3MnLCBzZWNvbmRzXSAgfHxcclxuICAgICAgICAgICAgICAgIHNlY29uZHMgPCB0aHJlc2hvbGRzLnMgICAmJiBbJ3NzJywgc2Vjb25kc10gfHxcclxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPD0gMSAgICAgICAgICAgICAmJiBbJ20nXSAgICAgICAgICAgfHxcclxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPCB0aHJlc2hvbGRzLm0gICAmJiBbJ21tJywgbWludXRlc10gfHxcclxuICAgICAgICAgICAgICAgIGhvdXJzICAgPD0gMSAgICAgICAgICAgICAmJiBbJ2gnXSAgICAgICAgICAgfHxcclxuICAgICAgICAgICAgICAgIGhvdXJzICAgPCB0aHJlc2hvbGRzLmggICAmJiBbJ2hoJywgaG91cnNdICAgfHxcclxuICAgICAgICAgICAgICAgIGRheXMgICAgPD0gMSAgICAgICAgICAgICAmJiBbJ2QnXSAgICAgICAgICAgfHxcclxuICAgICAgICAgICAgICAgIGRheXMgICAgPCB0aHJlc2hvbGRzLmQgICAmJiBbJ2RkJywgZGF5c10gICAgfHxcclxuICAgICAgICAgICAgICAgIG1vbnRocyAgPD0gMSAgICAgICAgICAgICAmJiBbJ00nXSAgICAgICAgICAgfHxcclxuICAgICAgICAgICAgICAgIG1vbnRocyAgPCB0aHJlc2hvbGRzLk0gICAmJiBbJ01NJywgbW9udGhzXSAgfHxcclxuICAgICAgICAgICAgICAgIHllYXJzICAgPD0gMSAgICAgICAgICAgICAmJiBbJ3knXSAgICAgICAgICAgfHwgWyd5eScsIHllYXJzXTtcclxuXHJcbiAgICAgICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XHJcbiAgICAgICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XHJcbiAgICAgICAgYVs0XSA9IGxvY2FsZTtcclxuICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCB0aGUgcm91bmRpbmcgZnVuY3Rpb24gZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xyXG4gICAgZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmcgKHJvdW5kaW5nRnVuY3Rpb24pIHtcclxuICAgICAgICBpZiAocm91bmRpbmdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByb3VuZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZihyb3VuZGluZ0Z1bmN0aW9uKSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByb3VuZCA9IHJvdW5kaW5nRnVuY3Rpb247XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCBhIHRocmVzaG9sZCBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXHJcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQgKHRocmVzaG9sZCwgbGltaXQpIHtcclxuICAgICAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhyZXNob2xkc1t0aHJlc2hvbGRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcclxuICAgICAgICBpZiAodGhyZXNob2xkID09PSAncycpIHtcclxuICAgICAgICAgICAgdGhyZXNob2xkcy5zcyA9IGxpbWl0IC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaHVtYW5pemUgKHdpdGhTdWZmaXgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xyXG4gICAgICAgIHZhciBvdXRwdXQgPSByZWxhdGl2ZVRpbWUkMSh0aGlzLCAhd2l0aFN1ZmZpeCwgbG9jYWxlKTtcclxuXHJcbiAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcclxuICAgICAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYWJzJDEgPSBNYXRoLmFicztcclxuXHJcbiAgICBmdW5jdGlvbiBzaWduKHgpIHtcclxuICAgICAgICByZXR1cm4gKCh4ID4gMCkgLSAoeCA8IDApKSB8fCAreDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyQxKCkge1xyXG4gICAgICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XHJcbiAgICAgICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xyXG4gICAgICAgIC8vICAqIGRheXMgZG8gbm90IGJ1YmJsZSBhdCBhbGxcclxuICAgICAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXHJcbiAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcclxuICAgICAgICAvLyAodGhpbmsgb2YgY2xvY2sgY2hhbmdlcylcclxuICAgICAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxyXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc2Vjb25kcyA9IGFicyQxKHRoaXMuX21pbGxpc2Vjb25kcykgLyAxMDAwO1xyXG4gICAgICAgIHZhciBkYXlzICAgICAgICAgPSBhYnMkMSh0aGlzLl9kYXlzKTtcclxuICAgICAgICB2YXIgbW9udGhzICAgICAgID0gYWJzJDEodGhpcy5fbW9udGhzKTtcclxuICAgICAgICB2YXIgbWludXRlcywgaG91cnMsIHllYXJzO1xyXG5cclxuICAgICAgICAvLyAzNjAwIHNlY29uZHMgLT4gNjAgbWludXRlcyAtPiAxIGhvdXJcclxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XHJcbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xyXG4gICAgICAgIHNlY29uZHMgJT0gNjA7XHJcbiAgICAgICAgbWludXRlcyAlPSA2MDtcclxuXHJcbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxyXG4gICAgICAgIHllYXJzICA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcclxuICAgICAgICBtb250aHMgJT0gMTI7XHJcblxyXG5cclxuICAgICAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xyXG4gICAgICAgIHZhciBZID0geWVhcnM7XHJcbiAgICAgICAgdmFyIE0gPSBtb250aHM7XHJcbiAgICAgICAgdmFyIEQgPSBkYXlzO1xyXG4gICAgICAgIHZhciBoID0gaG91cnM7XHJcbiAgICAgICAgdmFyIG0gPSBtaW51dGVzO1xyXG4gICAgICAgIHZhciBzID0gc2Vjb25kcyA/IHNlY29uZHMudG9GaXhlZCgzKS5yZXBsYWNlKC9cXC4/MCskLywgJycpIDogJyc7XHJcbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5hc1NlY29uZHMoKTtcclxuXHJcbiAgICAgICAgaWYgKCF0b3RhbCkge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXHJcbiAgICAgICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcclxuICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRvdGFsU2lnbiA9IHRvdGFsIDwgMCA/ICctJyA6ICcnO1xyXG4gICAgICAgIHZhciB5bVNpZ24gPSBzaWduKHRoaXMuX21vbnRocykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XHJcbiAgICAgICAgdmFyIGRheXNTaWduID0gc2lnbih0aGlzLl9kYXlzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcclxuICAgICAgICB2YXIgaG1zU2lnbiA9IHNpZ24odGhpcy5fbWlsbGlzZWNvbmRzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRvdGFsU2lnbiArICdQJyArXHJcbiAgICAgICAgICAgIChZID8geW1TaWduICsgWSArICdZJyA6ICcnKSArXHJcbiAgICAgICAgICAgIChNID8geW1TaWduICsgTSArICdNJyA6ICcnKSArXHJcbiAgICAgICAgICAgIChEID8gZGF5c1NpZ24gKyBEICsgJ0QnIDogJycpICtcclxuICAgICAgICAgICAgKChoIHx8IG0gfHwgcykgPyAnVCcgOiAnJykgK1xyXG4gICAgICAgICAgICAoaCA/IGhtc1NpZ24gKyBoICsgJ0gnIDogJycpICtcclxuICAgICAgICAgICAgKG0gPyBobXNTaWduICsgbSArICdNJyA6ICcnKSArXHJcbiAgICAgICAgICAgIChzID8gaG1zU2lnbiArIHMgKyAnUycgOiAnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHByb3RvJDIgPSBEdXJhdGlvbi5wcm90b3R5cGU7XHJcblxyXG4gICAgcHJvdG8kMi5pc1ZhbGlkICAgICAgICA9IGlzVmFsaWQkMTtcclxuICAgIHByb3RvJDIuYWJzICAgICAgICAgICAgPSBhYnM7XHJcbiAgICBwcm90byQyLmFkZCAgICAgICAgICAgID0gYWRkJDE7XHJcbiAgICBwcm90byQyLnN1YnRyYWN0ICAgICAgID0gc3VidHJhY3QkMTtcclxuICAgIHByb3RvJDIuYXMgICAgICAgICAgICAgPSBhcztcclxuICAgIHByb3RvJDIuYXNNaWxsaXNlY29uZHMgPSBhc01pbGxpc2Vjb25kcztcclxuICAgIHByb3RvJDIuYXNTZWNvbmRzICAgICAgPSBhc1NlY29uZHM7XHJcbiAgICBwcm90byQyLmFzTWludXRlcyAgICAgID0gYXNNaW51dGVzO1xyXG4gICAgcHJvdG8kMi5hc0hvdXJzICAgICAgICA9IGFzSG91cnM7XHJcbiAgICBwcm90byQyLmFzRGF5cyAgICAgICAgID0gYXNEYXlzO1xyXG4gICAgcHJvdG8kMi5hc1dlZWtzICAgICAgICA9IGFzV2Vla3M7XHJcbiAgICBwcm90byQyLmFzTW9udGhzICAgICAgID0gYXNNb250aHM7XHJcbiAgICBwcm90byQyLmFzWWVhcnMgICAgICAgID0gYXNZZWFycztcclxuICAgIHByb3RvJDIudmFsdWVPZiAgICAgICAgPSB2YWx1ZU9mJDE7XHJcbiAgICBwcm90byQyLl9idWJibGUgICAgICAgID0gYnViYmxlO1xyXG4gICAgcHJvdG8kMi5jbG9uZSAgICAgICAgICA9IGNsb25lJDE7XHJcbiAgICBwcm90byQyLmdldCAgICAgICAgICAgID0gZ2V0JDI7XHJcbiAgICBwcm90byQyLm1pbGxpc2Vjb25kcyAgID0gbWlsbGlzZWNvbmRzO1xyXG4gICAgcHJvdG8kMi5zZWNvbmRzICAgICAgICA9IHNlY29uZHM7XHJcbiAgICBwcm90byQyLm1pbnV0ZXMgICAgICAgID0gbWludXRlcztcclxuICAgIHByb3RvJDIuaG91cnMgICAgICAgICAgPSBob3VycztcclxuICAgIHByb3RvJDIuZGF5cyAgICAgICAgICAgPSBkYXlzO1xyXG4gICAgcHJvdG8kMi53ZWVrcyAgICAgICAgICA9IHdlZWtzO1xyXG4gICAgcHJvdG8kMi5tb250aHMgICAgICAgICA9IG1vbnRocztcclxuICAgIHByb3RvJDIueWVhcnMgICAgICAgICAgPSB5ZWFycztcclxuICAgIHByb3RvJDIuaHVtYW5pemUgICAgICAgPSBodW1hbml6ZTtcclxuICAgIHByb3RvJDIudG9JU09TdHJpbmcgICAgPSB0b0lTT1N0cmluZyQxO1xyXG4gICAgcHJvdG8kMi50b1N0cmluZyAgICAgICA9IHRvSVNPU3RyaW5nJDE7XHJcbiAgICBwcm90byQyLnRvSlNPTiAgICAgICAgID0gdG9JU09TdHJpbmckMTtcclxuICAgIHByb3RvJDIubG9jYWxlICAgICAgICAgPSBsb2NhbGU7XHJcbiAgICBwcm90byQyLmxvY2FsZURhdGEgICAgID0gbG9jYWxlRGF0YTtcclxuXHJcbiAgICBwcm90byQyLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKCd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsIHRvSVNPU3RyaW5nJDEpO1xyXG4gICAgcHJvdG8kMi5sYW5nID0gbGFuZztcclxuXHJcbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXHJcblxyXG4gICAgLy8gRk9STUFUVElOR1xyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcclxuICAgIGFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcclxuXHJcbiAgICAvLyBQQVJTSU5HXHJcblxyXG4gICAgYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XHJcbiAgICBhZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XHJcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCwgMTApICogMTAwMCk7XHJcbiAgICB9KTtcclxuICAgIGFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcclxuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xyXG5cclxuXHJcbiAgICBob29rcy52ZXJzaW9uID0gJzIuMjIuMic7XHJcblxyXG4gICAgc2V0SG9va0NhbGxiYWNrKGNyZWF0ZUxvY2FsKTtcclxuXHJcbiAgICBob29rcy5mbiAgICAgICAgICAgICAgICAgICAgPSBwcm90bztcclxuICAgIGhvb2tzLm1pbiAgICAgICAgICAgICAgICAgICA9IG1pbjtcclxuICAgIGhvb2tzLm1heCAgICAgICAgICAgICAgICAgICA9IG1heDtcclxuICAgIGhvb2tzLm5vdyAgICAgICAgICAgICAgICAgICA9IG5vdztcclxuICAgIGhvb2tzLnV0YyAgICAgICAgICAgICAgICAgICA9IGNyZWF0ZVVUQztcclxuICAgIGhvb2tzLnVuaXggICAgICAgICAgICAgICAgICA9IGNyZWF0ZVVuaXg7XHJcbiAgICBob29rcy5tb250aHMgICAgICAgICAgICAgICAgPSBsaXN0TW9udGhzO1xyXG4gICAgaG9va3MuaXNEYXRlICAgICAgICAgICAgICAgID0gaXNEYXRlO1xyXG4gICAgaG9va3MubG9jYWxlICAgICAgICAgICAgICAgID0gZ2V0U2V0R2xvYmFsTG9jYWxlO1xyXG4gICAgaG9va3MuaW52YWxpZCAgICAgICAgICAgICAgID0gY3JlYXRlSW52YWxpZDtcclxuICAgIGhvb2tzLmR1cmF0aW9uICAgICAgICAgICAgICA9IGNyZWF0ZUR1cmF0aW9uO1xyXG4gICAgaG9va3MuaXNNb21lbnQgICAgICAgICAgICAgID0gaXNNb21lbnQ7XHJcbiAgICBob29rcy53ZWVrZGF5cyAgICAgICAgICAgICAgPSBsaXN0V2Vla2RheXM7XHJcbiAgICBob29rcy5wYXJzZVpvbmUgICAgICAgICAgICAgPSBjcmVhdGVJblpvbmU7XHJcbiAgICBob29rcy5sb2NhbGVEYXRhICAgICAgICAgICAgPSBnZXRMb2NhbGU7XHJcbiAgICBob29rcy5pc0R1cmF0aW9uICAgICAgICAgICAgPSBpc0R1cmF0aW9uO1xyXG4gICAgaG9va3MubW9udGhzU2hvcnQgICAgICAgICAgID0gbGlzdE1vbnRoc1Nob3J0O1xyXG4gICAgaG9va3Mud2Vla2RheXNNaW4gICAgICAgICAgID0gbGlzdFdlZWtkYXlzTWluO1xyXG4gICAgaG9va3MuZGVmaW5lTG9jYWxlICAgICAgICAgID0gZGVmaW5lTG9jYWxlO1xyXG4gICAgaG9va3MudXBkYXRlTG9jYWxlICAgICAgICAgID0gdXBkYXRlTG9jYWxlO1xyXG4gICAgaG9va3MubG9jYWxlcyAgICAgICAgICAgICAgID0gbGlzdExvY2FsZXM7XHJcbiAgICBob29rcy53ZWVrZGF5c1Nob3J0ICAgICAgICAgPSBsaXN0V2Vla2RheXNTaG9ydDtcclxuICAgIGhvb2tzLm5vcm1hbGl6ZVVuaXRzICAgICAgICA9IG5vcm1hbGl6ZVVuaXRzO1xyXG4gICAgaG9va3MucmVsYXRpdmVUaW1lUm91bmRpbmcgID0gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmc7XHJcbiAgICBob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQ7XHJcbiAgICBob29rcy5jYWxlbmRhckZvcm1hdCAgICAgICAgPSBnZXRDYWxlbmRhckZvcm1hdDtcclxuICAgIGhvb2tzLnByb3RvdHlwZSAgICAgICAgICAgICA9IHByb3RvO1xyXG5cclxuICAgIC8vIGN1cnJlbnRseSBIVE1MNSBpbnB1dCB0eXBlIG9ubHkgc3VwcG9ydHMgMjQtaG91ciBmb3JtYXRzXHJcbiAgICBob29rcy5IVE1MNV9GTVQgPSB7XHJcbiAgICAgICAgREFURVRJTUVfTE9DQUw6ICdZWVlZLU1NLUREVEhIOm1tJywgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIC8+XHJcbiAgICAgICAgREFURVRJTUVfTE9DQUxfU0VDT05EUzogJ1lZWVktTU0tRERUSEg6bW06c3MnLCAgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIxXCIgLz5cclxuICAgICAgICBEQVRFVElNRV9MT0NBTF9NUzogJ1lZWVktTU0tRERUSEg6bW06c3MuU1NTJywgICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjAuMDAxXCIgLz5cclxuICAgICAgICBEQVRFOiAnWVlZWS1NTS1ERCcsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cImRhdGVcIiAvPlxyXG4gICAgICAgIFRJTUU6ICdISDptbScsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIC8+XHJcbiAgICAgICAgVElNRV9TRUNPTkRTOiAnSEg6bW06c3MnLCAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgc3RlcD1cIjFcIiAvPlxyXG4gICAgICAgIFRJTUVfTVM6ICdISDptbTpzcy5TU1MnLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIwLjAwMVwiIC8+XHJcbiAgICAgICAgV0VFSzogJ1lZWVktW1ddV1cnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ3ZWVrXCIgLz5cclxuICAgICAgICBNT05USDogJ1lZWVktTU0nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cIm1vbnRoXCIgLz5cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIGhvb2tzO1xyXG5cclxufSkpKTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/moment.js\n");

/***/ }),

/***/ "./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/money_format_utils.js":
/*!****************************************************************************************************!*\
  !*** ./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/money_format_utils.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("// Copyright (c) 2014-2018, MyMonero.com\r\n//\r\n// All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without modification, are\r\n// permitted provided that the following conditions are met:\r\n//\r\n// 1. Redistributions of source code must retain the above copyright notice, this list of\r\n//\tconditions and the following disclaimer.\r\n//\r\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list\r\n//\tof conditions and the following disclaimer in the documentation and/or other\r\n//\tmaterials provided with the distribution.\r\n//\r\n// 3. Neither the name of the copyright holder nor the names of its contributors may be\r\n//\tused to endorse or promote products derived from this software without specific\r\n//\tprior written permission.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\r\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\r\n// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\r\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n//\r\nconst JSBigInt = __webpack_require__(/*! ./biginteger */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/biginteger.js\").BigInteger;\r\n//\r\nmodule.exports = function(currencyConfig)\r\n{\r\n\t// `currencyConfig` needs coinUnitPlaces, and coinSymbol\r\n\tvar config = {}; // shallow copy of initConfig\r\n\t{\r\n\t\tfor (var key in currencyConfig) {\r\n\t\t\tconfig[key] = currencyConfig[key];\r\n\t\t}\r\n\t\tconfig.coinUnits = new JSBigInt(10).pow(config.coinUnitPlaces);\r\n\t}\r\n\tthis.formatMoneyFull = function(units) {\r\n\t\tunits = units.toString();\r\n\t\tvar symbol = units[0] === \"-\" ? \"-\" : \"\";\r\n\t\tif (symbol === \"-\") {\r\n\t\t\tunits = units.slice(1);\r\n\t\t}\r\n\t\tvar decimal;\r\n\t\tif (units.length >= config.coinUnitPlaces) {\r\n\t\t\tdecimal = units.substr(\r\n\t\t\t\tunits.length - config.coinUnitPlaces,\r\n\t\t\t\tconfig.coinUnitPlaces\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\tdecimal = padLeft(units, config.coinUnitPlaces, \"0\");\r\n\t\t}\r\n\t\treturn (\r\n\t\t\tsymbol +\r\n\t\t\t(units.substr(0, units.length - config.coinUnitPlaces) || \"0\") +\r\n\t\t\t\".\" +\r\n\t\t\tdecimal\r\n\t\t);\r\n\t};\r\n\r\n\tthis.formatMoneyFullSymbol = function(units) {\r\n\t\treturn this.formatMoneyFull(units) + \" \" + config.coinSymbol;\r\n\t};\r\n\r\n\tfunction padLeft(str, len, char) {\r\n\t\twhile (str.length < len) str = char + str;\r\n\t\treturn str;\r\n\t}\r\n\tfunction trimRight(str, char) {\r\n\t\twhile (str[str.length - 1] == char) str = str.slice(0, -1);\r\n\t\treturn str;\r\n\t}\r\n\tthis.formatMoney = function(units) {\r\n\t\tvar f = trimRight(this.formatMoneyFull(units), \"0\");\r\n\t\tif (f[f.length - 1] === \".\") {\r\n\t\t\treturn f.slice(0, f.length - 1);\r\n\t\t}\r\n\t\treturn f;\r\n\t};\r\n\r\n\tthis.formatMoneySymbol = function(units) {\r\n\t\treturn this.formatMoney(units) + \" \" + config.coinSymbol;\r\n\t};\r\n\r\n\tthis.parseMoney = function(str) {\r\n\t\tif (!str) return JSBigInt.ZERO;\r\n\t\tvar negative = str[0] === \"-\";\r\n\t\tif (negative) {\r\n\t\t\tstr = str.slice(1);\r\n\t\t}\r\n\t\tvar decimalIndex = str.indexOf(\".\");\r\n\t\tif (decimalIndex == -1) {\r\n\t\t\tif (negative) {\r\n\t\t\t\treturn JSBigInt.multiply(str, config.coinUnits).negate();\r\n\t\t\t}\r\n\t\t\treturn JSBigInt.multiply(str, config.coinUnits);\r\n\t\t}\r\n\t\tif (decimalIndex + config.coinUnitPlaces + 1 < str.length) {\r\n\t\t\tstr = str.substr(0, decimalIndex + config.coinUnitPlaces + 1);\r\n\t\t}\r\n\t\tif (negative) {\r\n\t\t\treturn new JSBigInt(str.substr(0, decimalIndex))\r\n\t\t\t\t.exp10(config.coinUnitPlaces)\r\n\t\t\t\t.add(\r\n\t\t\t\t\tnew JSBigInt(str.substr(decimalIndex + 1)).exp10(\r\n\t\t\t\t\t\tdecimalIndex + config.coinUnitPlaces - str.length + 1,\r\n\t\t\t\t\t),\r\n\t\t\t\t).negate;\r\n\t\t}\r\n\t\treturn new JSBigInt(str.substr(0, decimalIndex))\r\n\t\t\t.exp10(config.coinUnitPlaces)\r\n\t\t\t.add(\r\n\t\t\t\tnew JSBigInt(str.substr(decimalIndex + 1)).exp10(\r\n\t\t\t\t\tdecimalIndex + config.coinUnitPlaces - str.length + 1,\r\n\t\t\t\t),\r\n\t\t\t);\r\n\t};\r\n\r\n\treturn this;\r\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvY3J5cHRvbm90ZV91dGlscy9tb25leV9mb3JtYXRfdXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvY3J5cHRvbm90ZV91dGlscy9tb25leV9mb3JtYXRfdXRpbHMuanM/NGJkNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxOCwgTXlNb25lcm8uY29tXHJcbi8vXHJcbi8vIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vXHJcbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZVxyXG4vLyBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuLy9cclxuLy8gMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2ZcclxuLy9cdGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuLy9cclxuLy8gMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3RcclxuLy9cdG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXJcclxuLy9cdG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbi8vXHJcbi8vIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGNvcHlyaWdodCBob2xkZXIgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZVxyXG4vL1x0dXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xyXG4vL1x0cHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4vL1xyXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkQgQU5ZXHJcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRlxyXG4vLyBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTFxyXG4vLyBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcclxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxyXG4vLyBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcclxuLy8gSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsXHJcbi8vIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxyXG4vLyBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbi8vXHJcbmNvbnN0IEpTQmlnSW50ID0gcmVxdWlyZShcIi4vYmlnaW50ZWdlclwiKS5CaWdJbnRlZ2VyO1xyXG4vL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGN1cnJlbmN5Q29uZmlnKVxyXG57XHJcblx0Ly8gYGN1cnJlbmN5Q29uZmlnYCBuZWVkcyBjb2luVW5pdFBsYWNlcywgYW5kIGNvaW5TeW1ib2xcclxuXHR2YXIgY29uZmlnID0ge307IC8vIHNoYWxsb3cgY29weSBvZiBpbml0Q29uZmlnXHJcblx0e1xyXG5cdFx0Zm9yICh2YXIga2V5IGluIGN1cnJlbmN5Q29uZmlnKSB7XHJcblx0XHRcdGNvbmZpZ1trZXldID0gY3VycmVuY3lDb25maWdba2V5XTtcclxuXHRcdH1cclxuXHRcdGNvbmZpZy5jb2luVW5pdHMgPSBuZXcgSlNCaWdJbnQoMTApLnBvdyhjb25maWcuY29pblVuaXRQbGFjZXMpO1xyXG5cdH1cclxuXHR0aGlzLmZvcm1hdE1vbmV5RnVsbCA9IGZ1bmN0aW9uKHVuaXRzKSB7XHJcblx0XHR1bml0cyA9IHVuaXRzLnRvU3RyaW5nKCk7XHJcblx0XHR2YXIgc3ltYm9sID0gdW5pdHNbMF0gPT09IFwiLVwiID8gXCItXCIgOiBcIlwiO1xyXG5cdFx0aWYgKHN5bWJvbCA9PT0gXCItXCIpIHtcclxuXHRcdFx0dW5pdHMgPSB1bml0cy5zbGljZSgxKTtcclxuXHRcdH1cclxuXHRcdHZhciBkZWNpbWFsO1xyXG5cdFx0aWYgKHVuaXRzLmxlbmd0aCA+PSBjb25maWcuY29pblVuaXRQbGFjZXMpIHtcclxuXHRcdFx0ZGVjaW1hbCA9IHVuaXRzLnN1YnN0cihcclxuXHRcdFx0XHR1bml0cy5sZW5ndGggLSBjb25maWcuY29pblVuaXRQbGFjZXMsXHJcblx0XHRcdFx0Y29uZmlnLmNvaW5Vbml0UGxhY2VzXHJcblx0XHRcdCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRkZWNpbWFsID0gcGFkTGVmdCh1bml0cywgY29uZmlnLmNvaW5Vbml0UGxhY2VzLCBcIjBcIik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKFxyXG5cdFx0XHRzeW1ib2wgK1xyXG5cdFx0XHQodW5pdHMuc3Vic3RyKDAsIHVuaXRzLmxlbmd0aCAtIGNvbmZpZy5jb2luVW5pdFBsYWNlcykgfHwgXCIwXCIpICtcclxuXHRcdFx0XCIuXCIgK1xyXG5cdFx0XHRkZWNpbWFsXHJcblx0XHQpO1xyXG5cdH07XHJcblxyXG5cdHRoaXMuZm9ybWF0TW9uZXlGdWxsU3ltYm9sID0gZnVuY3Rpb24odW5pdHMpIHtcclxuXHRcdHJldHVybiB0aGlzLmZvcm1hdE1vbmV5RnVsbCh1bml0cykgKyBcIiBcIiArIGNvbmZpZy5jb2luU3ltYm9sO1xyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHBhZExlZnQoc3RyLCBsZW4sIGNoYXIpIHtcclxuXHRcdHdoaWxlIChzdHIubGVuZ3RoIDwgbGVuKSBzdHIgPSBjaGFyICsgc3RyO1xyXG5cdFx0cmV0dXJuIHN0cjtcclxuXHR9XHJcblx0ZnVuY3Rpb24gdHJpbVJpZ2h0KHN0ciwgY2hhcikge1xyXG5cdFx0d2hpbGUgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT0gY2hhcikgc3RyID0gc3RyLnNsaWNlKDAsIC0xKTtcclxuXHRcdHJldHVybiBzdHI7XHJcblx0fVxyXG5cdHRoaXMuZm9ybWF0TW9uZXkgPSBmdW5jdGlvbih1bml0cykge1xyXG5cdFx0dmFyIGYgPSB0cmltUmlnaHQodGhpcy5mb3JtYXRNb25leUZ1bGwodW5pdHMpLCBcIjBcIik7XHJcblx0XHRpZiAoZltmLmxlbmd0aCAtIDFdID09PSBcIi5cIikge1xyXG5cdFx0XHRyZXR1cm4gZi5zbGljZSgwLCBmLmxlbmd0aCAtIDEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGY7XHJcblx0fTtcclxuXHJcblx0dGhpcy5mb3JtYXRNb25leVN5bWJvbCA9IGZ1bmN0aW9uKHVuaXRzKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5mb3JtYXRNb25leSh1bml0cykgKyBcIiBcIiArIGNvbmZpZy5jb2luU3ltYm9sO1xyXG5cdH07XHJcblxyXG5cdHRoaXMucGFyc2VNb25leSA9IGZ1bmN0aW9uKHN0cikge1xyXG5cdFx0aWYgKCFzdHIpIHJldHVybiBKU0JpZ0ludC5aRVJPO1xyXG5cdFx0dmFyIG5lZ2F0aXZlID0gc3RyWzBdID09PSBcIi1cIjtcclxuXHRcdGlmIChuZWdhdGl2ZSkge1xyXG5cdFx0XHRzdHIgPSBzdHIuc2xpY2UoMSk7XHJcblx0XHR9XHJcblx0XHR2YXIgZGVjaW1hbEluZGV4ID0gc3RyLmluZGV4T2YoXCIuXCIpO1xyXG5cdFx0aWYgKGRlY2ltYWxJbmRleCA9PSAtMSkge1xyXG5cdFx0XHRpZiAobmVnYXRpdmUpIHtcclxuXHRcdFx0XHRyZXR1cm4gSlNCaWdJbnQubXVsdGlwbHkoc3RyLCBjb25maWcuY29pblVuaXRzKS5uZWdhdGUoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gSlNCaWdJbnQubXVsdGlwbHkoc3RyLCBjb25maWcuY29pblVuaXRzKTtcclxuXHRcdH1cclxuXHRcdGlmIChkZWNpbWFsSW5kZXggKyBjb25maWcuY29pblVuaXRQbGFjZXMgKyAxIDwgc3RyLmxlbmd0aCkge1xyXG5cdFx0XHRzdHIgPSBzdHIuc3Vic3RyKDAsIGRlY2ltYWxJbmRleCArIGNvbmZpZy5jb2luVW5pdFBsYWNlcyArIDEpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKG5lZ2F0aXZlKSB7XHJcblx0XHRcdHJldHVybiBuZXcgSlNCaWdJbnQoc3RyLnN1YnN0cigwLCBkZWNpbWFsSW5kZXgpKVxyXG5cdFx0XHRcdC5leHAxMChjb25maWcuY29pblVuaXRQbGFjZXMpXHJcblx0XHRcdFx0LmFkZChcclxuXHRcdFx0XHRcdG5ldyBKU0JpZ0ludChzdHIuc3Vic3RyKGRlY2ltYWxJbmRleCArIDEpKS5leHAxMChcclxuXHRcdFx0XHRcdFx0ZGVjaW1hbEluZGV4ICsgY29uZmlnLmNvaW5Vbml0UGxhY2VzIC0gc3RyLmxlbmd0aCArIDEsXHJcblx0XHRcdFx0XHQpLFxyXG5cdFx0XHRcdCkubmVnYXRlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBKU0JpZ0ludChzdHIuc3Vic3RyKDAsIGRlY2ltYWxJbmRleCkpXHJcblx0XHRcdC5leHAxMChjb25maWcuY29pblVuaXRQbGFjZXMpXHJcblx0XHRcdC5hZGQoXHJcblx0XHRcdFx0bmV3IEpTQmlnSW50KHN0ci5zdWJzdHIoZGVjaW1hbEluZGV4ICsgMSkpLmV4cDEwKFxyXG5cdFx0XHRcdFx0ZGVjaW1hbEluZGV4ICsgY29uZmlnLmNvaW5Vbml0UGxhY2VzIC0gc3RyLmxlbmd0aCArIDEsXHJcblx0XHRcdFx0KSxcclxuXHRcdFx0KTtcclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/money_format_utils.js\n");

/***/ }),

/***/ "./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/nettype.js":
/*!*****************************************************************************************!*\
  !*** ./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/nettype.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2014-2018, MyMonero.com\r\n//\r\n// All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without modification, are\r\n// permitted provided that the following conditions are met:\r\n//\r\n// 1. Redistributions of source code must retain the above copyright notice, this list of\r\n//\tconditions and the following disclaimer.\r\n//\r\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list\r\n//\tof conditions and the following disclaimer in the documentation and/or other\r\n//\tmaterials provided with the distribution.\r\n//\r\n// 3. Neither the name of the copyright holder nor the names of its contributors may be\r\n//\tused to endorse or promote products derived from this software without specific\r\n//\tprior written permission.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\r\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\r\n// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\r\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\n\r\n\r\nvar network_type = {\r\n\tMAINNET: 0,\r\n\tTESTNET: 1,\r\n\tSTAGENET: 2,\r\n\tFAKECHAIN: 3,\r\n\tUNDEFINED: 4\r\n};\r\nexports.network_type = network_type;\r\nexports.nettype_to_API_string = function(nettype)\r\n{\r\n\tswitch (nettype) {\r\n\t\tcase network_type.MAINNET:\r\n\t\t\treturn \"MAINNET\"\r\n\t\tcase network_type.TESTNET:\r\n\t\t\treturn \"TESTNET\"\r\n\t\tcase network_type.STAGENET:\r\n\t\t\treturn \"STAGENET\"\r\n\t\tcase network_type.FAKECHAIN:\r\n\t\t\treturn \"FAKECHAIN\"\r\n\t\tcase network_type.UNDEFINED:\r\n\t\t\treturn \"UNDEFINED\"\r\n\t}\r\n\tthrow \"Unrecognized nettype\"\r\n}\r\n//\r\nvar __MAINNET_CRYPTONOTE_PUBLIC_ADDRESS_BASE58_PREFIX = 18;\r\nvar __MAINNET_CRYPTONOTE_PUBLIC_INTEGRATED_ADDRESS_BASE58_PREFIX = 19;\r\nvar __MAINNET_CRYPTONOTE_PUBLIC_SUBADDRESS_BASE58_PREFIX = 42;\r\n//\r\nvar __TESTNET_CRYPTONOTE_PUBLIC_ADDRESS_BASE58_PREFIX = 53;\r\nvar __TESTNET_CRYPTONOTE_PUBLIC_INTEGRATED_ADDRESS_BASE58_PREFIX = 54;\r\nvar __TESTNET_CRYPTONOTE_PUBLIC_SUBADDRESS_BASE58_PREFIX = 63;\r\n//\r\nvar __STAGENET_CRYPTONOTE_PUBLIC_ADDRESS_BASE58_PREFIX = 24;\r\nvar __STAGENET_CRYPTONOTE_PUBLIC_INTEGRATED_ADDRESS_BASE58_PREFIX = 25;\r\nvar __STAGENET_CRYPTONOTE_PUBLIC_SUBADDRESS_BASE58_PREFIX = 36;\r\n//\r\nfunction cryptonoteBase58PrefixForStandardAddressOn(nettype) {\r\n\tif (nettype == null || typeof nettype === \"undefined\") {\r\n\t\tconsole.warn(\"Unexpected nil nettype\");\r\n\t}\r\n\tif (nettype == network_type.MAINNET) {\r\n\t\treturn __MAINNET_CRYPTONOTE_PUBLIC_ADDRESS_BASE58_PREFIX;\r\n\t} else if (nettype == network_type.TESTNET) {\r\n\t\treturn __TESTNET_CRYPTONOTE_PUBLIC_ADDRESS_BASE58_PREFIX;\r\n\t} else if (nettype == network_type.STAGENET) {\r\n\t\treturn __STAGENET_CRYPTONOTE_PUBLIC_ADDRESS_BASE58_PREFIX;\r\n\t}\r\n\tthrow \"Illegal nettype\";\r\n}\r\nfunction cryptonoteBase58PrefixForIntegratedAddressOn(nettype) {\r\n\tif (nettype == null || typeof nettype === \"undefined\") {\r\n\t\tconsole.warn(\"Unexpected nil nettype\");\r\n\t}\r\n\tif (nettype == network_type.MAINNET) {\r\n\t\treturn __MAINNET_CRYPTONOTE_PUBLIC_INTEGRATED_ADDRESS_BASE58_PREFIX;\r\n\t} else if (nettype == network_type.TESTNET) {\r\n\t\treturn __TESTNET_CRYPTONOTE_PUBLIC_INTEGRATED_ADDRESS_BASE58_PREFIX;\r\n\t} else if (nettype == network_type.STAGENET) {\r\n\t\treturn __STAGENET_CRYPTONOTE_PUBLIC_INTEGRATED_ADDRESS_BASE58_PREFIX;\r\n\t}\r\n\tthrow \"Illegal nettype\";\r\n}\r\nfunction cryptonoteBase58PrefixForSubAddressOn(nettype) {\r\n\tif (nettype == null || typeof nettype === \"undefined\") {\r\n\t\tconsole.warn(\"Unexpected nil nettype\");\r\n\t}\r\n\tif (nettype == network_type.MAINNET) {\r\n\t\treturn __MAINNET_CRYPTONOTE_PUBLIC_SUBADDRESS_BASE58_PREFIX;\r\n\t} else if (nettype == network_type.TESTNET) {\r\n\t\treturn __TESTNET_CRYPTONOTE_PUBLIC_SUBADDRESS_BASE58_PREFIX;\r\n\t} else if (nettype == network_type.STAGENET) {\r\n\t\treturn __STAGENET_CRYPTONOTE_PUBLIC_SUBADDRESS_BASE58_PREFIX;\r\n\t}\r\n\tthrow \"Illegal nettype\";\r\n}\r\n//\r\nexports.cryptonoteBase58PrefixForStandardAddressOn = cryptonoteBase58PrefixForStandardAddressOn;\r\nexports.cryptonoteBase58PrefixForIntegratedAddressOn = cryptonoteBase58PrefixForIntegratedAddressOn;\r\nexports.cryptonoteBase58PrefixForSubAddressOn = cryptonoteBase58PrefixForSubAddressOn;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvY3J5cHRvbm90ZV91dGlscy9uZXR0eXBlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGlicy9teW1vbmVyby1hcHAtanMvbG9jYWxfbW9kdWxlcy9teW1vbmVyb19jb3JlX2pzL2NyeXB0b25vdGVfdXRpbHMvbmV0dHlwZS5qcz84NjI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNC0yMDE4LCBNeU1vbmVyby5jb21cclxuLy9cclxuLy8gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy9cclxuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlXHJcbi8vIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4vL1xyXG4vLyAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZlxyXG4vL1x0Y29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4vL1xyXG4vLyAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdFxyXG4vL1x0b2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlclxyXG4vL1x0bWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuLy9cclxuLy8gMy4gTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgY29weXJpZ2h0IGhvbGRlciBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlXHJcbi8vXHR1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljXHJcbi8vXHRwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcbi8vXHJcbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORCBBTllcclxuLy8gRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GXHJcbi8vIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMXHJcbi8vIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxyXG4vLyBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXHJcbi8vIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xyXG4vLyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCxcclxuLy8gU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXHJcbi8vIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIG5ldHdvcmtfdHlwZSA9IHtcclxuXHRNQUlOTkVUOiAwLFxyXG5cdFRFU1RORVQ6IDEsXHJcblx0U1RBR0VORVQ6IDIsXHJcblx0RkFLRUNIQUlOOiAzLFxyXG5cdFVOREVGSU5FRDogNFxyXG59O1xyXG5leHBvcnRzLm5ldHdvcmtfdHlwZSA9IG5ldHdvcmtfdHlwZTtcclxuZXhwb3J0cy5uZXR0eXBlX3RvX0FQSV9zdHJpbmcgPSBmdW5jdGlvbihuZXR0eXBlKVxyXG57XHJcblx0c3dpdGNoIChuZXR0eXBlKSB7XHJcblx0XHRjYXNlIG5ldHdvcmtfdHlwZS5NQUlOTkVUOlxyXG5cdFx0XHRyZXR1cm4gXCJNQUlOTkVUXCJcclxuXHRcdGNhc2UgbmV0d29ya190eXBlLlRFU1RORVQ6XHJcblx0XHRcdHJldHVybiBcIlRFU1RORVRcIlxyXG5cdFx0Y2FzZSBuZXR3b3JrX3R5cGUuU1RBR0VORVQ6XHJcblx0XHRcdHJldHVybiBcIlNUQUdFTkVUXCJcclxuXHRcdGNhc2UgbmV0d29ya190eXBlLkZBS0VDSEFJTjpcclxuXHRcdFx0cmV0dXJuIFwiRkFLRUNIQUlOXCJcclxuXHRcdGNhc2UgbmV0d29ya190eXBlLlVOREVGSU5FRDpcclxuXHRcdFx0cmV0dXJuIFwiVU5ERUZJTkVEXCJcclxuXHR9XHJcblx0dGhyb3cgXCJVbnJlY29nbml6ZWQgbmV0dHlwZVwiXHJcbn1cclxuLy9cclxudmFyIF9fTUFJTk5FVF9DUllQVE9OT1RFX1BVQkxJQ19BRERSRVNTX0JBU0U1OF9QUkVGSVggPSAxODtcclxudmFyIF9fTUFJTk5FVF9DUllQVE9OT1RFX1BVQkxJQ19JTlRFR1JBVEVEX0FERFJFU1NfQkFTRTU4X1BSRUZJWCA9IDE5O1xyXG52YXIgX19NQUlOTkVUX0NSWVBUT05PVEVfUFVCTElDX1NVQkFERFJFU1NfQkFTRTU4X1BSRUZJWCA9IDQyO1xyXG4vL1xyXG52YXIgX19URVNUTkVUX0NSWVBUT05PVEVfUFVCTElDX0FERFJFU1NfQkFTRTU4X1BSRUZJWCA9IDUzO1xyXG52YXIgX19URVNUTkVUX0NSWVBUT05PVEVfUFVCTElDX0lOVEVHUkFURURfQUREUkVTU19CQVNFNThfUFJFRklYID0gNTQ7XHJcbnZhciBfX1RFU1RORVRfQ1JZUFRPTk9URV9QVUJMSUNfU1VCQUREUkVTU19CQVNFNThfUFJFRklYID0gNjM7XHJcbi8vXHJcbnZhciBfX1NUQUdFTkVUX0NSWVBUT05PVEVfUFVCTElDX0FERFJFU1NfQkFTRTU4X1BSRUZJWCA9IDI0O1xyXG52YXIgX19TVEFHRU5FVF9DUllQVE9OT1RFX1BVQkxJQ19JTlRFR1JBVEVEX0FERFJFU1NfQkFTRTU4X1BSRUZJWCA9IDI1O1xyXG52YXIgX19TVEFHRU5FVF9DUllQVE9OT1RFX1BVQkxJQ19TVUJBRERSRVNTX0JBU0U1OF9QUkVGSVggPSAzNjtcclxuLy9cclxuZnVuY3Rpb24gY3J5cHRvbm90ZUJhc2U1OFByZWZpeEZvclN0YW5kYXJkQWRkcmVzc09uKG5ldHR5cGUpIHtcclxuXHRpZiAobmV0dHlwZSA9PSBudWxsIHx8IHR5cGVvZiBuZXR0eXBlID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRjb25zb2xlLndhcm4oXCJVbmV4cGVjdGVkIG5pbCBuZXR0eXBlXCIpO1xyXG5cdH1cclxuXHRpZiAobmV0dHlwZSA9PSBuZXR3b3JrX3R5cGUuTUFJTk5FVCkge1xyXG5cdFx0cmV0dXJuIF9fTUFJTk5FVF9DUllQVE9OT1RFX1BVQkxJQ19BRERSRVNTX0JBU0U1OF9QUkVGSVg7XHJcblx0fSBlbHNlIGlmIChuZXR0eXBlID09IG5ldHdvcmtfdHlwZS5URVNUTkVUKSB7XHJcblx0XHRyZXR1cm4gX19URVNUTkVUX0NSWVBUT05PVEVfUFVCTElDX0FERFJFU1NfQkFTRTU4X1BSRUZJWDtcclxuXHR9IGVsc2UgaWYgKG5ldHR5cGUgPT0gbmV0d29ya190eXBlLlNUQUdFTkVUKSB7XHJcblx0XHRyZXR1cm4gX19TVEFHRU5FVF9DUllQVE9OT1RFX1BVQkxJQ19BRERSRVNTX0JBU0U1OF9QUkVGSVg7XHJcblx0fVxyXG5cdHRocm93IFwiSWxsZWdhbCBuZXR0eXBlXCI7XHJcbn1cclxuZnVuY3Rpb24gY3J5cHRvbm90ZUJhc2U1OFByZWZpeEZvckludGVncmF0ZWRBZGRyZXNzT24obmV0dHlwZSkge1xyXG5cdGlmIChuZXR0eXBlID09IG51bGwgfHwgdHlwZW9mIG5ldHR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdGNvbnNvbGUud2FybihcIlVuZXhwZWN0ZWQgbmlsIG5ldHR5cGVcIik7XHJcblx0fVxyXG5cdGlmIChuZXR0eXBlID09IG5ldHdvcmtfdHlwZS5NQUlOTkVUKSB7XHJcblx0XHRyZXR1cm4gX19NQUlOTkVUX0NSWVBUT05PVEVfUFVCTElDX0lOVEVHUkFURURfQUREUkVTU19CQVNFNThfUFJFRklYO1xyXG5cdH0gZWxzZSBpZiAobmV0dHlwZSA9PSBuZXR3b3JrX3R5cGUuVEVTVE5FVCkge1xyXG5cdFx0cmV0dXJuIF9fVEVTVE5FVF9DUllQVE9OT1RFX1BVQkxJQ19JTlRFR1JBVEVEX0FERFJFU1NfQkFTRTU4X1BSRUZJWDtcclxuXHR9IGVsc2UgaWYgKG5ldHR5cGUgPT0gbmV0d29ya190eXBlLlNUQUdFTkVUKSB7XHJcblx0XHRyZXR1cm4gX19TVEFHRU5FVF9DUllQVE9OT1RFX1BVQkxJQ19JTlRFR1JBVEVEX0FERFJFU1NfQkFTRTU4X1BSRUZJWDtcclxuXHR9XHJcblx0dGhyb3cgXCJJbGxlZ2FsIG5ldHR5cGVcIjtcclxufVxyXG5mdW5jdGlvbiBjcnlwdG9ub3RlQmFzZTU4UHJlZml4Rm9yU3ViQWRkcmVzc09uKG5ldHR5cGUpIHtcclxuXHRpZiAobmV0dHlwZSA9PSBudWxsIHx8IHR5cGVvZiBuZXR0eXBlID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRjb25zb2xlLndhcm4oXCJVbmV4cGVjdGVkIG5pbCBuZXR0eXBlXCIpO1xyXG5cdH1cclxuXHRpZiAobmV0dHlwZSA9PSBuZXR3b3JrX3R5cGUuTUFJTk5FVCkge1xyXG5cdFx0cmV0dXJuIF9fTUFJTk5FVF9DUllQVE9OT1RFX1BVQkxJQ19TVUJBRERSRVNTX0JBU0U1OF9QUkVGSVg7XHJcblx0fSBlbHNlIGlmIChuZXR0eXBlID09IG5ldHdvcmtfdHlwZS5URVNUTkVUKSB7XHJcblx0XHRyZXR1cm4gX19URVNUTkVUX0NSWVBUT05PVEVfUFVCTElDX1NVQkFERFJFU1NfQkFTRTU4X1BSRUZJWDtcclxuXHR9IGVsc2UgaWYgKG5ldHR5cGUgPT0gbmV0d29ya190eXBlLlNUQUdFTkVUKSB7XHJcblx0XHRyZXR1cm4gX19TVEFHRU5FVF9DUllQVE9OT1RFX1BVQkxJQ19TVUJBRERSRVNTX0JBU0U1OF9QUkVGSVg7XHJcblx0fVxyXG5cdHRocm93IFwiSWxsZWdhbCBuZXR0eXBlXCI7XHJcbn1cclxuLy9cclxuZXhwb3J0cy5jcnlwdG9ub3RlQmFzZTU4UHJlZml4Rm9yU3RhbmRhcmRBZGRyZXNzT24gPSBjcnlwdG9ub3RlQmFzZTU4UHJlZml4Rm9yU3RhbmRhcmRBZGRyZXNzT247XHJcbmV4cG9ydHMuY3J5cHRvbm90ZUJhc2U1OFByZWZpeEZvckludGVncmF0ZWRBZGRyZXNzT24gPSBjcnlwdG9ub3RlQmFzZTU4UHJlZml4Rm9ySW50ZWdyYXRlZEFkZHJlc3NPbjtcclxuZXhwb3J0cy5jcnlwdG9ub3RlQmFzZTU4UHJlZml4Rm9yU3ViQWRkcmVzc09uID0gY3J5cHRvbm90ZUJhc2U1OFByZWZpeEZvclN1YkFkZHJlc3NPbjtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/nettype.js\n");

/***/ }),

/***/ "./libs/mymonero-app-js/local_modules/mymonero_core_js/hostAPI/net_service_utils.js":
/*!******************************************************************************************!*\
  !*** ./libs/mymonero-app-js/local_modules/mymonero_core_js/hostAPI/net_service_utils.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2014-2018, MyMonero.com\r\n//\r\n// All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without modification, are\r\n// permitted provided that the following conditions are met:\r\n//\r\n// 1. Redistributions of source code must retain the above copyright notice, this list of\r\n//\tconditions and the following disclaimer.\r\n//\r\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list\r\n//\tof conditions and the following disclaimer in the documentation and/or other\r\n//\tmaterials provided with the distribution.\r\n//\r\n// 3. Neither the name of the copyright holder nor the names of its contributors may be\r\n//\tused to endorse or promote products derived from this software without specific\r\n//\tprior written permission.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\r\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\r\n// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\r\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n//\r\n\r\n//\r\nconst response_parser_utils = __webpack_require__(/*! ./response_parser_utils */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/hostAPI/response_parser_utils.js\");\r\nconst JSBigInt = __webpack_require__(/*! ../cryptonote_utils/biginteger */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/biginteger.js\").BigInteger; // important: grab defined export\r\n//\r\nfunction New_ParametersForWalletRequest(address, view_key__private) {\r\n\treturn {\r\n\t\taddress: address,\r\n\t\tview_key: view_key__private,\r\n\t};\r\n}\r\nexports.New_ParametersForWalletRequest = New_ParametersForWalletRequest;\r\n//\r\nfunction AddUserAgentParamters(\r\n\tparameters,\r\n\tappUserAgent_product,\r\n\tappUserAgent_version,\r\n) {\r\n\t// setting these on params instead of as header field User-Agent so as to retain all info found in User-Agent, such as platform and these are set so server has option to control delivery\r\n\tparameters[\"app_name\"] = appUserAgent_product;\r\n\tparameters[\"app_version\"] = appUserAgent_version;\r\n}\r\nexports.AddUserAgentParamters = AddUserAgentParamters;\r\n//\r\nfunction HTTPRequest(\r\n\trequest_conformant_module, // such as 'request' or 'xhr' .. TODO: consider switching to 'fetch'\r\n\tapiAddress_authority, // authority means [subdomain.]host.[:] with no trailing slash\r\n\tendpointPath,\r\n\tfinal_parameters,\r\n\tfn,\r\n) {\r\n\t// fn: (err?, data?) -> new Request\r\n\tif (typeof final_parameters == \"undefined\" || final_parameters == null) {\r\n\t\tthrow \"final_parameters must not be nil\";\r\n\t\t// return null\r\n\t}\r\n\tconst completeURL =\r\n\t\t_new_APIAddress_baseURLString(apiAddress_authority) + endpointPath;\r\n\tconsole.log(\"  \" + completeURL);\r\n\t//\r\n\tconst request_options = _new_requestOptions_base(\r\n\t\t\"POST\",\r\n\t\tcompleteURL,\r\n\t\tfinal_parameters,\r\n\t);\r\n\tconst requestHandle = request_conformant_module(request_options, function(\r\n\t\terr_orProgressEvent,\r\n\t\tres,\r\n\t\tbody,\r\n\t) {\r\n\t\t_new_HTTPRequestHandlerFunctionCallingFn(fn)(\r\n\t\t\t// <- called manually instead of directly passed to request_conformant_module call to enable passing completeURL\r\n\t\t\tcompleteURL,\r\n\t\t\terr_orProgressEvent,\r\n\t\t\tres,\r\n\t\t\tbody,\r\n\t\t);\r\n\t});\r\n\t//\r\n\treturn requestHandle;\r\n}\r\nexports.HTTPRequest = HTTPRequest;\r\n//\r\nfunction _new_APIAddress_baseURLString(\r\n\tapiAddress_authority, // authority means [subdomain.]host.[:]\r\n) {\r\n\treturn \"https\" + \"://\" + apiAddress_authority + \"/\";\r\n}\r\nfunction _new_requestOptions_base(methodName, completeURL, json_parameters) {\r\n\treturn {\r\n\t\tmethod: methodName,\r\n\t\turl: completeURL,\r\n\t\theaders: {\r\n\t\t\t\"Content-Type\": \"application/json\",\r\n\t\t\tAccept: \"application/json\",\r\n\t\t},\r\n\t\tjson: json_parameters,\r\n\t\tuseXDR: true, // CORS\r\n\t\twithCredentials: true, // CORS\r\n\t};\r\n}\r\nfunction _new_HTTPRequestHandlerFunctionCallingFn(fn) {\r\n\treturn function(completeURL, err_orProgressEvent, res, body) {\r\n\t\t// err appears to actually be a ProgressEvent\r\n\t\tvar err = null;\r\n\t\tconst statusCode = typeof res !== \"undefined\" ? res.statusCode : -1;\r\n\t\tif (statusCode == 0 || statusCode == -1) {\r\n\t\t\t// we'll treat 0 as a lack of internet connection.. unless there's a better way to make use of err_orProgressEvent which is apparently going to be typeof ProgressEvent here\r\n\t\t\terr = new Error(\"Connection Failure\");\r\n\t\t} else if (statusCode !== 200) {\r\n\t\t\tconst body_Error =\r\n\t\t\t\tbody && typeof body == \"object\" ? body.Error : undefined;\r\n\t\t\tconst statusMessage =\r\n\t\t\t\tres && res.statusMessage ? res.statusMessage : undefined;\r\n\t\t\tif (typeof body_Error !== \"undefined\" && body_Error) {\r\n\t\t\t\terr = new Error(body_Error);\r\n\t\t\t} else if (typeof statusMessage !== \"undefined\" && statusMessage) {\r\n\t\t\t\terr = new Error(statusMessage);\r\n\t\t\t} else {\r\n\t\t\t\terr = new Error(\"Unknown \" + statusCode + \" error\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (err) {\r\n\t\t\tconsole.error(\"  \" + err);\r\n\t\t\t// console.error(\"Body:\", body)\r\n\t\t\tfn(err, null);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar json;\r\n\t\tif (typeof body === \"string\") {\r\n\t\t\ttry {\r\n\t\t\t\tjson = JSON.parse(body);\r\n\t\t\t} catch (e) {\r\n\t\t\t\tconsole.error(\r\n\t\t\t\t\t\"  HostedMoneroAPIClient Error: Unable to parse json with exception:\",\r\n\t\t\t\t\te,\r\n\t\t\t\t\t\"\\nbody:\",\r\n\t\t\t\t\tbody,\r\n\t\t\t\t);\r\n\t\t\t\tfn(e, null);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tjson = body;\r\n\t\t}\r\n\t\tconsole.log(\"  \" + completeURL + \" \" + statusCode);\r\n\t\tfn(null, json);\r\n\t};\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvaG9zdEFQSS9uZXRfc2VydmljZV91dGlscy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYnMvbXltb25lcm8tYXBwLWpzL2xvY2FsX21vZHVsZXMvbXltb25lcm9fY29yZV9qcy9ob3N0QVBJL25ldF9zZXJ2aWNlX3V0aWxzLmpzP2VkMmMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTgsIE15TW9uZXJvLmNvbVxyXG4vL1xyXG4vLyBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vL1xyXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmVcclxuLy8gcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbi8vXHJcbi8vIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mXHJcbi8vXHRjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbi8vXHJcbi8vIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0XHJcbi8vXHRvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyXHJcbi8vXHRtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4vL1xyXG4vLyAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBjb3B5cmlnaHQgaG9sZGVyIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmVcclxuLy9cdHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWNcclxuLy9cdHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuLy9cclxuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EIEFOWVxyXG4vLyBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcclxuLy8gTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTExcclxuLy8gVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXHJcbi8vIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcclxuLy8gUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXHJcbi8vIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxyXG4vLyBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcclxuLy8gVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4vL1xyXG5cInVzZSBzdHJpY3RcIjtcclxuLy9cclxuY29uc3QgcmVzcG9uc2VfcGFyc2VyX3V0aWxzID0gcmVxdWlyZShcIi4vcmVzcG9uc2VfcGFyc2VyX3V0aWxzXCIpO1xyXG5jb25zdCBKU0JpZ0ludCA9IHJlcXVpcmUoXCIuLi9jcnlwdG9ub3RlX3V0aWxzL2JpZ2ludGVnZXJcIikuQmlnSW50ZWdlcjsgLy8gaW1wb3J0YW50OiBncmFiIGRlZmluZWQgZXhwb3J0XHJcbi8vXHJcbmZ1bmN0aW9uIE5ld19QYXJhbWV0ZXJzRm9yV2FsbGV0UmVxdWVzdChhZGRyZXNzLCB2aWV3X2tleV9fcHJpdmF0ZSkge1xyXG5cdHJldHVybiB7XHJcblx0XHRhZGRyZXNzOiBhZGRyZXNzLFxyXG5cdFx0dmlld19rZXk6IHZpZXdfa2V5X19wcml2YXRlLFxyXG5cdH07XHJcbn1cclxuZXhwb3J0cy5OZXdfUGFyYW1ldGVyc0ZvcldhbGxldFJlcXVlc3QgPSBOZXdfUGFyYW1ldGVyc0ZvcldhbGxldFJlcXVlc3Q7XHJcbi8vXHJcbmZ1bmN0aW9uIEFkZFVzZXJBZ2VudFBhcmFtdGVycyhcclxuXHRwYXJhbWV0ZXJzLFxyXG5cdGFwcFVzZXJBZ2VudF9wcm9kdWN0LFxyXG5cdGFwcFVzZXJBZ2VudF92ZXJzaW9uLFxyXG4pIHtcclxuXHQvLyBzZXR0aW5nIHRoZXNlIG9uIHBhcmFtcyBpbnN0ZWFkIG9mIGFzIGhlYWRlciBmaWVsZCBVc2VyLUFnZW50IHNvIGFzIHRvIHJldGFpbiBhbGwgaW5mbyBmb3VuZCBpbiBVc2VyLUFnZW50LCBzdWNoIGFzIHBsYXRmb3Jt4oCmIGFuZCB0aGVzZSBhcmUgc2V0IHNvIHNlcnZlciBoYXMgb3B0aW9uIHRvIGNvbnRyb2wgZGVsaXZlcnlcclxuXHRwYXJhbWV0ZXJzW1wiYXBwX25hbWVcIl0gPSBhcHBVc2VyQWdlbnRfcHJvZHVjdDtcclxuXHRwYXJhbWV0ZXJzW1wiYXBwX3ZlcnNpb25cIl0gPSBhcHBVc2VyQWdlbnRfdmVyc2lvbjtcclxufVxyXG5leHBvcnRzLkFkZFVzZXJBZ2VudFBhcmFtdGVycyA9IEFkZFVzZXJBZ2VudFBhcmFtdGVycztcclxuLy9cclxuZnVuY3Rpb24gSFRUUFJlcXVlc3QoXHJcblx0cmVxdWVzdF9jb25mb3JtYW50X21vZHVsZSwgLy8gc3VjaCBhcyAncmVxdWVzdCcgb3IgJ3hocicgLi4gVE9ETzogY29uc2lkZXIgc3dpdGNoaW5nIHRvICdmZXRjaCdcclxuXHRhcGlBZGRyZXNzX2F1dGhvcml0eSwgLy8gYXV0aG9yaXR5IG1lYW5zIFtzdWJkb21haW4uXWhvc3Qu4oCmWzrigKZdIHdpdGggbm8gdHJhaWxpbmcgc2xhc2hcclxuXHRlbmRwb2ludFBhdGgsXHJcblx0ZmluYWxfcGFyYW1ldGVycyxcclxuXHRmbixcclxuKSB7XHJcblx0Ly8gZm46IChlcnI/LCBkYXRhPykgLT4gbmV3IFJlcXVlc3RcclxuXHRpZiAodHlwZW9mIGZpbmFsX3BhcmFtZXRlcnMgPT0gXCJ1bmRlZmluZWRcIiB8fCBmaW5hbF9wYXJhbWV0ZXJzID09IG51bGwpIHtcclxuXHRcdHRocm93IFwiZmluYWxfcGFyYW1ldGVycyBtdXN0IG5vdCBiZSBuaWxcIjtcclxuXHRcdC8vIHJldHVybiBudWxsXHJcblx0fVxyXG5cdGNvbnN0IGNvbXBsZXRlVVJMID1cclxuXHRcdF9uZXdfQVBJQWRkcmVzc19iYXNlVVJMU3RyaW5nKGFwaUFkZHJlc3NfYXV0aG9yaXR5KSArIGVuZHBvaW50UGF0aDtcclxuXHRjb25zb2xlLmxvZyhcIvCfk6EgIFwiICsgY29tcGxldGVVUkwpO1xyXG5cdC8vXHJcblx0Y29uc3QgcmVxdWVzdF9vcHRpb25zID0gX25ld19yZXF1ZXN0T3B0aW9uc19iYXNlKFxyXG5cdFx0XCJQT1NUXCIsXHJcblx0XHRjb21wbGV0ZVVSTCxcclxuXHRcdGZpbmFsX3BhcmFtZXRlcnMsXHJcblx0KTtcclxuXHRjb25zdCByZXF1ZXN0SGFuZGxlID0gcmVxdWVzdF9jb25mb3JtYW50X21vZHVsZShyZXF1ZXN0X29wdGlvbnMsIGZ1bmN0aW9uKFxyXG5cdFx0ZXJyX29yUHJvZ3Jlc3NFdmVudCxcclxuXHRcdHJlcyxcclxuXHRcdGJvZHksXHJcblx0KSB7XHJcblx0XHRfbmV3X0hUVFBSZXF1ZXN0SGFuZGxlckZ1bmN0aW9uQ2FsbGluZ0ZuKGZuKShcclxuXHRcdFx0Ly8gPC0gY2FsbGVkIG1hbnVhbGx5IGluc3RlYWQgb2YgZGlyZWN0bHkgcGFzc2VkIHRvIHJlcXVlc3RfY29uZm9ybWFudF9tb2R1bGUgY2FsbCB0byBlbmFibGUgcGFzc2luZyBjb21wbGV0ZVVSTFxyXG5cdFx0XHRjb21wbGV0ZVVSTCxcclxuXHRcdFx0ZXJyX29yUHJvZ3Jlc3NFdmVudCxcclxuXHRcdFx0cmVzLFxyXG5cdFx0XHRib2R5LFxyXG5cdFx0KTtcclxuXHR9KTtcclxuXHQvL1xyXG5cdHJldHVybiByZXF1ZXN0SGFuZGxlO1xyXG59XHJcbmV4cG9ydHMuSFRUUFJlcXVlc3QgPSBIVFRQUmVxdWVzdDtcclxuLy9cclxuZnVuY3Rpb24gX25ld19BUElBZGRyZXNzX2Jhc2VVUkxTdHJpbmcoXHJcblx0YXBpQWRkcmVzc19hdXRob3JpdHksIC8vIGF1dGhvcml0eSBtZWFucyBbc3ViZG9tYWluLl1ob3N0LuKApls64oCmXVxyXG4pIHtcclxuXHRyZXR1cm4gXCJodHRwc1wiICsgXCI6Ly9cIiArIGFwaUFkZHJlc3NfYXV0aG9yaXR5ICsgXCIvXCI7XHJcbn1cclxuZnVuY3Rpb24gX25ld19yZXF1ZXN0T3B0aW9uc19iYXNlKG1ldGhvZE5hbWUsIGNvbXBsZXRlVVJMLCBqc29uX3BhcmFtZXRlcnMpIHtcclxuXHRyZXR1cm4ge1xyXG5cdFx0bWV0aG9kOiBtZXRob2ROYW1lLFxyXG5cdFx0dXJsOiBjb21wbGV0ZVVSTCxcclxuXHRcdGhlYWRlcnM6IHtcclxuXHRcdFx0XCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXHJcblx0XHRcdEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXHJcblx0XHR9LFxyXG5cdFx0anNvbjoganNvbl9wYXJhbWV0ZXJzLFxyXG5cdFx0dXNlWERSOiB0cnVlLCAvLyBDT1JTXHJcblx0XHR3aXRoQ3JlZGVudGlhbHM6IHRydWUsIC8vIENPUlNcclxuXHR9O1xyXG59XHJcbmZ1bmN0aW9uIF9uZXdfSFRUUFJlcXVlc3RIYW5kbGVyRnVuY3Rpb25DYWxsaW5nRm4oZm4pIHtcclxuXHRyZXR1cm4gZnVuY3Rpb24oY29tcGxldGVVUkwsIGVycl9vclByb2dyZXNzRXZlbnQsIHJlcywgYm9keSkge1xyXG5cdFx0Ly8gZXJyIGFwcGVhcnMgdG8gYWN0dWFsbHkgYmUgYSBQcm9ncmVzc0V2ZW50XHJcblx0XHR2YXIgZXJyID0gbnVsbDtcclxuXHRcdGNvbnN0IHN0YXR1c0NvZGUgPSB0eXBlb2YgcmVzICE9PSBcInVuZGVmaW5lZFwiID8gcmVzLnN0YXR1c0NvZGUgOiAtMTtcclxuXHRcdGlmIChzdGF0dXNDb2RlID09IDAgfHwgc3RhdHVzQ29kZSA9PSAtMSkge1xyXG5cdFx0XHQvLyB3ZSdsbCB0cmVhdCAwIGFzIGEgbGFjayBvZiBpbnRlcm5ldCBjb25uZWN0aW9uLi4gdW5sZXNzIHRoZXJlJ3MgYSBiZXR0ZXIgd2F5IHRvIG1ha2UgdXNlIG9mIGVycl9vclByb2dyZXNzRXZlbnQgd2hpY2ggaXMgYXBwYXJlbnRseSBnb2luZyB0byBiZSB0eXBlb2YgUHJvZ3Jlc3NFdmVudCBoZXJlXHJcblx0XHRcdGVyciA9IG5ldyBFcnJvcihcIkNvbm5lY3Rpb24gRmFpbHVyZVwiKTtcclxuXHRcdH0gZWxzZSBpZiAoc3RhdHVzQ29kZSAhPT0gMjAwKSB7XHJcblx0XHRcdGNvbnN0IGJvZHlfRXJyb3IgPVxyXG5cdFx0XHRcdGJvZHkgJiYgdHlwZW9mIGJvZHkgPT0gXCJvYmplY3RcIiA/IGJvZHkuRXJyb3IgOiB1bmRlZmluZWQ7XHJcblx0XHRcdGNvbnN0IHN0YXR1c01lc3NhZ2UgPVxyXG5cdFx0XHRcdHJlcyAmJiByZXMuc3RhdHVzTWVzc2FnZSA/IHJlcy5zdGF0dXNNZXNzYWdlIDogdW5kZWZpbmVkO1xyXG5cdFx0XHRpZiAodHlwZW9mIGJvZHlfRXJyb3IgIT09IFwidW5kZWZpbmVkXCIgJiYgYm9keV9FcnJvcikge1xyXG5cdFx0XHRcdGVyciA9IG5ldyBFcnJvcihib2R5X0Vycm9yKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2Ygc3RhdHVzTWVzc2FnZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzdGF0dXNNZXNzYWdlKSB7XHJcblx0XHRcdFx0ZXJyID0gbmV3IEVycm9yKHN0YXR1c01lc3NhZ2UpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGVyciA9IG5ldyBFcnJvcihcIlVua25vd24gXCIgKyBzdGF0dXNDb2RlICsgXCIgZXJyb3JcIik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmIChlcnIpIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcihcIuKdjCAgXCIgKyBlcnIpO1xyXG5cdFx0XHQvLyBjb25zb2xlLmVycm9yKFwiQm9keTpcIiwgYm9keSlcclxuXHRcdFx0Zm4oZXJyLCBudWxsKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGpzb247XHJcblx0XHRpZiAodHlwZW9mIGJvZHkgPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRqc29uID0gSlNPTi5wYXJzZShib2R5KTtcclxuXHRcdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXHJcblx0XHRcdFx0XHRcIuKdjCAgSG9zdGVkTW9uZXJvQVBJQ2xpZW50IEVycm9yOiBVbmFibGUgdG8gcGFyc2UganNvbiB3aXRoIGV4Y2VwdGlvbjpcIixcclxuXHRcdFx0XHRcdGUsXHJcblx0XHRcdFx0XHRcIlxcbmJvZHk6XCIsXHJcblx0XHRcdFx0XHRib2R5LFxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdFx0Zm4oZSwgbnVsbCk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGpzb24gPSBib2R5O1xyXG5cdFx0fVxyXG5cdFx0Y29uc29sZS5sb2coXCLinIUgIFwiICsgY29tcGxldGVVUkwgKyBcIiBcIiArIHN0YXR1c0NvZGUpO1xyXG5cdFx0Zm4obnVsbCwganNvbik7XHJcblx0fTtcclxufVxyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./libs/mymonero-app-js/local_modules/mymonero_core_js/hostAPI/net_service_utils.js\n");

/***/ }),

/***/ "./libs/mymonero-app-js/local_modules/mymonero_core_js/hostAPI/response_parser_utils.js":
/*!**********************************************************************************************!*\
  !*** ./libs/mymonero-app-js/local_modules/mymonero_core_js/hostAPI/response_parser_utils.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2014-2018, MyMonero.com\r\n//\r\n// All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without modification, are\r\n// permitted provided that the following conditions are met:\r\n//\r\n// 1. Redistributions of source code must retain the above copyright notice, this list of\r\n//\tconditions and the following disclaimer.\r\n//\r\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list\r\n//\tof conditions and the following disclaimer in the documentation and/or other\r\n//\tmaterials provided with the distribution.\r\n//\r\n// 3. Neither the name of the copyright holder nor the names of its contributors may be\r\n//\tused to endorse or promote products derived from this software without specific\r\n//\tprior written permission.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\r\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\r\n// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\r\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n//\r\n\r\n//\r\nconst JSBigInt = __webpack_require__(/*! ../cryptonote_utils/biginteger */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/biginteger.js\").BigInteger;\r\nconst monero_amount_format_utils = __webpack_require__(/*! ../monero_utils/monero_amount_format_utils */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_amount_format_utils.js\");\r\nconst monero_keyImage_cache_utils = __webpack_require__(/*! ../monero_utils/monero_keyImage_cache_utils */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_keyImage_cache_utils.js\");\r\n//\r\nfunction Parsed_AddressInfo__sync(\r\n\tkeyImage_cache,\r\n\tdata,\r\n\taddress,\r\n\tview_key__private,\r\n\tspend_key__public,\r\n\tspend_key__private,\r\n\tmonero_utils,\r\n) {\r\n\t// -> returnValuesByKey\r\n\tconst total_received = new JSBigInt(data.total_received || 0);\r\n\tconst locked_balance = new JSBigInt(data.locked_funds || 0);\r\n\tvar total_sent = new JSBigInt(data.total_sent || 0); // will be modified in place\r\n\t//\r\n\tconst account_scanned_tx_height = data.scanned_height || 0;\r\n\tconst account_scanned_block_height = data.scanned_block_height || 0;\r\n\tconst account_scan_start_height = data.start_height || 0;\r\n\tconst transaction_height = data.transaction_height || 0;\r\n\tconst blockchain_height = data.blockchain_height || 0;\r\n\tconst spent_outputs = data.spent_outputs || [];\r\n\t//\r\n\tfor (let spent_output of spent_outputs) {\r\n\t\tvar key_image = monero_keyImage_cache_utils.Lazy_KeyImage(\r\n\t\t\tkeyImage_cache,\r\n\t\t\tspent_output.tx_pub_key,\r\n\t\t\tspent_output.out_index,\r\n\t\t\taddress,\r\n\t\t\tview_key__private,\r\n\t\t\tspend_key__public,\r\n\t\t\tspend_key__private,\r\n\t\t\tmonero_utils,\r\n\t\t);\r\n\t\tif (spent_output.key_image !== key_image) {\r\n\t\t\t// console.log('  Output used as mixin (' + spent_output.key_image + '/' + key_image + ')')\r\n\t\t\ttotal_sent = new JSBigInt(total_sent).subtract(spent_output.amount);\r\n\t\t}\r\n\t}\r\n\t//\r\n\tconst ratesBySymbol = data.rates || {}; // jic it's not there\r\n\t//\r\n\tconst returnValuesByKey = {\r\n\t\ttotal_received_String: total_received\r\n\t\t\t? total_received.toString()\r\n\t\t\t: null,\r\n\t\tlocked_balance_String: locked_balance\r\n\t\t\t? locked_balance.toString()\r\n\t\t\t: null,\r\n\t\ttotal_sent_String: total_sent ? total_sent.toString() : null,\r\n\t\t// ^serialized JSBigInt\r\n\t\tspent_outputs: spent_outputs,\r\n\t\taccount_scanned_tx_height: account_scanned_tx_height,\r\n\t\taccount_scanned_block_height: account_scanned_block_height,\r\n\t\taccount_scan_start_height: account_scan_start_height,\r\n\t\ttransaction_height: transaction_height,\r\n\t\tblockchain_height: blockchain_height,\r\n\t\t//\r\n\t\tratesBySymbol: ratesBySymbol,\r\n\t};\r\n\treturn returnValuesByKey;\r\n}\r\nfunction Parsed_AddressInfo__sync__keyImageManaged(\r\n\tdata,\r\n\taddress,\r\n\tview_key__private,\r\n\tspend_key__public,\r\n\tspend_key__private,\r\n\tmonero_utils,\r\n) {\r\n\t// -> returnValuesByKey\r\n\tconst keyImageCache = monero_keyImage_cache_utils.Lazy_KeyImageCacheForWalletWith(\r\n\t\taddress,\r\n\t);\r\n\treturn Parsed_AddressInfo__sync(\r\n\t\tkeyImageCache,\r\n\t\tdata,\r\n\t\taddress,\r\n\t\tview_key__private,\r\n\t\tspend_key__public,\r\n\t\tspend_key__private,\r\n\t\tmonero_utils,\r\n\t);\r\n}\r\nfunction Parsed_AddressInfo(\r\n\tkeyImage_cache,\r\n\tdata,\r\n\taddress,\r\n\tview_key__private,\r\n\tspend_key__public,\r\n\tspend_key__private,\r\n\tmonero_utils,\r\n\tfn, // (err?, returnValuesByKey) -> Void\r\n) {\r\n\tconst returnValuesByKey = Parsed_AddressInfo__sync(\r\n\t\tkeyImage_cache,\r\n\t\tdata,\r\n\t\taddress,\r\n\t\tview_key__private,\r\n\t\tspend_key__public,\r\n\t\tspend_key__private,\r\n\t\tmonero_utils,\r\n\t);\r\n\tfn(null, returnValuesByKey);\r\n}\r\nfunction Parsed_AddressInfo__keyImageManaged(\r\n\tdata,\r\n\taddress,\r\n\tview_key__private,\r\n\tspend_key__public,\r\n\tspend_key__private,\r\n\tmonero_utils,\r\n\tfn,\r\n) {\r\n\t// -> returnValuesByKey\r\n\tParsed_AddressInfo(\r\n\t\tmonero_keyImage_cache_utils.Lazy_KeyImageCacheForWalletWith(address),\r\n\t\tdata,\r\n\t\taddress,\r\n\t\tview_key__private,\r\n\t\tspend_key__public,\r\n\t\tspend_key__private,\r\n\t\tmonero_utils,\r\n\t\tfn,\r\n\t);\r\n}\r\nexports.Parsed_AddressInfo = Parsed_AddressInfo;\r\nexports.Parsed_AddressInfo__keyImageManaged = Parsed_AddressInfo__keyImageManaged; // in case you can't send a mutable key image cache dictionary\r\nexports.Parsed_AddressInfo__sync__keyImageManaged = Parsed_AddressInfo__sync__keyImageManaged; // in case you can't send a mutable key image cache dictionary\r\nexports.Parsed_AddressInfo__sync = Parsed_AddressInfo__sync;\r\n//\r\nfunction Parsed_AddressTransactions(\r\n\tkeyImage_cache,\r\n\tdata,\r\n\taddress,\r\n\tview_key__private,\r\n\tspend_key__public,\r\n\tspend_key__private,\r\n\tmonero_utils,\r\n\tfn, // (err?, returnValuesByKey) -> Void\r\n) {\r\n\tconst returnValuesByKey = Parsed_AddressTransactions__sync(\r\n\t\tkeyImage_cache,\r\n\t\tdata,\r\n\t\taddress,\r\n\t\tview_key__private,\r\n\t\tspend_key__public,\r\n\t\tspend_key__private,\r\n\t\tmonero_utils,\r\n\t);\r\n\tfn(null, returnValuesByKey);\r\n}\r\nfunction Parsed_AddressTransactions__sync(\r\n\tkeyImage_cache,\r\n\tdata,\r\n\taddress,\r\n\tview_key__private,\r\n\tspend_key__public,\r\n\tspend_key__private,\r\n\tmonero_utils,\r\n) {\r\n\tconst account_scanned_height = data.scanned_height || 0;\r\n\tconst account_scanned_block_height = data.scanned_block_height || 0;\r\n\tconst account_scan_start_height = data.start_height || 0;\r\n\tconst transaction_height = data.transaction_height || 0;\r\n\tconst blockchain_height = data.blockchain_height || 0;\r\n\t//\r\n\tconst transactions = data.transactions || [];\r\n\t//\r\n\t// TODO: rewrite this with more clarity if possible\r\n\tfor (let i = 0; i < transactions.length; ++i) {\r\n\t\tif ((transactions[i].spent_outputs || []).length > 0) {\r\n\t\t\tfor (var j = 0; j < transactions[i].spent_outputs.length; ++j) {\r\n\t\t\t\tvar key_image = monero_keyImage_cache_utils.Lazy_KeyImage(\r\n\t\t\t\t\tkeyImage_cache,\r\n\t\t\t\t\ttransactions[i].spent_outputs[j].tx_pub_key,\r\n\t\t\t\t\ttransactions[i].spent_outputs[j].out_index,\r\n\t\t\t\t\taddress,\r\n\t\t\t\t\tview_key__private,\r\n\t\t\t\t\tspend_key__public,\r\n\t\t\t\t\tspend_key__private,\r\n\t\t\t\t\tmonero_utils,\r\n\t\t\t\t);\r\n\t\t\t\tif (transactions[i].spent_outputs[j].key_image !== key_image) {\r\n\t\t\t\t\t// console.log('Output used as mixin, ignoring (' + transactions[i].spent_outputs[j].key_image + '/' + key_image + ')')\r\n\t\t\t\t\ttransactions[i].total_sent = new JSBigInt(\r\n\t\t\t\t\t\ttransactions[i].total_sent,\r\n\t\t\t\t\t)\r\n\t\t\t\t\t\t.subtract(transactions[i].spent_outputs[j].amount)\r\n\t\t\t\t\t\t.toString();\r\n\t\t\t\t\ttransactions[i].spent_outputs.splice(j, 1);\r\n\t\t\t\t\tj--;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (\r\n\t\t\tnew JSBigInt(transactions[i].total_received || 0)\r\n\t\t\t\t.add(transactions[i].total_sent || 0)\r\n\t\t\t\t.compare(0) <= 0\r\n\t\t) {\r\n\t\t\ttransactions.splice(i, 1);\r\n\t\t\ti--;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\ttransactions[i].amount = new JSBigInt(\r\n\t\t\ttransactions[i].total_received || 0,\r\n\t\t)\r\n\t\t\t.subtract(transactions[i].total_sent || 0)\r\n\t\t\t.toString();\r\n\t\ttransactions[i].approx_float_amount = parseFloat(\r\n\t\t\tmonero_amount_format_utils.formatMoney(transactions[i].amount),\r\n\t\t);\r\n\t\ttransactions[i].timestamp = transactions[i].timestamp;\r\n\t\tconst record__payment_id = transactions[i].payment_id;\r\n\t\tif (typeof record__payment_id !== \"undefined\" && record__payment_id) {\r\n\t\t\tif (record__payment_id.length == 16) {\r\n\t\t\t\t// short (encrypted) pid\r\n\t\t\t\tif (transactions[i].approx_float_amount < 0) {\r\n\t\t\t\t\t// outgoing\r\n\t\t\t\t\tdelete transactions[i][\"payment_id\"]; // need to filter these out .. because the server can't filter out short (encrypted) pids on outgoing txs\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\ttransactions.sort(function(a, b) {\r\n\t\tif (a.mempool == true) {\r\n\t\t\tif (b.mempool != true) {\r\n\t\t\t\treturn -1; // a first\r\n\t\t\t}\r\n\t\t\t// both mempool - fall back to .id compare\r\n\t\t} else if (b.mempool == true) {\r\n\t\t\treturn 1; // b first\r\n\t\t}\r\n\t\treturn b.id - a.id;\r\n\t});\r\n\t// prepare transactions to be serialized\r\n\tfor (let transaction of transactions) {\r\n\t\ttransaction.amount = transaction.amount.toString(); // JSBigInt -> String\r\n\t\tif (\r\n\t\t\ttypeof transaction.total_sent !== \"undefined\" &&\r\n\t\t\ttransaction.total_sent !== null\r\n\t\t) {\r\n\t\t\ttransaction.total_sent = transaction.total_sent.toString();\r\n\t\t}\r\n\t}\r\n\t// on the other side, we convert transactions timestamp to Date obj\r\n\tconst returnValuesByKey = {\r\n\t\taccount_scanned_height: account_scanned_height,\r\n\t\taccount_scanned_block_height: account_scanned_block_height,\r\n\t\taccount_scan_start_height: account_scan_start_height,\r\n\t\ttransaction_height: transaction_height,\r\n\t\tblockchain_height: blockchain_height,\r\n\t\tserialized_transactions: transactions,\r\n\t};\r\n\treturn returnValuesByKey;\r\n}\r\nfunction Parsed_AddressTransactions__sync__keyImageManaged(\r\n\tdata,\r\n\taddress,\r\n\tview_key__private,\r\n\tspend_key__public,\r\n\tspend_key__private,\r\n\tmonero_utils,\r\n) {\r\n\tconst keyImageCache = monero_keyImage_cache_utils.Lazy_KeyImageCacheForWalletWith(\r\n\t\taddress,\r\n\t);\r\n\treturn Parsed_AddressTransactions__sync(\r\n\t\tkeyImageCache,\r\n\t\tdata,\r\n\t\taddress,\r\n\t\tview_key__private,\r\n\t\tspend_key__public,\r\n\t\tspend_key__private,\r\n\t\tmonero_utils,\r\n\t);\r\n}\r\nfunction Parsed_AddressTransactions__keyImageManaged(\r\n\tdata,\r\n\taddress,\r\n\tview_key__private,\r\n\tspend_key__public,\r\n\tspend_key__private,\r\n\tmonero_utils,\r\n\tfn,\r\n) {\r\n\tParsed_AddressTransactions(\r\n\t\tmonero_keyImage_cache_utils.Lazy_KeyImageCacheForWalletWith(address),\r\n\t\tdata,\r\n\t\taddress,\r\n\t\tview_key__private,\r\n\t\tspend_key__public,\r\n\t\tspend_key__private,\r\n\t\tmonero_utils,\r\n\t\tfn,\r\n\t);\r\n}\r\nexports.Parsed_AddressTransactions = Parsed_AddressTransactions;\r\nexports.Parsed_AddressTransactions__keyImageManaged = Parsed_AddressTransactions__keyImageManaged;\r\nexports.Parsed_AddressTransactions__sync = Parsed_AddressTransactions__sync;\r\nexports.Parsed_AddressTransactions__sync__keyImageManaged = Parsed_AddressTransactions__sync__keyImageManaged;\r\n//\r\nfunction Parsed_UnspentOuts(\r\n\tkeyImage_cache,\r\n\tdata,\r\n\taddress,\r\n\tview_key__private,\r\n\tspend_key__public,\r\n\tspend_key__private,\r\n\tmonero_utils,\r\n\tfn, // (err?, returnValuesByKey)\r\n) {\r\n\tconst returnValuesByKey = Parsed_UnspentOuts__sync(\r\n\t\tkeyImage_cache,\r\n\t\tdata,\r\n\t\taddress,\r\n\t\tview_key__private,\r\n\t\tspend_key__public,\r\n\t\tspend_key__private,\r\n\t\tmonero_utils,\r\n\t);\r\n\tfn(null, returnValuesByKey);\r\n}\r\nfunction Parsed_UnspentOuts__sync(\r\n\tkeyImage_cache,\r\n\tdata,\r\n\taddress,\r\n\tview_key__private,\r\n\tspend_key__public,\r\n\tspend_key__private,\r\n\tmonero_utils\r\n) {\r\n\tconst data_outputs = data.outputs;\r\n\tconst finalized_unspentOutputs = data.outputs || []; // to finalize:\r\n\tfor (var i = 0; i < finalized_unspentOutputs.length; i++) {\r\n\t\tconst unspent_output = finalized_unspentOutputs[i];\r\n\t\tif (\r\n\t\t\tunspent_output === null ||\r\n\t\t\ttypeof unspent_output === \"undefined\" ||\r\n\t\t\t!unspent_output // just preserving what was in the original code\r\n\t\t) {\r\n\t\t\tthrow \"unspent_output at index \" + i + \" was null\";\r\n\t\t}\r\n\t\tconst spend_key_images = unspent_output.spend_key_images;\r\n\t\tif (\r\n\t\t\tspend_key_images === null ||\r\n\t\t\ttypeof spend_key_images === \"undefined\"\r\n\t\t) {\r\n\t\t\tthrow \"spend_key_images of unspent_output at index \" +\r\n\t\t\t\ti +\r\n\t\t\t\t\" was null\";\r\n\t\t}\r\n\t\tfor (var j = 0; j < spend_key_images.length; j++) {\r\n\t\t\tconst finalized_unspentOutput_atI_beforeSplice =\r\n\t\t\t\tfinalized_unspentOutputs[i];\r\n\t\t\tif (\r\n\t\t\t\t!finalized_unspentOutput_atI_beforeSplice ||\r\n\t\t\t\ttypeof finalized_unspentOutput_atI_beforeSplice === \"undefined\"\r\n\t\t\t) {\r\n\t\t\t\t// console.warn(\r\n\t\t\t\t// \t`This unspent output at i ${i} was literally undefined! Skipping.`,\r\n\t\t\t\t// ); // NOTE: Looks like the i-- code below should exit earlier if this is necessary\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tconst beforeSplice__tx_pub_key =\r\n\t\t\t\tfinalized_unspentOutput_atI_beforeSplice.tx_pub_key;\r\n\t\t\tconst beforeSplice__index =\r\n\t\t\t\tfinalized_unspentOutput_atI_beforeSplice.index;\r\n\t\t\tif (\r\n\t\t\t\ttypeof beforeSplice__tx_pub_key === \"undefined\" ||\r\n\t\t\t\t!beforeSplice__tx_pub_key\r\n\t\t\t) {\r\n\t\t\t\tconsole.warn(\r\n\t\t\t\t\t\"This unspent out was missing a tx_pub_key! Skipping.\",\r\n\t\t\t\t\tfinalized_unspentOutput_atI_beforeSplice,\r\n\t\t\t\t);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tvar key_image = monero_keyImage_cache_utils.Lazy_KeyImage(\r\n\t\t\t\tkeyImage_cache,\r\n\t\t\t\tbeforeSplice__tx_pub_key,\r\n\t\t\t\tbeforeSplice__index,\r\n\t\t\t\taddress,\r\n\t\t\t\tview_key__private,\r\n\t\t\t\tspend_key__public,\r\n\t\t\t\tspend_key__private,\r\n\t\t\t\tmonero_utils\r\n\t\t\t);\r\n\t\t\tif (\r\n\t\t\t\tkey_image ===\r\n\t\t\t\tfinalized_unspentOutput_atI_beforeSplice.spend_key_images[j]\r\n\t\t\t) {\r\n\t\t\t\t// console.log(\"  Output was spent; key image: \" + key_image + \" amount: \" + monero_amount_format_utils.formatMoneyFull(finalized_unspentOutputs[i].amount));\r\n\t\t\t\t// Remove output from list\r\n\t\t\t\tfinalized_unspentOutputs.splice(i, 1);\r\n\t\t\t\tconst finalized_unspentOutput_atI_afterSplice =\r\n\t\t\t\t\tfinalized_unspentOutputs[i];\r\n\t\t\t\tif (finalized_unspentOutput_atI_afterSplice) {\r\n\t\t\t\t\tj =\r\n\t\t\t\t\t\tfinalized_unspentOutput_atI_afterSplice.spend_key_images\r\n\t\t\t\t\t\t\t.length;\r\n\t\t\t\t}\r\n\t\t\t\ti--;\r\n\t\t\t} else {\r\n\t\t\t\t// console.log(\r\n\t\t\t\t// \t\"  Output used as mixin (\" +\r\n\t\t\t\t// \t\tkey_image +\r\n\t\t\t\t// \t\t\"/\" +\r\n\t\t\t\t// \t\tfinalized_unspentOutputs[i].spend_key_images[j] +\r\n\t\t\t\t// \t\t\")\",\r\n\t\t\t\t// );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// console.log(\"Unspent outs: \" + JSON.stringify(finalized_unspentOutputs));\r\n\tvar final__per_byte_fee__string;\r\n\tif (typeof data.per_byte_fee !== 'undefined' && data.per_byte_fee) {\r\n\t\tfinal__per_byte_fee__string = data.per_byte_fee // (is already string)\r\n\t} else { // per_byte_fee not yet deployed - fall back to per_kb_fee\r\n\t\tif (typeof data.per_kb_fee == 'undefined' || !data.per_kb_fee) {\r\n\t\t\tthrow \"Expected data.per_kb_fee or data.per_byte_fee\"\r\n\t\t}\r\n\t\tfinal__per_byte_fee__string = (new JSBigInt(data.per_kb_fee)).divide(1024).toString() // scale from kib to b and convert back to string\r\n\t}\r\n\tif (typeof final__per_byte_fee__string == 'undefined' || !final__per_byte_fee__string) {\r\n\t\tthrow \"Unable to derive per_byte_fee string\"\r\n\t}\r\n\tconst returnValuesByKey = {\r\n\t\tunspentOutputs: finalized_unspentOutputs,\r\n\t\tper_byte_fee__string: final__per_byte_fee__string, // String\r\n\t};\r\n\treturn returnValuesByKey;\r\n}\r\nfunction Parsed_UnspentOuts__sync__keyImageManaged(\r\n\tdata,\r\n\taddress,\r\n\tview_key__private,\r\n\tspend_key__public,\r\n\tspend_key__private,\r\n\tmonero_utils,\r\n) {\r\n\tconst keyImageCache = monero_keyImage_cache_utils.Lazy_KeyImageCacheForWalletWith(\r\n\t\taddress,\r\n\t);\r\n\treturn Parsed_UnspentOuts__sync(\r\n\t\tkeyImageCache,\r\n\t\tdata,\r\n\t\taddress,\r\n\t\tview_key__private,\r\n\t\tspend_key__public,\r\n\t\tspend_key__private,\r\n\t\tmonero_utils,\r\n\t);\r\n}\r\nfunction Parsed_UnspentOuts__keyImageManaged(\r\n\tdata,\r\n\taddress,\r\n\tview_key__private,\r\n\tspend_key__public,\r\n\tspend_key__private,\r\n\tmonero_utils,\r\n\tfn,\r\n) {\r\n\tParsed_UnspentOuts(\r\n\t\tmonero_keyImage_cache_utils.Lazy_KeyImageCacheForWalletWith(address),\r\n\t\tdata,\r\n\t\taddress,\r\n\t\tview_key__private,\r\n\t\tspend_key__public,\r\n\t\tspend_key__private,\r\n\t\tmonero_utils,\r\n\t\tfn,\r\n\t);\r\n}\r\nexports.Parsed_UnspentOuts = Parsed_UnspentOuts;\r\nexports.Parsed_UnspentOuts__keyImageManaged = Parsed_UnspentOuts__keyImageManaged;\r\nexports.Parsed_UnspentOuts__sync = Parsed_UnspentOuts__sync;\r\nexports.Parsed_UnspentOuts__sync__keyImageManaged = Parsed_UnspentOuts__sync__keyImageManaged;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvaG9zdEFQSS9yZXNwb25zZV9wYXJzZXJfdXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvaG9zdEFQSS9yZXNwb25zZV9wYXJzZXJfdXRpbHMuanM/MWQ0OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxOCwgTXlNb25lcm8uY29tXHJcbi8vXHJcbi8vIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vXHJcbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZVxyXG4vLyBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuLy9cclxuLy8gMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2ZcclxuLy9cdGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuLy9cclxuLy8gMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3RcclxuLy9cdG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXJcclxuLy9cdG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbi8vXHJcbi8vIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGNvcHlyaWdodCBob2xkZXIgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZVxyXG4vL1x0dXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xyXG4vL1x0cHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4vL1xyXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkQgQU5ZXHJcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRlxyXG4vLyBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTFxyXG4vLyBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcclxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxyXG4vLyBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcclxuLy8gSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsXHJcbi8vIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxyXG4vLyBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbi8vXHJcblwidXNlIHN0cmljdFwiO1xyXG4vL1xyXG5jb25zdCBKU0JpZ0ludCA9IHJlcXVpcmUoXCIuLi9jcnlwdG9ub3RlX3V0aWxzL2JpZ2ludGVnZXJcIikuQmlnSW50ZWdlcjtcclxuY29uc3QgbW9uZXJvX2Ftb3VudF9mb3JtYXRfdXRpbHMgPSByZXF1aXJlKFwiLi4vbW9uZXJvX3V0aWxzL21vbmVyb19hbW91bnRfZm9ybWF0X3V0aWxzXCIpO1xyXG5jb25zdCBtb25lcm9fa2V5SW1hZ2VfY2FjaGVfdXRpbHMgPSByZXF1aXJlKFwiLi4vbW9uZXJvX3V0aWxzL21vbmVyb19rZXlJbWFnZV9jYWNoZV91dGlsc1wiKTtcclxuLy9cclxuZnVuY3Rpb24gUGFyc2VkX0FkZHJlc3NJbmZvX19zeW5jKFxyXG5cdGtleUltYWdlX2NhY2hlLFxyXG5cdGRhdGEsXHJcblx0YWRkcmVzcyxcclxuXHR2aWV3X2tleV9fcHJpdmF0ZSxcclxuXHRzcGVuZF9rZXlfX3B1YmxpYyxcclxuXHRzcGVuZF9rZXlfX3ByaXZhdGUsXHJcblx0bW9uZXJvX3V0aWxzLFxyXG4pIHtcclxuXHQvLyAtPiByZXR1cm5WYWx1ZXNCeUtleVxyXG5cdGNvbnN0IHRvdGFsX3JlY2VpdmVkID0gbmV3IEpTQmlnSW50KGRhdGEudG90YWxfcmVjZWl2ZWQgfHwgMCk7XHJcblx0Y29uc3QgbG9ja2VkX2JhbGFuY2UgPSBuZXcgSlNCaWdJbnQoZGF0YS5sb2NrZWRfZnVuZHMgfHwgMCk7XHJcblx0dmFyIHRvdGFsX3NlbnQgPSBuZXcgSlNCaWdJbnQoZGF0YS50b3RhbF9zZW50IHx8IDApOyAvLyB3aWxsIGJlIG1vZGlmaWVkIGluIHBsYWNlXHJcblx0Ly9cclxuXHRjb25zdCBhY2NvdW50X3NjYW5uZWRfdHhfaGVpZ2h0ID0gZGF0YS5zY2FubmVkX2hlaWdodCB8fCAwO1xyXG5cdGNvbnN0IGFjY291bnRfc2Nhbm5lZF9ibG9ja19oZWlnaHQgPSBkYXRhLnNjYW5uZWRfYmxvY2tfaGVpZ2h0IHx8IDA7XHJcblx0Y29uc3QgYWNjb3VudF9zY2FuX3N0YXJ0X2hlaWdodCA9IGRhdGEuc3RhcnRfaGVpZ2h0IHx8IDA7XHJcblx0Y29uc3QgdHJhbnNhY3Rpb25faGVpZ2h0ID0gZGF0YS50cmFuc2FjdGlvbl9oZWlnaHQgfHwgMDtcclxuXHRjb25zdCBibG9ja2NoYWluX2hlaWdodCA9IGRhdGEuYmxvY2tjaGFpbl9oZWlnaHQgfHwgMDtcclxuXHRjb25zdCBzcGVudF9vdXRwdXRzID0gZGF0YS5zcGVudF9vdXRwdXRzIHx8IFtdO1xyXG5cdC8vXHJcblx0Zm9yIChsZXQgc3BlbnRfb3V0cHV0IG9mIHNwZW50X291dHB1dHMpIHtcclxuXHRcdHZhciBrZXlfaW1hZ2UgPSBtb25lcm9fa2V5SW1hZ2VfY2FjaGVfdXRpbHMuTGF6eV9LZXlJbWFnZShcclxuXHRcdFx0a2V5SW1hZ2VfY2FjaGUsXHJcblx0XHRcdHNwZW50X291dHB1dC50eF9wdWJfa2V5LFxyXG5cdFx0XHRzcGVudF9vdXRwdXQub3V0X2luZGV4LFxyXG5cdFx0XHRhZGRyZXNzLFxyXG5cdFx0XHR2aWV3X2tleV9fcHJpdmF0ZSxcclxuXHRcdFx0c3BlbmRfa2V5X19wdWJsaWMsXHJcblx0XHRcdHNwZW5kX2tleV9fcHJpdmF0ZSxcclxuXHRcdFx0bW9uZXJvX3V0aWxzLFxyXG5cdFx0KTtcclxuXHRcdGlmIChzcGVudF9vdXRwdXQua2V5X2ltYWdlICE9PSBrZXlfaW1hZ2UpIHtcclxuXHRcdFx0Ly8gY29uc29sZS5sb2coJ/CfkqwgIE91dHB1dCB1c2VkIGFzIG1peGluICgnICsgc3BlbnRfb3V0cHV0LmtleV9pbWFnZSArICcvJyArIGtleV9pbWFnZSArICcpJylcclxuXHRcdFx0dG90YWxfc2VudCA9IG5ldyBKU0JpZ0ludCh0b3RhbF9zZW50KS5zdWJ0cmFjdChzcGVudF9vdXRwdXQuYW1vdW50KTtcclxuXHRcdH1cclxuXHR9XHJcblx0Ly9cclxuXHRjb25zdCByYXRlc0J5U3ltYm9sID0gZGF0YS5yYXRlcyB8fCB7fTsgLy8gamljIGl0J3Mgbm90IHRoZXJlXHJcblx0Ly9cclxuXHRjb25zdCByZXR1cm5WYWx1ZXNCeUtleSA9IHtcclxuXHRcdHRvdGFsX3JlY2VpdmVkX1N0cmluZzogdG90YWxfcmVjZWl2ZWRcclxuXHRcdFx0PyB0b3RhbF9yZWNlaXZlZC50b1N0cmluZygpXHJcblx0XHRcdDogbnVsbCxcclxuXHRcdGxvY2tlZF9iYWxhbmNlX1N0cmluZzogbG9ja2VkX2JhbGFuY2VcclxuXHRcdFx0PyBsb2NrZWRfYmFsYW5jZS50b1N0cmluZygpXHJcblx0XHRcdDogbnVsbCxcclxuXHRcdHRvdGFsX3NlbnRfU3RyaW5nOiB0b3RhbF9zZW50ID8gdG90YWxfc2VudC50b1N0cmluZygpIDogbnVsbCxcclxuXHRcdC8vIF5zZXJpYWxpemVkIEpTQmlnSW50XHJcblx0XHRzcGVudF9vdXRwdXRzOiBzcGVudF9vdXRwdXRzLFxyXG5cdFx0YWNjb3VudF9zY2FubmVkX3R4X2hlaWdodDogYWNjb3VudF9zY2FubmVkX3R4X2hlaWdodCxcclxuXHRcdGFjY291bnRfc2Nhbm5lZF9ibG9ja19oZWlnaHQ6IGFjY291bnRfc2Nhbm5lZF9ibG9ja19oZWlnaHQsXHJcblx0XHRhY2NvdW50X3NjYW5fc3RhcnRfaGVpZ2h0OiBhY2NvdW50X3NjYW5fc3RhcnRfaGVpZ2h0LFxyXG5cdFx0dHJhbnNhY3Rpb25faGVpZ2h0OiB0cmFuc2FjdGlvbl9oZWlnaHQsXHJcblx0XHRibG9ja2NoYWluX2hlaWdodDogYmxvY2tjaGFpbl9oZWlnaHQsXHJcblx0XHQvL1xyXG5cdFx0cmF0ZXNCeVN5bWJvbDogcmF0ZXNCeVN5bWJvbCxcclxuXHR9O1xyXG5cdHJldHVybiByZXR1cm5WYWx1ZXNCeUtleTtcclxufVxyXG5mdW5jdGlvbiBQYXJzZWRfQWRkcmVzc0luZm9fX3N5bmNfX2tleUltYWdlTWFuYWdlZChcclxuXHRkYXRhLFxyXG5cdGFkZHJlc3MsXHJcblx0dmlld19rZXlfX3ByaXZhdGUsXHJcblx0c3BlbmRfa2V5X19wdWJsaWMsXHJcblx0c3BlbmRfa2V5X19wcml2YXRlLFxyXG5cdG1vbmVyb191dGlscyxcclxuKSB7XHJcblx0Ly8gLT4gcmV0dXJuVmFsdWVzQnlLZXlcclxuXHRjb25zdCBrZXlJbWFnZUNhY2hlID0gbW9uZXJvX2tleUltYWdlX2NhY2hlX3V0aWxzLkxhenlfS2V5SW1hZ2VDYWNoZUZvcldhbGxldFdpdGgoXHJcblx0XHRhZGRyZXNzLFxyXG5cdCk7XHJcblx0cmV0dXJuIFBhcnNlZF9BZGRyZXNzSW5mb19fc3luYyhcclxuXHRcdGtleUltYWdlQ2FjaGUsXHJcblx0XHRkYXRhLFxyXG5cdFx0YWRkcmVzcyxcclxuXHRcdHZpZXdfa2V5X19wcml2YXRlLFxyXG5cdFx0c3BlbmRfa2V5X19wdWJsaWMsXHJcblx0XHRzcGVuZF9rZXlfX3ByaXZhdGUsXHJcblx0XHRtb25lcm9fdXRpbHMsXHJcblx0KTtcclxufVxyXG5mdW5jdGlvbiBQYXJzZWRfQWRkcmVzc0luZm8oXHJcblx0a2V5SW1hZ2VfY2FjaGUsXHJcblx0ZGF0YSxcclxuXHRhZGRyZXNzLFxyXG5cdHZpZXdfa2V5X19wcml2YXRlLFxyXG5cdHNwZW5kX2tleV9fcHVibGljLFxyXG5cdHNwZW5kX2tleV9fcHJpdmF0ZSxcclxuXHRtb25lcm9fdXRpbHMsXHJcblx0Zm4sIC8vIChlcnI/LCByZXR1cm5WYWx1ZXNCeUtleSkgLT4gVm9pZFxyXG4pIHtcclxuXHRjb25zdCByZXR1cm5WYWx1ZXNCeUtleSA9IFBhcnNlZF9BZGRyZXNzSW5mb19fc3luYyhcclxuXHRcdGtleUltYWdlX2NhY2hlLFxyXG5cdFx0ZGF0YSxcclxuXHRcdGFkZHJlc3MsXHJcblx0XHR2aWV3X2tleV9fcHJpdmF0ZSxcclxuXHRcdHNwZW5kX2tleV9fcHVibGljLFxyXG5cdFx0c3BlbmRfa2V5X19wcml2YXRlLFxyXG5cdFx0bW9uZXJvX3V0aWxzLFxyXG5cdCk7XHJcblx0Zm4obnVsbCwgcmV0dXJuVmFsdWVzQnlLZXkpO1xyXG59XHJcbmZ1bmN0aW9uIFBhcnNlZF9BZGRyZXNzSW5mb19fa2V5SW1hZ2VNYW5hZ2VkKFxyXG5cdGRhdGEsXHJcblx0YWRkcmVzcyxcclxuXHR2aWV3X2tleV9fcHJpdmF0ZSxcclxuXHRzcGVuZF9rZXlfX3B1YmxpYyxcclxuXHRzcGVuZF9rZXlfX3ByaXZhdGUsXHJcblx0bW9uZXJvX3V0aWxzLFxyXG5cdGZuLFxyXG4pIHtcclxuXHQvLyAtPiByZXR1cm5WYWx1ZXNCeUtleVxyXG5cdFBhcnNlZF9BZGRyZXNzSW5mbyhcclxuXHRcdG1vbmVyb19rZXlJbWFnZV9jYWNoZV91dGlscy5MYXp5X0tleUltYWdlQ2FjaGVGb3JXYWxsZXRXaXRoKGFkZHJlc3MpLFxyXG5cdFx0ZGF0YSxcclxuXHRcdGFkZHJlc3MsXHJcblx0XHR2aWV3X2tleV9fcHJpdmF0ZSxcclxuXHRcdHNwZW5kX2tleV9fcHVibGljLFxyXG5cdFx0c3BlbmRfa2V5X19wcml2YXRlLFxyXG5cdFx0bW9uZXJvX3V0aWxzLFxyXG5cdFx0Zm4sXHJcblx0KTtcclxufVxyXG5leHBvcnRzLlBhcnNlZF9BZGRyZXNzSW5mbyA9IFBhcnNlZF9BZGRyZXNzSW5mbztcclxuZXhwb3J0cy5QYXJzZWRfQWRkcmVzc0luZm9fX2tleUltYWdlTWFuYWdlZCA9IFBhcnNlZF9BZGRyZXNzSW5mb19fa2V5SW1hZ2VNYW5hZ2VkOyAvLyBpbiBjYXNlIHlvdSBjYW4ndCBzZW5kIGEgbXV0YWJsZSBrZXkgaW1hZ2UgY2FjaGUgZGljdGlvbmFyeVxyXG5leHBvcnRzLlBhcnNlZF9BZGRyZXNzSW5mb19fc3luY19fa2V5SW1hZ2VNYW5hZ2VkID0gUGFyc2VkX0FkZHJlc3NJbmZvX19zeW5jX19rZXlJbWFnZU1hbmFnZWQ7IC8vIGluIGNhc2UgeW91IGNhbid0IHNlbmQgYSBtdXRhYmxlIGtleSBpbWFnZSBjYWNoZSBkaWN0aW9uYXJ5XHJcbmV4cG9ydHMuUGFyc2VkX0FkZHJlc3NJbmZvX19zeW5jID0gUGFyc2VkX0FkZHJlc3NJbmZvX19zeW5jO1xyXG4vL1xyXG5mdW5jdGlvbiBQYXJzZWRfQWRkcmVzc1RyYW5zYWN0aW9ucyhcclxuXHRrZXlJbWFnZV9jYWNoZSxcclxuXHRkYXRhLFxyXG5cdGFkZHJlc3MsXHJcblx0dmlld19rZXlfX3ByaXZhdGUsXHJcblx0c3BlbmRfa2V5X19wdWJsaWMsXHJcblx0c3BlbmRfa2V5X19wcml2YXRlLFxyXG5cdG1vbmVyb191dGlscyxcclxuXHRmbiwgLy8gKGVycj8sIHJldHVyblZhbHVlc0J5S2V5KSAtPiBWb2lkXHJcbikge1xyXG5cdGNvbnN0IHJldHVyblZhbHVlc0J5S2V5ID0gUGFyc2VkX0FkZHJlc3NUcmFuc2FjdGlvbnNfX3N5bmMoXHJcblx0XHRrZXlJbWFnZV9jYWNoZSxcclxuXHRcdGRhdGEsXHJcblx0XHRhZGRyZXNzLFxyXG5cdFx0dmlld19rZXlfX3ByaXZhdGUsXHJcblx0XHRzcGVuZF9rZXlfX3B1YmxpYyxcclxuXHRcdHNwZW5kX2tleV9fcHJpdmF0ZSxcclxuXHRcdG1vbmVyb191dGlscyxcclxuXHQpO1xyXG5cdGZuKG51bGwsIHJldHVyblZhbHVlc0J5S2V5KTtcclxufVxyXG5mdW5jdGlvbiBQYXJzZWRfQWRkcmVzc1RyYW5zYWN0aW9uc19fc3luYyhcclxuXHRrZXlJbWFnZV9jYWNoZSxcclxuXHRkYXRhLFxyXG5cdGFkZHJlc3MsXHJcblx0dmlld19rZXlfX3ByaXZhdGUsXHJcblx0c3BlbmRfa2V5X19wdWJsaWMsXHJcblx0c3BlbmRfa2V5X19wcml2YXRlLFxyXG5cdG1vbmVyb191dGlscyxcclxuKSB7XHJcblx0Y29uc3QgYWNjb3VudF9zY2FubmVkX2hlaWdodCA9IGRhdGEuc2Nhbm5lZF9oZWlnaHQgfHwgMDtcclxuXHRjb25zdCBhY2NvdW50X3NjYW5uZWRfYmxvY2tfaGVpZ2h0ID0gZGF0YS5zY2FubmVkX2Jsb2NrX2hlaWdodCB8fCAwO1xyXG5cdGNvbnN0IGFjY291bnRfc2Nhbl9zdGFydF9oZWlnaHQgPSBkYXRhLnN0YXJ0X2hlaWdodCB8fCAwO1xyXG5cdGNvbnN0IHRyYW5zYWN0aW9uX2hlaWdodCA9IGRhdGEudHJhbnNhY3Rpb25faGVpZ2h0IHx8IDA7XHJcblx0Y29uc3QgYmxvY2tjaGFpbl9oZWlnaHQgPSBkYXRhLmJsb2NrY2hhaW5faGVpZ2h0IHx8IDA7XHJcblx0Ly9cclxuXHRjb25zdCB0cmFuc2FjdGlvbnMgPSBkYXRhLnRyYW5zYWN0aW9ucyB8fCBbXTtcclxuXHQvL1xyXG5cdC8vIFRPRE86IHJld3JpdGUgdGhpcyB3aXRoIG1vcmUgY2xhcml0eSBpZiBwb3NzaWJsZVxyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNhY3Rpb25zLmxlbmd0aDsgKytpKSB7XHJcblx0XHRpZiAoKHRyYW5zYWN0aW9uc1tpXS5zcGVudF9vdXRwdXRzIHx8IFtdKS5sZW5ndGggPiAwKSB7XHJcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgdHJhbnNhY3Rpb25zW2ldLnNwZW50X291dHB1dHMubGVuZ3RoOyArK2opIHtcclxuXHRcdFx0XHR2YXIga2V5X2ltYWdlID0gbW9uZXJvX2tleUltYWdlX2NhY2hlX3V0aWxzLkxhenlfS2V5SW1hZ2UoXHJcblx0XHRcdFx0XHRrZXlJbWFnZV9jYWNoZSxcclxuXHRcdFx0XHRcdHRyYW5zYWN0aW9uc1tpXS5zcGVudF9vdXRwdXRzW2pdLnR4X3B1Yl9rZXksXHJcblx0XHRcdFx0XHR0cmFuc2FjdGlvbnNbaV0uc3BlbnRfb3V0cHV0c1tqXS5vdXRfaW5kZXgsXHJcblx0XHRcdFx0XHRhZGRyZXNzLFxyXG5cdFx0XHRcdFx0dmlld19rZXlfX3ByaXZhdGUsXHJcblx0XHRcdFx0XHRzcGVuZF9rZXlfX3B1YmxpYyxcclxuXHRcdFx0XHRcdHNwZW5kX2tleV9fcHJpdmF0ZSxcclxuXHRcdFx0XHRcdG1vbmVyb191dGlscyxcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHRcdGlmICh0cmFuc2FjdGlvbnNbaV0uc3BlbnRfb3V0cHV0c1tqXS5rZXlfaW1hZ2UgIT09IGtleV9pbWFnZSkge1xyXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ091dHB1dCB1c2VkIGFzIG1peGluLCBpZ25vcmluZyAoJyArIHRyYW5zYWN0aW9uc1tpXS5zcGVudF9vdXRwdXRzW2pdLmtleV9pbWFnZSArICcvJyArIGtleV9pbWFnZSArICcpJylcclxuXHRcdFx0XHRcdHRyYW5zYWN0aW9uc1tpXS50b3RhbF9zZW50ID0gbmV3IEpTQmlnSW50KFxyXG5cdFx0XHRcdFx0XHR0cmFuc2FjdGlvbnNbaV0udG90YWxfc2VudCxcclxuXHRcdFx0XHRcdClcclxuXHRcdFx0XHRcdFx0LnN1YnRyYWN0KHRyYW5zYWN0aW9uc1tpXS5zcGVudF9vdXRwdXRzW2pdLmFtb3VudClcclxuXHRcdFx0XHRcdFx0LnRvU3RyaW5nKCk7XHJcblx0XHRcdFx0XHR0cmFuc2FjdGlvbnNbaV0uc3BlbnRfb3V0cHV0cy5zcGxpY2UoaiwgMSk7XHJcblx0XHRcdFx0XHRqLS07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAoXHJcblx0XHRcdG5ldyBKU0JpZ0ludCh0cmFuc2FjdGlvbnNbaV0udG90YWxfcmVjZWl2ZWQgfHwgMClcclxuXHRcdFx0XHQuYWRkKHRyYW5zYWN0aW9uc1tpXS50b3RhbF9zZW50IHx8IDApXHJcblx0XHRcdFx0LmNvbXBhcmUoMCkgPD0gMFxyXG5cdFx0KSB7XHJcblx0XHRcdHRyYW5zYWN0aW9ucy5zcGxpY2UoaSwgMSk7XHJcblx0XHRcdGktLTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblx0XHR0cmFuc2FjdGlvbnNbaV0uYW1vdW50ID0gbmV3IEpTQmlnSW50KFxyXG5cdFx0XHR0cmFuc2FjdGlvbnNbaV0udG90YWxfcmVjZWl2ZWQgfHwgMCxcclxuXHRcdClcclxuXHRcdFx0LnN1YnRyYWN0KHRyYW5zYWN0aW9uc1tpXS50b3RhbF9zZW50IHx8IDApXHJcblx0XHRcdC50b1N0cmluZygpO1xyXG5cdFx0dHJhbnNhY3Rpb25zW2ldLmFwcHJveF9mbG9hdF9hbW91bnQgPSBwYXJzZUZsb2F0KFxyXG5cdFx0XHRtb25lcm9fYW1vdW50X2Zvcm1hdF91dGlscy5mb3JtYXRNb25leSh0cmFuc2FjdGlvbnNbaV0uYW1vdW50KSxcclxuXHRcdCk7XHJcblx0XHR0cmFuc2FjdGlvbnNbaV0udGltZXN0YW1wID0gdHJhbnNhY3Rpb25zW2ldLnRpbWVzdGFtcDtcclxuXHRcdGNvbnN0IHJlY29yZF9fcGF5bWVudF9pZCA9IHRyYW5zYWN0aW9uc1tpXS5wYXltZW50X2lkO1xyXG5cdFx0aWYgKHR5cGVvZiByZWNvcmRfX3BheW1lbnRfaWQgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVjb3JkX19wYXltZW50X2lkKSB7XHJcblx0XHRcdGlmIChyZWNvcmRfX3BheW1lbnRfaWQubGVuZ3RoID09IDE2KSB7XHJcblx0XHRcdFx0Ly8gc2hvcnQgKGVuY3J5cHRlZCkgcGlkXHJcblx0XHRcdFx0aWYgKHRyYW5zYWN0aW9uc1tpXS5hcHByb3hfZmxvYXRfYW1vdW50IDwgMCkge1xyXG5cdFx0XHRcdFx0Ly8gb3V0Z29pbmdcclxuXHRcdFx0XHRcdGRlbGV0ZSB0cmFuc2FjdGlvbnNbaV1bXCJwYXltZW50X2lkXCJdOyAvLyBuZWVkIHRvIGZpbHRlciB0aGVzZSBvdXQgLi4gYmVjYXVzZSB0aGUgc2VydmVyIGNhbid0IGZpbHRlciBvdXQgc2hvcnQgKGVuY3J5cHRlZCkgcGlkcyBvbiBvdXRnb2luZyB0eHNcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0dHJhbnNhY3Rpb25zLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0aWYgKGEubWVtcG9vbCA9PSB0cnVlKSB7XHJcblx0XHRcdGlmIChiLm1lbXBvb2wgIT0gdHJ1ZSkge1xyXG5cdFx0XHRcdHJldHVybiAtMTsgLy8gYSBmaXJzdFxyXG5cdFx0XHR9XHJcblx0XHRcdC8vIGJvdGggbWVtcG9vbCAtIGZhbGwgYmFjayB0byAuaWQgY29tcGFyZVxyXG5cdFx0fSBlbHNlIGlmIChiLm1lbXBvb2wgPT0gdHJ1ZSkge1xyXG5cdFx0XHRyZXR1cm4gMTsgLy8gYiBmaXJzdFxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGIuaWQgLSBhLmlkO1xyXG5cdH0pO1xyXG5cdC8vIHByZXBhcmUgdHJhbnNhY3Rpb25zIHRvIGJlIHNlcmlhbGl6ZWRcclxuXHRmb3IgKGxldCB0cmFuc2FjdGlvbiBvZiB0cmFuc2FjdGlvbnMpIHtcclxuXHRcdHRyYW5zYWN0aW9uLmFtb3VudCA9IHRyYW5zYWN0aW9uLmFtb3VudC50b1N0cmluZygpOyAvLyBKU0JpZ0ludCAtPiBTdHJpbmdcclxuXHRcdGlmIChcclxuXHRcdFx0dHlwZW9mIHRyYW5zYWN0aW9uLnRvdGFsX3NlbnQgIT09IFwidW5kZWZpbmVkXCIgJiZcclxuXHRcdFx0dHJhbnNhY3Rpb24udG90YWxfc2VudCAhPT0gbnVsbFxyXG5cdFx0KSB7XHJcblx0XHRcdHRyYW5zYWN0aW9uLnRvdGFsX3NlbnQgPSB0cmFuc2FjdGlvbi50b3RhbF9zZW50LnRvU3RyaW5nKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdC8vIG9uIHRoZSBvdGhlciBzaWRlLCB3ZSBjb252ZXJ0IHRyYW5zYWN0aW9ucyB0aW1lc3RhbXAgdG8gRGF0ZSBvYmpcclxuXHRjb25zdCByZXR1cm5WYWx1ZXNCeUtleSA9IHtcclxuXHRcdGFjY291bnRfc2Nhbm5lZF9oZWlnaHQ6IGFjY291bnRfc2Nhbm5lZF9oZWlnaHQsXHJcblx0XHRhY2NvdW50X3NjYW5uZWRfYmxvY2tfaGVpZ2h0OiBhY2NvdW50X3NjYW5uZWRfYmxvY2tfaGVpZ2h0LFxyXG5cdFx0YWNjb3VudF9zY2FuX3N0YXJ0X2hlaWdodDogYWNjb3VudF9zY2FuX3N0YXJ0X2hlaWdodCxcclxuXHRcdHRyYW5zYWN0aW9uX2hlaWdodDogdHJhbnNhY3Rpb25faGVpZ2h0LFxyXG5cdFx0YmxvY2tjaGFpbl9oZWlnaHQ6IGJsb2NrY2hhaW5faGVpZ2h0LFxyXG5cdFx0c2VyaWFsaXplZF90cmFuc2FjdGlvbnM6IHRyYW5zYWN0aW9ucyxcclxuXHR9O1xyXG5cdHJldHVybiByZXR1cm5WYWx1ZXNCeUtleTtcclxufVxyXG5mdW5jdGlvbiBQYXJzZWRfQWRkcmVzc1RyYW5zYWN0aW9uc19fc3luY19fa2V5SW1hZ2VNYW5hZ2VkKFxyXG5cdGRhdGEsXHJcblx0YWRkcmVzcyxcclxuXHR2aWV3X2tleV9fcHJpdmF0ZSxcclxuXHRzcGVuZF9rZXlfX3B1YmxpYyxcclxuXHRzcGVuZF9rZXlfX3ByaXZhdGUsXHJcblx0bW9uZXJvX3V0aWxzLFxyXG4pIHtcclxuXHRjb25zdCBrZXlJbWFnZUNhY2hlID0gbW9uZXJvX2tleUltYWdlX2NhY2hlX3V0aWxzLkxhenlfS2V5SW1hZ2VDYWNoZUZvcldhbGxldFdpdGgoXHJcblx0XHRhZGRyZXNzLFxyXG5cdCk7XHJcblx0cmV0dXJuIFBhcnNlZF9BZGRyZXNzVHJhbnNhY3Rpb25zX19zeW5jKFxyXG5cdFx0a2V5SW1hZ2VDYWNoZSxcclxuXHRcdGRhdGEsXHJcblx0XHRhZGRyZXNzLFxyXG5cdFx0dmlld19rZXlfX3ByaXZhdGUsXHJcblx0XHRzcGVuZF9rZXlfX3B1YmxpYyxcclxuXHRcdHNwZW5kX2tleV9fcHJpdmF0ZSxcclxuXHRcdG1vbmVyb191dGlscyxcclxuXHQpO1xyXG59XHJcbmZ1bmN0aW9uIFBhcnNlZF9BZGRyZXNzVHJhbnNhY3Rpb25zX19rZXlJbWFnZU1hbmFnZWQoXHJcblx0ZGF0YSxcclxuXHRhZGRyZXNzLFxyXG5cdHZpZXdfa2V5X19wcml2YXRlLFxyXG5cdHNwZW5kX2tleV9fcHVibGljLFxyXG5cdHNwZW5kX2tleV9fcHJpdmF0ZSxcclxuXHRtb25lcm9fdXRpbHMsXHJcblx0Zm4sXHJcbikge1xyXG5cdFBhcnNlZF9BZGRyZXNzVHJhbnNhY3Rpb25zKFxyXG5cdFx0bW9uZXJvX2tleUltYWdlX2NhY2hlX3V0aWxzLkxhenlfS2V5SW1hZ2VDYWNoZUZvcldhbGxldFdpdGgoYWRkcmVzcyksXHJcblx0XHRkYXRhLFxyXG5cdFx0YWRkcmVzcyxcclxuXHRcdHZpZXdfa2V5X19wcml2YXRlLFxyXG5cdFx0c3BlbmRfa2V5X19wdWJsaWMsXHJcblx0XHRzcGVuZF9rZXlfX3ByaXZhdGUsXHJcblx0XHRtb25lcm9fdXRpbHMsXHJcblx0XHRmbixcclxuXHQpO1xyXG59XHJcbmV4cG9ydHMuUGFyc2VkX0FkZHJlc3NUcmFuc2FjdGlvbnMgPSBQYXJzZWRfQWRkcmVzc1RyYW5zYWN0aW9ucztcclxuZXhwb3J0cy5QYXJzZWRfQWRkcmVzc1RyYW5zYWN0aW9uc19fa2V5SW1hZ2VNYW5hZ2VkID0gUGFyc2VkX0FkZHJlc3NUcmFuc2FjdGlvbnNfX2tleUltYWdlTWFuYWdlZDtcclxuZXhwb3J0cy5QYXJzZWRfQWRkcmVzc1RyYW5zYWN0aW9uc19fc3luYyA9IFBhcnNlZF9BZGRyZXNzVHJhbnNhY3Rpb25zX19zeW5jO1xyXG5leHBvcnRzLlBhcnNlZF9BZGRyZXNzVHJhbnNhY3Rpb25zX19zeW5jX19rZXlJbWFnZU1hbmFnZWQgPSBQYXJzZWRfQWRkcmVzc1RyYW5zYWN0aW9uc19fc3luY19fa2V5SW1hZ2VNYW5hZ2VkO1xyXG4vL1xyXG5mdW5jdGlvbiBQYXJzZWRfVW5zcGVudE91dHMoXHJcblx0a2V5SW1hZ2VfY2FjaGUsXHJcblx0ZGF0YSxcclxuXHRhZGRyZXNzLFxyXG5cdHZpZXdfa2V5X19wcml2YXRlLFxyXG5cdHNwZW5kX2tleV9fcHVibGljLFxyXG5cdHNwZW5kX2tleV9fcHJpdmF0ZSxcclxuXHRtb25lcm9fdXRpbHMsXHJcblx0Zm4sIC8vIChlcnI/LCByZXR1cm5WYWx1ZXNCeUtleSlcclxuKSB7XHJcblx0Y29uc3QgcmV0dXJuVmFsdWVzQnlLZXkgPSBQYXJzZWRfVW5zcGVudE91dHNfX3N5bmMoXHJcblx0XHRrZXlJbWFnZV9jYWNoZSxcclxuXHRcdGRhdGEsXHJcblx0XHRhZGRyZXNzLFxyXG5cdFx0dmlld19rZXlfX3ByaXZhdGUsXHJcblx0XHRzcGVuZF9rZXlfX3B1YmxpYyxcclxuXHRcdHNwZW5kX2tleV9fcHJpdmF0ZSxcclxuXHRcdG1vbmVyb191dGlscyxcclxuXHQpO1xyXG5cdGZuKG51bGwsIHJldHVyblZhbHVlc0J5S2V5KTtcclxufVxyXG5mdW5jdGlvbiBQYXJzZWRfVW5zcGVudE91dHNfX3N5bmMoXHJcblx0a2V5SW1hZ2VfY2FjaGUsXHJcblx0ZGF0YSxcclxuXHRhZGRyZXNzLFxyXG5cdHZpZXdfa2V5X19wcml2YXRlLFxyXG5cdHNwZW5kX2tleV9fcHVibGljLFxyXG5cdHNwZW5kX2tleV9fcHJpdmF0ZSxcclxuXHRtb25lcm9fdXRpbHNcclxuKSB7XHJcblx0Y29uc3QgZGF0YV9vdXRwdXRzID0gZGF0YS5vdXRwdXRzO1xyXG5cdGNvbnN0IGZpbmFsaXplZF91bnNwZW50T3V0cHV0cyA9IGRhdGEub3V0cHV0cyB8fCBbXTsgLy8gdG8gZmluYWxpemU6XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmaW5hbGl6ZWRfdW5zcGVudE91dHB1dHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGNvbnN0IHVuc3BlbnRfb3V0cHV0ID0gZmluYWxpemVkX3Vuc3BlbnRPdXRwdXRzW2ldO1xyXG5cdFx0aWYgKFxyXG5cdFx0XHR1bnNwZW50X291dHB1dCA9PT0gbnVsbCB8fFxyXG5cdFx0XHR0eXBlb2YgdW5zcGVudF9vdXRwdXQgPT09IFwidW5kZWZpbmVkXCIgfHxcclxuXHRcdFx0IXVuc3BlbnRfb3V0cHV0IC8vIGp1c3QgcHJlc2VydmluZyB3aGF0IHdhcyBpbiB0aGUgb3JpZ2luYWwgY29kZVxyXG5cdFx0KSB7XHJcblx0XHRcdHRocm93IFwidW5zcGVudF9vdXRwdXQgYXQgaW5kZXggXCIgKyBpICsgXCIgd2FzIG51bGxcIjtcclxuXHRcdH1cclxuXHRcdGNvbnN0IHNwZW5kX2tleV9pbWFnZXMgPSB1bnNwZW50X291dHB1dC5zcGVuZF9rZXlfaW1hZ2VzO1xyXG5cdFx0aWYgKFxyXG5cdFx0XHRzcGVuZF9rZXlfaW1hZ2VzID09PSBudWxsIHx8XHJcblx0XHRcdHR5cGVvZiBzcGVuZF9rZXlfaW1hZ2VzID09PSBcInVuZGVmaW5lZFwiXHJcblx0XHQpIHtcclxuXHRcdFx0dGhyb3cgXCJzcGVuZF9rZXlfaW1hZ2VzIG9mIHVuc3BlbnRfb3V0cHV0IGF0IGluZGV4IFwiICtcclxuXHRcdFx0XHRpICtcclxuXHRcdFx0XHRcIiB3YXMgbnVsbFwiO1xyXG5cdFx0fVxyXG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzcGVuZF9rZXlfaW1hZ2VzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdGNvbnN0IGZpbmFsaXplZF91bnNwZW50T3V0cHV0X2F0SV9iZWZvcmVTcGxpY2UgPVxyXG5cdFx0XHRcdGZpbmFsaXplZF91bnNwZW50T3V0cHV0c1tpXTtcclxuXHRcdFx0aWYgKFxyXG5cdFx0XHRcdCFmaW5hbGl6ZWRfdW5zcGVudE91dHB1dF9hdElfYmVmb3JlU3BsaWNlIHx8XHJcblx0XHRcdFx0dHlwZW9mIGZpbmFsaXplZF91bnNwZW50T3V0cHV0X2F0SV9iZWZvcmVTcGxpY2UgPT09IFwidW5kZWZpbmVkXCJcclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0Ly8gY29uc29sZS53YXJuKFxyXG5cdFx0XHRcdC8vIFx0YFRoaXMgdW5zcGVudCBvdXRwdXQgYXQgaSAke2l9IHdhcyBsaXRlcmFsbHkgdW5kZWZpbmVkISBTa2lwcGluZy5gLFxyXG5cdFx0XHRcdC8vICk7IC8vIE5PVEU6IExvb2tzIGxpa2UgdGhlIGktLSBjb2RlIGJlbG93IHNob3VsZCBleGl0IGVhcmxpZXIgaWYgdGhpcyBpcyBuZWNlc3NhcnlcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjb25zdCBiZWZvcmVTcGxpY2VfX3R4X3B1Yl9rZXkgPVxyXG5cdFx0XHRcdGZpbmFsaXplZF91bnNwZW50T3V0cHV0X2F0SV9iZWZvcmVTcGxpY2UudHhfcHViX2tleTtcclxuXHRcdFx0Y29uc3QgYmVmb3JlU3BsaWNlX19pbmRleCA9XHJcblx0XHRcdFx0ZmluYWxpemVkX3Vuc3BlbnRPdXRwdXRfYXRJX2JlZm9yZVNwbGljZS5pbmRleDtcclxuXHRcdFx0aWYgKFxyXG5cdFx0XHRcdHR5cGVvZiBiZWZvcmVTcGxpY2VfX3R4X3B1Yl9rZXkgPT09IFwidW5kZWZpbmVkXCIgfHxcclxuXHRcdFx0XHQhYmVmb3JlU3BsaWNlX190eF9wdWJfa2V5XHJcblx0XHRcdCkge1xyXG5cdFx0XHRcdGNvbnNvbGUud2FybihcclxuXHRcdFx0XHRcdFwiVGhpcyB1bnNwZW50IG91dCB3YXMgbWlzc2luZyBhIHR4X3B1Yl9rZXkhIFNraXBwaW5nLlwiLFxyXG5cdFx0XHRcdFx0ZmluYWxpemVkX3Vuc3BlbnRPdXRwdXRfYXRJX2JlZm9yZVNwbGljZSxcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBrZXlfaW1hZ2UgPSBtb25lcm9fa2V5SW1hZ2VfY2FjaGVfdXRpbHMuTGF6eV9LZXlJbWFnZShcclxuXHRcdFx0XHRrZXlJbWFnZV9jYWNoZSxcclxuXHRcdFx0XHRiZWZvcmVTcGxpY2VfX3R4X3B1Yl9rZXksXHJcblx0XHRcdFx0YmVmb3JlU3BsaWNlX19pbmRleCxcclxuXHRcdFx0XHRhZGRyZXNzLFxyXG5cdFx0XHRcdHZpZXdfa2V5X19wcml2YXRlLFxyXG5cdFx0XHRcdHNwZW5kX2tleV9fcHVibGljLFxyXG5cdFx0XHRcdHNwZW5kX2tleV9fcHJpdmF0ZSxcclxuXHRcdFx0XHRtb25lcm9fdXRpbHNcclxuXHRcdFx0KTtcclxuXHRcdFx0aWYgKFxyXG5cdFx0XHRcdGtleV9pbWFnZSA9PT1cclxuXHRcdFx0XHRmaW5hbGl6ZWRfdW5zcGVudE91dHB1dF9hdElfYmVmb3JlU3BsaWNlLnNwZW5kX2tleV9pbWFnZXNbal1cclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCLwn5KsICBPdXRwdXQgd2FzIHNwZW50OyBrZXkgaW1hZ2U6IFwiICsga2V5X2ltYWdlICsgXCIgYW1vdW50OiBcIiArIG1vbmVyb19hbW91bnRfZm9ybWF0X3V0aWxzLmZvcm1hdE1vbmV5RnVsbChmaW5hbGl6ZWRfdW5zcGVudE91dHB1dHNbaV0uYW1vdW50KSk7XHJcblx0XHRcdFx0Ly8gUmVtb3ZlIG91dHB1dCBmcm9tIGxpc3RcclxuXHRcdFx0XHRmaW5hbGl6ZWRfdW5zcGVudE91dHB1dHMuc3BsaWNlKGksIDEpO1xyXG5cdFx0XHRcdGNvbnN0IGZpbmFsaXplZF91bnNwZW50T3V0cHV0X2F0SV9hZnRlclNwbGljZSA9XHJcblx0XHRcdFx0XHRmaW5hbGl6ZWRfdW5zcGVudE91dHB1dHNbaV07XHJcblx0XHRcdFx0aWYgKGZpbmFsaXplZF91bnNwZW50T3V0cHV0X2F0SV9hZnRlclNwbGljZSkge1xyXG5cdFx0XHRcdFx0aiA9XHJcblx0XHRcdFx0XHRcdGZpbmFsaXplZF91bnNwZW50T3V0cHV0X2F0SV9hZnRlclNwbGljZS5zcGVuZF9rZXlfaW1hZ2VzXHJcblx0XHRcdFx0XHRcdFx0Lmxlbmd0aDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aS0tO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFxyXG5cdFx0XHRcdC8vIFx0XCLwn5KsICBPdXRwdXQgdXNlZCBhcyBtaXhpbiAoXCIgK1xyXG5cdFx0XHRcdC8vIFx0XHRrZXlfaW1hZ2UgK1xyXG5cdFx0XHRcdC8vIFx0XHRcIi9cIiArXHJcblx0XHRcdFx0Ly8gXHRcdGZpbmFsaXplZF91bnNwZW50T3V0cHV0c1tpXS5zcGVuZF9rZXlfaW1hZ2VzW2pdICtcclxuXHRcdFx0XHQvLyBcdFx0XCIpXCIsXHJcblx0XHRcdFx0Ly8gKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHQvLyBjb25zb2xlLmxvZyhcIlVuc3BlbnQgb3V0czogXCIgKyBKU09OLnN0cmluZ2lmeShmaW5hbGl6ZWRfdW5zcGVudE91dHB1dHMpKTtcclxuXHR2YXIgZmluYWxfX3Blcl9ieXRlX2ZlZV9fc3RyaW5nO1xyXG5cdGlmICh0eXBlb2YgZGF0YS5wZXJfYnl0ZV9mZWUgIT09ICd1bmRlZmluZWQnICYmIGRhdGEucGVyX2J5dGVfZmVlKSB7XHJcblx0XHRmaW5hbF9fcGVyX2J5dGVfZmVlX19zdHJpbmcgPSBkYXRhLnBlcl9ieXRlX2ZlZSAvLyAoaXMgYWxyZWFkeSBzdHJpbmcpXHJcblx0fSBlbHNlIHsgLy8gcGVyX2J5dGVfZmVlIG5vdCB5ZXQgZGVwbG95ZWQgLSBmYWxsIGJhY2sgdG8gcGVyX2tiX2ZlZVxyXG5cdFx0aWYgKHR5cGVvZiBkYXRhLnBlcl9rYl9mZWUgPT0gJ3VuZGVmaW5lZCcgfHwgIWRhdGEucGVyX2tiX2ZlZSkge1xyXG5cdFx0XHR0aHJvdyBcIkV4cGVjdGVkIGRhdGEucGVyX2tiX2ZlZSBvciBkYXRhLnBlcl9ieXRlX2ZlZVwiXHJcblx0XHR9XHJcblx0XHRmaW5hbF9fcGVyX2J5dGVfZmVlX19zdHJpbmcgPSAobmV3IEpTQmlnSW50KGRhdGEucGVyX2tiX2ZlZSkpLmRpdmlkZSgxMDI0KS50b1N0cmluZygpIC8vIHNjYWxlIGZyb20ga2liIHRvIGIgYW5kIGNvbnZlcnQgYmFjayB0byBzdHJpbmdcclxuXHR9XHJcblx0aWYgKHR5cGVvZiBmaW5hbF9fcGVyX2J5dGVfZmVlX19zdHJpbmcgPT0gJ3VuZGVmaW5lZCcgfHwgIWZpbmFsX19wZXJfYnl0ZV9mZWVfX3N0cmluZykge1xyXG5cdFx0dGhyb3cgXCJVbmFibGUgdG8gZGVyaXZlIHBlcl9ieXRlX2ZlZSBzdHJpbmdcIlxyXG5cdH1cclxuXHRjb25zdCByZXR1cm5WYWx1ZXNCeUtleSA9IHtcclxuXHRcdHVuc3BlbnRPdXRwdXRzOiBmaW5hbGl6ZWRfdW5zcGVudE91dHB1dHMsXHJcblx0XHRwZXJfYnl0ZV9mZWVfX3N0cmluZzogZmluYWxfX3Blcl9ieXRlX2ZlZV9fc3RyaW5nLCAvLyBTdHJpbmdcclxuXHR9O1xyXG5cdHJldHVybiByZXR1cm5WYWx1ZXNCeUtleTtcclxufVxyXG5mdW5jdGlvbiBQYXJzZWRfVW5zcGVudE91dHNfX3N5bmNfX2tleUltYWdlTWFuYWdlZChcclxuXHRkYXRhLFxyXG5cdGFkZHJlc3MsXHJcblx0dmlld19rZXlfX3ByaXZhdGUsXHJcblx0c3BlbmRfa2V5X19wdWJsaWMsXHJcblx0c3BlbmRfa2V5X19wcml2YXRlLFxyXG5cdG1vbmVyb191dGlscyxcclxuKSB7XHJcblx0Y29uc3Qga2V5SW1hZ2VDYWNoZSA9IG1vbmVyb19rZXlJbWFnZV9jYWNoZV91dGlscy5MYXp5X0tleUltYWdlQ2FjaGVGb3JXYWxsZXRXaXRoKFxyXG5cdFx0YWRkcmVzcyxcclxuXHQpO1xyXG5cdHJldHVybiBQYXJzZWRfVW5zcGVudE91dHNfX3N5bmMoXHJcblx0XHRrZXlJbWFnZUNhY2hlLFxyXG5cdFx0ZGF0YSxcclxuXHRcdGFkZHJlc3MsXHJcblx0XHR2aWV3X2tleV9fcHJpdmF0ZSxcclxuXHRcdHNwZW5kX2tleV9fcHVibGljLFxyXG5cdFx0c3BlbmRfa2V5X19wcml2YXRlLFxyXG5cdFx0bW9uZXJvX3V0aWxzLFxyXG5cdCk7XHJcbn1cclxuZnVuY3Rpb24gUGFyc2VkX1Vuc3BlbnRPdXRzX19rZXlJbWFnZU1hbmFnZWQoXHJcblx0ZGF0YSxcclxuXHRhZGRyZXNzLFxyXG5cdHZpZXdfa2V5X19wcml2YXRlLFxyXG5cdHNwZW5kX2tleV9fcHVibGljLFxyXG5cdHNwZW5kX2tleV9fcHJpdmF0ZSxcclxuXHRtb25lcm9fdXRpbHMsXHJcblx0Zm4sXHJcbikge1xyXG5cdFBhcnNlZF9VbnNwZW50T3V0cyhcclxuXHRcdG1vbmVyb19rZXlJbWFnZV9jYWNoZV91dGlscy5MYXp5X0tleUltYWdlQ2FjaGVGb3JXYWxsZXRXaXRoKGFkZHJlc3MpLFxyXG5cdFx0ZGF0YSxcclxuXHRcdGFkZHJlc3MsXHJcblx0XHR2aWV3X2tleV9fcHJpdmF0ZSxcclxuXHRcdHNwZW5kX2tleV9fcHVibGljLFxyXG5cdFx0c3BlbmRfa2V5X19wcml2YXRlLFxyXG5cdFx0bW9uZXJvX3V0aWxzLFxyXG5cdFx0Zm4sXHJcblx0KTtcclxufVxyXG5leHBvcnRzLlBhcnNlZF9VbnNwZW50T3V0cyA9IFBhcnNlZF9VbnNwZW50T3V0cztcclxuZXhwb3J0cy5QYXJzZWRfVW5zcGVudE91dHNfX2tleUltYWdlTWFuYWdlZCA9IFBhcnNlZF9VbnNwZW50T3V0c19fa2V5SW1hZ2VNYW5hZ2VkO1xyXG5leHBvcnRzLlBhcnNlZF9VbnNwZW50T3V0c19fc3luYyA9IFBhcnNlZF9VbnNwZW50T3V0c19fc3luYztcclxuZXhwb3J0cy5QYXJzZWRfVW5zcGVudE91dHNfX3N5bmNfX2tleUltYWdlTWFuYWdlZCA9IFBhcnNlZF9VbnNwZW50T3V0c19fc3luY19fa2V5SW1hZ2VNYW5hZ2VkO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./libs/mymonero-app-js/local_modules/mymonero_core_js/hostAPI/response_parser_utils.js\n");

/***/ }),

/***/ "./libs/mymonero-app-js/local_modules/mymonero_core_js/index.js":
/*!**********************************************************************!*\
  !*** ./libs/mymonero-app-js/local_modules/mymonero_core_js/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2014-2018, MyMonero.com\r\n//\r\n// All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without modification, are\r\n// permitted provided that the following conditions are met:\r\n//\r\n// 1. Redistributions of source code must retain the above copyright notice, this list of\r\n//\tconditions and the following disclaimer.\r\n//\r\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list\r\n//\tof conditions and the following disclaimer in the documentation and/or other\r\n//\tmaterials provided with the distribution.\r\n//\r\n// 3. Neither the name of the copyright holder nor the names of its contributors may be\r\n//\tused to endorse or promote products derived from this software without specific\r\n//\tprior written permission.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\r\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\r\n// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\r\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n//\r\n\r\n//\r\n// NOTE: The main downside to using an index.js file like this is that it will pull in all the code - rather than the consumer requiring code module-by-module\r\n// It's of course possible to construct your own stripped-down index.[custom name].js file for, e.g., special webpack bundling usages.\r\nconst mymonero_core_js = {};\r\nmymonero_core_js.monero_utils_promise = __webpack_require__(/*! ./monero_utils/monero_utils */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_utils.js\")(); // NOTE: This is actually a promise. Call .then(function(monero_utils) { }) to actually use\r\nmymonero_core_js.monero_config = __webpack_require__(/*! ./monero_utils/monero_config */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_config.js\");\r\nmymonero_core_js.monero_txParsing_utils = __webpack_require__(/*! ./monero_utils/monero_txParsing_utils */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_txParsing_utils.js\");\r\nmymonero_core_js.monero_sendingFunds_utils = __webpack_require__(/*! ./monero_utils/monero_sendingFunds_utils */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_sendingFunds_utils.js\");\r\nmymonero_core_js.monero_requestURI_utils = __webpack_require__(/*! ./monero_utils/monero_requestURI_utils */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_requestURI_utils.js\");\r\nmymonero_core_js.monero_keyImage_cache_utils = __webpack_require__(/*! ./monero_utils/monero_keyImage_cache_utils */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_keyImage_cache_utils.js\");\r\nmymonero_core_js.monero_paymentID_utils = __webpack_require__(/*! ./monero_utils/monero_paymentID_utils */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_paymentID_utils.js\");\r\nmymonero_core_js.monero_amount_format_utils = __webpack_require__(/*! ./monero_utils/monero_amount_format_utils */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_amount_format_utils.js\");\r\nmymonero_core_js.api_response_parser_utils = __webpack_require__(/*! ./hostAPI/response_parser_utils */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/hostAPI/response_parser_utils.js\");\r\n//\r\nmymonero_core_js.nettype_utils = __webpack_require__(/*! ./cryptonote_utils/nettype */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/nettype.js\");\r\nmymonero_core_js.JSBigInt = __webpack_require__(/*! ./cryptonote_utils/biginteger */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/biginteger.js\").BigInteger; // so that it is available to a hypothetical consumer's language-bridging web context for constructing string arguments to the above modules\r\n//\r\nmodule.exports = mymonero_core_js;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvaW5kZXguanM/ZWYyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxOCwgTXlNb25lcm8uY29tXHJcbi8vXHJcbi8vIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vXHJcbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZVxyXG4vLyBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuLy9cclxuLy8gMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2ZcclxuLy9cdGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuLy9cclxuLy8gMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3RcclxuLy9cdG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXJcclxuLy9cdG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbi8vXHJcbi8vIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGNvcHlyaWdodCBob2xkZXIgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZVxyXG4vL1x0dXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xyXG4vL1x0cHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4vL1xyXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkQgQU5ZXHJcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRlxyXG4vLyBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTFxyXG4vLyBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcclxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxyXG4vLyBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcclxuLy8gSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsXHJcbi8vIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxyXG4vLyBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbi8vXHJcblwidXNlIHN0cmljdFwiO1xyXG4vL1xyXG4vLyBOT1RFOiBUaGUgbWFpbiBkb3duc2lkZSB0byB1c2luZyBhbiBpbmRleC5qcyBmaWxlIGxpa2UgdGhpcyBpcyB0aGF0IGl0IHdpbGwgcHVsbCBpbiBhbGwgdGhlIGNvZGUgLSByYXRoZXIgdGhhbiB0aGUgY29uc3VtZXIgcmVxdWlyaW5nIGNvZGUgbW9kdWxlLWJ5LW1vZHVsZVxyXG4vLyBJdCdzIG9mIGNvdXJzZSBwb3NzaWJsZSB0byBjb25zdHJ1Y3QgeW91ciBvd24gc3RyaXBwZWQtZG93biBpbmRleC5bY3VzdG9tIG5hbWVdLmpzIGZpbGUgZm9yLCBlLmcuLCBzcGVjaWFsIHdlYnBhY2sgYnVuZGxpbmcgdXNhZ2VzLlxyXG5jb25zdCBteW1vbmVyb19jb3JlX2pzID0ge307XHJcbm15bW9uZXJvX2NvcmVfanMubW9uZXJvX3V0aWxzX3Byb21pc2UgPSByZXF1aXJlKFwiLi9tb25lcm9fdXRpbHMvbW9uZXJvX3V0aWxzXCIpKCk7IC8vIE5PVEU6IFRoaXMgaXMgYWN0dWFsbHkgYSBwcm9taXNlLiBDYWxsIC50aGVuKGZ1bmN0aW9uKG1vbmVyb191dGlscykgeyB9KSB0byBhY3R1YWxseSB1c2VcclxubXltb25lcm9fY29yZV9qcy5tb25lcm9fY29uZmlnID0gcmVxdWlyZShcIi4vbW9uZXJvX3V0aWxzL21vbmVyb19jb25maWdcIik7XHJcbm15bW9uZXJvX2NvcmVfanMubW9uZXJvX3R4UGFyc2luZ191dGlscyA9IHJlcXVpcmUoXCIuL21vbmVyb191dGlscy9tb25lcm9fdHhQYXJzaW5nX3V0aWxzXCIpO1xyXG5teW1vbmVyb19jb3JlX2pzLm1vbmVyb19zZW5kaW5nRnVuZHNfdXRpbHMgPSByZXF1aXJlKFwiLi9tb25lcm9fdXRpbHMvbW9uZXJvX3NlbmRpbmdGdW5kc191dGlsc1wiKTtcclxubXltb25lcm9fY29yZV9qcy5tb25lcm9fcmVxdWVzdFVSSV91dGlscyA9IHJlcXVpcmUoXCIuL21vbmVyb191dGlscy9tb25lcm9fcmVxdWVzdFVSSV91dGlsc1wiKTtcclxubXltb25lcm9fY29yZV9qcy5tb25lcm9fa2V5SW1hZ2VfY2FjaGVfdXRpbHMgPSByZXF1aXJlKFwiLi9tb25lcm9fdXRpbHMvbW9uZXJvX2tleUltYWdlX2NhY2hlX3V0aWxzXCIpO1xyXG5teW1vbmVyb19jb3JlX2pzLm1vbmVyb19wYXltZW50SURfdXRpbHMgPSByZXF1aXJlKFwiLi9tb25lcm9fdXRpbHMvbW9uZXJvX3BheW1lbnRJRF91dGlsc1wiKTtcclxubXltb25lcm9fY29yZV9qcy5tb25lcm9fYW1vdW50X2Zvcm1hdF91dGlscyA9IHJlcXVpcmUoXCIuL21vbmVyb191dGlscy9tb25lcm9fYW1vdW50X2Zvcm1hdF91dGlsc1wiKTtcclxubXltb25lcm9fY29yZV9qcy5hcGlfcmVzcG9uc2VfcGFyc2VyX3V0aWxzID0gcmVxdWlyZShcIi4vaG9zdEFQSS9yZXNwb25zZV9wYXJzZXJfdXRpbHNcIik7XHJcbi8vXHJcbm15bW9uZXJvX2NvcmVfanMubmV0dHlwZV91dGlscyA9IHJlcXVpcmUoXCIuL2NyeXB0b25vdGVfdXRpbHMvbmV0dHlwZVwiKTtcclxubXltb25lcm9fY29yZV9qcy5KU0JpZ0ludCA9IHJlcXVpcmUoXCIuL2NyeXB0b25vdGVfdXRpbHMvYmlnaW50ZWdlclwiKS5CaWdJbnRlZ2VyOyAvLyBzbyB0aGF0IGl0IGlzIGF2YWlsYWJsZSB0byBhIGh5cG90aGV0aWNhbCBjb25zdW1lcidzIGxhbmd1YWdlLWJyaWRnaW5nIHdlYiBjb250ZXh0IGZvciBjb25zdHJ1Y3Rpbmcgc3RyaW5nIGFyZ3VtZW50cyB0byB0aGUgYWJvdmUgbW9kdWxlc1xyXG4vL1xyXG5tb2R1bGUuZXhwb3J0cyA9IG15bW9uZXJvX2NvcmVfanM7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./libs/mymonero-app-js/local_modules/mymonero_core_js/index.js\n");

/***/ }),

/***/ "./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/MyMoneroCoreBridge.js":
/*!************************************************************************************************!*\
  !*** ./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/MyMoneroCoreBridge.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process, __dirname) {// Copyright (c) 2014-2018, MyMonero.com\r\n//\r\n// All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without modification, are\r\n// permitted provided that the following conditions are met:\r\n//\r\n// 1. Redistributions of source code must retain the above copyright notice, this list of\r\n//\tconditions and the following disclaimer.\r\n//\r\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list\r\n//\tof conditions and the following disclaimer in the documentation and/or other\r\n//\tmaterials provided with the distribution.\r\n//\r\n// 3. Neither the name of the copyright holder nor the names of its contributors may be\r\n//\tused to endorse or promote products derived from this software without specific\r\n//\tprior written permission.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\r\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\r\n// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\r\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\n// Original Author: Lucas Jones\r\n// Modified to remove jQuery dep and support modular inclusion of deps by Paul Shapiro (2016)\r\n// Modified to add RingCT support by luigi1111 (2017)\r\n//\r\n// v--- These should maybe be injected into a context and supplied to currencyConfig for future platforms\r\nconst JSBigInt = __webpack_require__(/*! ../cryptonote_utils/biginteger */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/biginteger.js\").BigInteger;\r\nconst nettype_utils = __webpack_require__(/*! ../cryptonote_utils/nettype */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/nettype.js\");\r\nconst monero_config = __webpack_require__(/*! ./monero_config */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_config.js\");\r\nconst monero_amount_format_utils = __webpack_require__(/*! ../cryptonote_utils/money_format_utils */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/money_format_utils.js\")(monero_config);\r\n//\r\nfunction ret_val_boolstring_to_bool(boolstring)\r\n{\r\n\tif (typeof boolstring !== \"string\") {\r\n\t\tthrow \"ret_val_boolstring_to_bool expected string input\"\r\n\t}\r\n\tif (boolstring === \"true\") {\r\n\t\treturn true\r\n\t} else if (boolstring === \"false\") {\r\n\t\treturn false\r\n\t}\r\n\tthrow \"ret_val_boolstring_to_bool given illegal input\"\r\n}\r\nfunction api_safe_wordset_name(wordset_name)\r\n{\r\n\t// convert all lowercase, legacy values to core-cpp compatible\r\n\tif (wordset_name == \"english\") {\r\n\t\treturn \"English\"\r\n\t} else if (wordset_name == \"spanish\") {\r\n\t\treturn \"Espaol\"\r\n\t} else if (wordset_name == \"portuguese\") {\r\n\t\treturn \"Portugus\"\r\n\t} else if (wordset_name == \"japanese\") {\r\n\t\treturn \"\"\r\n\t}\r\n\treturn wordset_name // must be a value returned by core-cpp\r\n}\r\nfunction bridge_sanitized__spendable_out(raw__out)\r\n{\r\n\tconst sanitary__output = \r\n\t{\r\n\t\tamount: raw__out.amount.toString(),\r\n\t\tpublic_key: raw__out.public_key,\r\n\t\tglobal_index: \"\" + raw__out.global_index,\r\n\t\tindex: \"\" + raw__out.index,\r\n\t\ttx_pub_key: raw__out.tx_pub_key\r\n\t};\r\n\tif (raw__out.rct && typeof raw__out.rct !== 'undefined') {\r\n\t\tsanitary__output.rct = raw__out.rct;\r\n\t}\r\n\treturn sanitary__output;\r\n}\r\n//\r\nclass MyMoneroCoreBridge\r\n{\r\n\tconstructor(this_Module)\r\n\t{\r\n\t\tthis.Module = this_Module;\r\n\t}\r\n\t//\r\n\t//\r\n\tis_subaddress(addr, nettype) {\r\n\t\tconst args =\r\n\t\t{\r\n\t\t\taddress: addr,\r\n\t\t\tnettype_string: nettype_utils.nettype_to_API_string(nettype)\r\n\t\t};\r\n\t\tconst args_str = JSON.stringify(args);\r\n\t\tconst ret_string = this.Module.is_subaddress(args_str);\r\n\t\tconst ret = JSON.parse(ret_string);\r\n\t\tif (typeof ret.err_msg !== 'undefined' && ret.err_msg) {\r\n\t\t\treturn { err_msg: ret.err_msg }\r\n\t\t}\r\n\t\treturn ret_val_boolstring_to_bool(ret.retVal);\r\n\t}\r\n\r\n\tis_integrated_address(addr, nettype) {\r\n\t\tconst args =\r\n\t\t{\r\n\t\t\taddress: addr,\r\n\t\t\tnettype_string: nettype_utils.nettype_to_API_string(nettype)\r\n\t\t};\r\n\t\tconst args_str = JSON.stringify(args);\r\n\t\tconst ret_string = this.Module.is_integrated_address(args_str);\r\n\t\tconst ret = JSON.parse(ret_string);\r\n\t\tif (typeof ret.err_msg !== 'undefined' && ret.err_msg) {\r\n\t\t\treturn { err_msg: ret.err_msg }\r\n\t\t}\r\n\t\treturn ret_val_boolstring_to_bool(ret.retVal);\r\n\t}\r\n\r\n\tnew_payment_id() {\r\n\t\tconst args = {};\r\n\t\tconst args_str = JSON.stringify(args);\r\n\t\tconst ret_string = this.Module.new_payment_id(args_str);\r\n\t\tconst ret = JSON.parse(ret_string);\r\n\t\tif (typeof ret.err_msg !== 'undefined' && ret.err_msg) {\r\n\t\t\treturn { err_msg: ret.err_msg }\r\n\t\t}\r\n\t\treturn ret.retVal;\r\n\t}\r\n\r\n\tnew__int_addr_from_addr_and_short_pid(\r\n\t\taddress,\r\n\t\tshort_pid,\r\n\t\tnettype\r\n\t) {\r\n\t\tif (!short_pid || short_pid.length != 16) {\r\n\t\t\treturn { err_msg: \"expected valid short_pid\" };\r\n\t\t}\r\n\t\tconst args =\r\n\t\t{\r\n\t\t\taddress: address,\r\n\t\t\tshort_pid: short_pid,\r\n\t\t\tnettype_string: nettype_utils.nettype_to_API_string(nettype)\r\n\t\t};\r\n\t\tconst args_str = JSON.stringify(args);\r\n\t\tconst ret_string = this.Module.new_integrated_address(args_str);\r\n\t\tconst ret = JSON.parse(ret_string);\r\n\t\tif (typeof ret.err_msg !== 'undefined' && ret.err_msg) {\r\n\t\t\treturn { err_msg: ret.err_msg }\r\n\t\t}\r\n\t\treturn ret.retVal;\r\n\t}\r\n\r\n\tdecode_address(address, nettype)\r\n\t{\r\n\t\tconst args =\r\n\t\t{\r\n\t\t\taddress: address,\r\n\t\t\tnettype_string: nettype_utils.nettype_to_API_string(nettype)\r\n\t\t};\r\n\t\tconst args_str = JSON.stringify(args);\r\n\t\tconst ret_string = this.Module.decode_address(args_str);\r\n\t\tconst ret = JSON.parse(ret_string);\r\n\t\tif (typeof ret.err_msg !== 'undefined' && ret.err_msg) {\r\n\t\t\treturn { err_msg: ret.err_msg }\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tspend: ret.pub_spendKey_string,\r\n\t\t\tview: ret.pub_viewKey_string,\r\n\t\t\tintPaymentId: ret.paymentID_string, // may be undefined\r\n\t\t\tisSubaddress: ret_val_boolstring_to_bool(ret.isSubaddress)\r\n\t\t}\r\n\t}\r\n\r\n\tnewly_created_wallet(\r\n\t\tlocale_language_code,\r\n\t\tnettype\r\n\t) {\r\n\t\tconst args =\r\n\t\t{\r\n\t\t\tlocale_language_code: locale_language_code, // NOTE: this function takes the locale, not the wordset name\r\n\t\t\tnettype_string: nettype_utils.nettype_to_API_string(nettype)\r\n\t\t};\r\n\t\tconst args_str = JSON.stringify(args);\r\n\t\tconst ret_string = this.Module.newly_created_wallet(args_str);\r\n\t\tconst ret = JSON.parse(ret_string);\r\n\t\tif (typeof ret.err_msg !== 'undefined' && ret.err_msg) {\r\n\t\t\treturn { err_msg: ret.err_msg }\r\n\t\t}\r\n\t\treturn { // calling these out so as to provide a stable ret val interface\r\n\t\t\tmnemonic_string: ret.mnemonic_string,\r\n\t\t\tmnemonic_language: ret.mnemonic_language,\r\n\t\t\tsec_seed_string: ret.sec_seed_string,\r\n\t\t\taddress_string: ret.address_string,\r\n\t\t\tpub_viewKey_string: ret.pub_viewKey_string,\r\n\t\t\tsec_viewKey_string: ret.sec_viewKey_string,\r\n\t\t\tpub_spendKey_string: ret.pub_spendKey_string,\r\n\t\t\tsec_spendKey_string: ret.sec_spendKey_string\r\n\t\t};\r\n\t}\r\n\r\n\tare_equal_mnemonics(a, b) {\r\n\t\tconst args =\r\n\t\t{\r\n\t\t\ta: a,\r\n\t\t\tb: b\r\n\t\t};\r\n\t\tconst args_str = JSON.stringify(args);\r\n\t\tconst ret_string = this.Module.are_equal_mnemonics(args_str);\r\n\t\tconst ret = JSON.parse(ret_string);\r\n\t\tif (typeof ret.err_msg !== 'undefined' && ret.err_msg) {\r\n\t\t\treturn { err_msg: ret.err_msg }\r\n\t\t}\r\n\t\treturn ret_val_boolstring_to_bool(ret.retVal);\r\n\t}\r\n\r\n\tmnemonic_from_seed(\r\n\t\tseed_string,\r\n\t\twordset_name\r\n\t) {\r\n\t\tconst args =\r\n\t\t{\r\n\t\t\tseed_string: seed_string,\r\n\t\t\twordset_name: api_safe_wordset_name(wordset_name)\r\n\t\t};\r\n\t\tconst args_str = JSON.stringify(args);\r\n\t\tconst ret_string = this.Module.mnemonic_from_seed(args_str);\r\n\t\tconst ret = JSON.parse(ret_string);\r\n\t\tif (typeof ret.err_msg !== 'undefined' && ret.err_msg) {\r\n\t\t\treturn { err_msg: ret.err_msg } // TODO: maybe return this somehow\r\n\t\t}\r\n\t\treturn ret.retVal;\r\n\t}\r\n\r\n\tseed_and_keys_from_mnemonic(\r\n\t\tmnemonic_string,\r\n\t\tnettype\r\n\t) {\r\n\t\tconst args =\r\n\t\t{\r\n\t\t\tmnemonic_string: mnemonic_string,\r\n\t\t\tnettype_string: nettype_utils.nettype_to_API_string(nettype)\r\n\t\t};\r\n\t\tconst args_str = JSON.stringify(args);\r\n\t\tconst ret_string = this.Module.seed_and_keys_from_mnemonic(args_str);\r\n\t\tconst ret = JSON.parse(ret_string);\r\n\t\tif (typeof ret.err_msg !== 'undefined' && ret.err_msg) {\r\n\t\t\treturn { err_msg: ret.err_msg }\r\n\t\t}\r\n\t\treturn { // calling these out so as to provide a stable ret val interface\r\n\t\t\tsec_seed_string: ret.sec_seed_string,\r\n\t\t\tmnemonic_language: ret.mnemonic_language,\r\n\t\t\taddress_string: ret.address_string,\r\n\t\t\tpub_viewKey_string: ret.pub_viewKey_string,\r\n\t\t\tsec_viewKey_string: ret.sec_viewKey_string,\r\n\t\t\tpub_spendKey_string: ret.pub_spendKey_string,\r\n\t\t\tsec_spendKey_string: ret.sec_spendKey_string\r\n\t\t};\r\n\t}\r\n\r\n\tvalidate_components_for_login(\r\n\t\taddress_string,\r\n\t\tsec_viewKey_string,\r\n\t\tsec_spendKey_string,\r\n\t\tseed_string,\r\n\t\tnettype\r\n\t) {\r\n\t\tconst args =\r\n\t\t{\r\n\t\t\taddress_string: address_string,\r\n\t\t\tsec_viewKey_string: sec_viewKey_string,\r\n\t\t\tsec_spendKey_string: sec_spendKey_string,\r\n\t\t\tseed_string: seed_string,\r\n\t\t\tnettype_string: nettype_utils.nettype_to_API_string(nettype)\r\n\t\t};\r\n\t\tconst args_str = JSON.stringify(args);\r\n\t\tconst ret_string = this.Module.validate_components_for_login(args_str);\r\n\t\tconst ret = JSON.parse(ret_string);\r\n\t\tif (typeof ret.err_msg !== 'undefined' && ret.err_msg) {\r\n\t\t\treturn { err_msg: ret.err_msg }\r\n\t\t}\r\n\t\treturn { // calling these out so as to provide a stable ret val interface\r\n\t\t\tisValid: ret_val_boolstring_to_bool(ret.isValid),\r\n\t\t\tisInViewOnlyMode: ret_val_boolstring_to_bool(ret.isInViewOnlyMode),\r\n\t\t\tpub_viewKey_string: ret.pub_viewKey_string,\r\n\t\t\tpub_spendKey_string: ret.pub_spendKey_string\r\n\t\t};\r\n\t}\r\n\r\n\taddress_and_keys_from_seed(\r\n\t\tseed_string,\r\n\t\tnettype\r\n\t) {\r\n\t\tconst args =\r\n\t\t{\r\n\t\t\tseed_string: seed_string,\r\n\t\t\tnettype_string: nettype_utils.nettype_to_API_string(nettype)\r\n\t\t};\r\n\t\tconst args_str = JSON.stringify(args);\r\n\t\tconst ret_string = this.Module.address_and_keys_from_seed(args_str);\r\n\t\tconst ret = JSON.parse(ret_string);\r\n\t\tif (typeof ret.err_msg !== 'undefined' && ret.err_msg) {\r\n\t\t\treturn { err_msg: ret.err_msg }\r\n\t\t}\r\n\t\treturn { // calling these out so as to provide a stable ret val interface\r\n\t\t\taddress_string: ret.address_string,\r\n\t\t\tpub_viewKey_string: ret.pub_viewKey_string,\r\n\t\t\tsec_viewKey_string: ret.sec_viewKey_string,\r\n\t\t\tpub_spendKey_string: ret.pub_spendKey_string,\r\n\t\t\tsec_spendKey_string: ret.sec_spendKey_string\r\n\t\t};\r\n\t}\r\n\r\n\tgenerate_key_image(\r\n\t\ttx_pub,\r\n\t\tview_sec,\r\n\t\tspend_pub,\r\n\t\tspend_sec,\r\n\t\toutput_index\r\n\t) {\r\n\t\tif (tx_pub.length !== 64) {\r\n\t\t\treturn { err_msg: \"Invalid tx_pub length\" };\r\n\t\t}\r\n\t\tif (view_sec.length !== 64) {\r\n\t\t\treturn { err_msg: \"Invalid view_sec length\" };\r\n\t\t}\r\n\t\tif (spend_pub.length !== 64) {\r\n\t\t\treturn { err_msg: \"Invalid spend_pub length\" };\r\n\t\t}\r\n\t\tif (spend_sec.length !== 64) {\r\n\t\t\treturn { err_msg: \"Invalid spend_sec length\" };\r\n\t\t}\r\n\t\tconst args =\r\n\t\t{\r\n\t\t\tsec_viewKey_string: view_sec,\r\n\t\t\tsec_spendKey_string: spend_sec,\r\n\t\t\tpub_spendKey_string: spend_pub,\r\n\t\t\ttx_pub_key: tx_pub,\r\n\t\t\tout_index: \"\" + output_index\r\n\t\t};\r\n\t\tconst args_str = JSON.stringify(args);\r\n\t\tconst ret_string = this.Module.generate_key_image(args_str);\r\n\t\tconst ret = JSON.parse(ret_string);\r\n\t\tif (typeof ret.err_msg !== 'undefined' && ret.err_msg) {\r\n\t\t\treturn { err_msg: ret.err_msg };\r\n\t\t}\r\n\t\treturn ret.retVal;\r\n\t}\r\n\r\n\tgenerate_key_derivation(\r\n\t\tpub,\r\n\t\tsec,\r\n\t) {\r\n\t\tconst args =\r\n\t\t{\r\n\t\t\tpub: pub,\r\n\t\t\tsec: sec,\r\n\t\t};\r\n\t\tconst args_str = JSON.stringify(args);\r\n\t\tconst ret_string = this.Module.generate_key_derivation(args_str);\r\n\t\tconst ret = JSON.parse(ret_string);\r\n\t\tif (typeof ret.err_msg !== 'undefined' && ret.err_msg) {\r\n\t\t\treturn { err_msg: ret.err_msg };\r\n\t\t}\r\n\t\treturn ret.retVal;\r\n\t}\r\n\tderive_public_key(derivation, out_index, pub)\r\n\t{\r\n\t\tconst args =\r\n\t\t{\r\n\t\t\tpub: pub,\r\n\t\t\tderivation: derivation, \r\n\t\t\tout_index: out_index,\r\n\t\t};\r\n\t\tconst args_str = JSON.stringify(args);\r\n\t\tconst ret_string = this.Module.derive_public_key(args_str);\r\n\t\tconst ret = JSON.parse(ret_string);\r\n\t\tif (typeof ret.err_msg !== 'undefined' && ret.err_msg) {\r\n\t\t\treturn { err_msg: ret.err_msg };\r\n\t\t}\r\n\t\treturn ret.retVal;\r\n\t}\r\n\tderive_subaddress_public_key(\r\n\t\toutput_key,\r\n\t\tderivation,\r\n\t\tout_index\r\n\t) {\r\n\t\tconst args =\r\n\t\t{\r\n\t\t\toutput_key: output_key,\r\n\t\t\tderivation: derivation,\r\n\t\t\tout_index: \"\" + out_index, // must be passed as string\r\n\t\t};\r\n\t\tconst args_str = JSON.stringify(args);\r\n\t\tconst ret_string = this.Module.derive_subaddress_public_key(args_str);\r\n\t\tconst ret = JSON.parse(ret_string);\r\n\t\tif (typeof ret.err_msg !== 'undefined' && ret.err_msg) {\r\n\t\t\treturn { err_msg: ret.err_msg };\r\n\t\t}\r\n\t\treturn ret.retVal;\t\t\r\n\t}\r\n\tdecodeRct(rv, sk, i)\r\n\t{\r\n\t\tconst ecdhInfo = []; // should obvs be plural but just keeping exact names in-tact\r\n\t\tfor (var j = 0 ; j < rv.outPk.length ; j++) {\r\n\t\t\tvar this_ecdhInfo = rv.ecdhInfo[j];\r\n  \t\t\tecdhInfo.push({\r\n\t\t\t\tmask: this_ecdhInfo.mask,\r\n\t\t\t\tamount: this_ecdhInfo.amount\r\n\t\t\t})\r\n\t\t}\r\n\t\tconst outPk = [];\r\n\t\tfor (var j = 0 ; j < rv.outPk.length ; j++) {\r\n\t\t\tvar this_outPk_mask = null;\r\n\t\t\tvar this_outPk = rv.outPk[j];\r\n\t\t\tif (typeof this_outPk === 'string') {\r\n\t\t\t\tthis_outPk_mask = this_outPk;\r\n\t\t\t} else if (typeof this_outPk === \"object\") {\r\n\t\t\t\tthis_outPk_mask = this_outPk.mask; \r\n\t\t\t}\r\n\t\t\tif (this_outPk_mask == null) {\r\n\t\t\t\treturn { err_msg: \"Couldn't locate outPk mask value\" }\r\n\t\t\t}\r\n  \t\t\toutPk.push({\r\n\t\t\t\tmask: this_outPk_mask\r\n\t\t\t})\r\n\t\t}\r\n\t\tconst args =\r\n\t\t{\r\n\t\t\ti: \"\" + i,  // must be passed as string\r\n\t\t\tsk: sk,\r\n\t\t\trv: {\r\n\t\t\t\ttype: \"\" + rv.type/*must be string*/, // e.g. 1, 3 ... corresponding to rct::RCTType* in rctSigs.cpp\r\n\t\t\t\tecdhInfo: ecdhInfo,\r\n\t\t\t\toutPk: outPk\r\n\t\t\t}\r\n\t\t};\r\n\t\tconst args_str = JSON.stringify(args);\r\n\t\tconst ret_string = this.Module.decodeRct(args_str);\r\n\t\tconst ret = JSON.parse(ret_string);\r\n\t\tif (typeof ret.err_msg !== 'undefined' && ret.err_msg) {\r\n\t\t\treturn { err_msg: ret.err_msg }\r\n\t\t}\r\n\t\treturn { // calling these out so as to provide a stable ret val interface\r\n\t\t\tamount: ret.amount, // string\r\n\t\t\tmask: ret.mask,\r\n\t\t};\r\n\t}\r\n\testimated_tx_network_fee(fee_per_kb__string, priority, optl__fee_per_b_string) // this is until we switch the server over to fee per b\r\n\t{ // TODO update this API to take object rather than arg list\r\n\t\tconst args =\r\n\t\t{\r\n\t\t\tfee_per_b: typeof optl__fee_per_b_string !== undefined && optl__fee_per_b_string != null \r\n\t\t\t\t? optl__fee_per_b_string \r\n\t\t\t\t: (new JSBigInt(fee_per_kb__string)).divide(1024).toString()/*kib -> b*/, \r\n\t\t\tpriority: \"\" + priority,\r\n\t\t};\r\n\t\tconst args_str = JSON.stringify(args);\r\n\t\tconst ret_string = this.Module.estimated_tx_network_fee(args_str);\r\n\t\tconst ret = JSON.parse(ret_string);\r\n\t\tif (typeof ret.err_msg !== 'undefined' && ret.err_msg) {\r\n\t\t\treturn { err_msg: ret.err_msg } // TODO: maybe return this somehow\r\n\t\t}\r\n\t\treturn ret.retVal; // this is a string - pass it to new JSBigInt()\r\n\t}\r\n\tsend_step1__prepare_params_for_get_decoys(\r\n\t\tis_sweeping,\r\n\t\tsending_amount, // this may be 0 if sweeping\r\n\t\tfee_per_b,\r\n\t\tpriority,\r\n\t\tunspent_outputs,\r\n\t\toptl__payment_id_string, // this may be nil\r\n\t\toptl__passedIn_attemptAt_fee\r\n\t) {\r\n\t\tvar sanitary__unspent_outputs = [];\r\n\t\tfor (let i in unspent_outputs) {\r\n\t\t\tconst sanitary__output = bridge_sanitized__spendable_out(unspent_outputs[i])\r\n\t\t\tsanitary__unspent_outputs.push(sanitary__output);\r\n\t\t}\r\n\t\tconst args =\r\n\t\t{\r\n\t\t\tsending_amount: sending_amount.toString(),\r\n\t\t\tis_sweeping: \"\" + is_sweeping, // bool -> string\r\n\t\t\tpriority: \"\" + priority,\r\n\t\t\tfee_per_b: fee_per_b.toString(),\r\n\t\t\tunspent_outs: sanitary__unspent_outputs // outs, not outputs\r\n\t\t};\r\n\t\tif (typeof optl__payment_id_string !== \"undefined\" && optl__payment_id_string && optl__payment_id_string != \"\") {\r\n\t\t\targs.payment_id_string = optl__payment_id_string;\r\n\t\t}\r\n\t\tif (typeof optl__passedIn_attemptAt_fee !== \"undefined\" && optl__passedIn_attemptAt_fee && optl__passedIn_attemptAt_fee != \"\") {\r\n\t\t\targs.passedIn_attemptAt_fee = optl__passedIn_attemptAt_fee.toString(); // ought to be a string but in case it's a JSBigInt\r\n\t\t}\r\n\t\tconst args_str = JSON.stringify(args);\r\n\t\tconst ret_string = this.Module.send_step1__prepare_params_for_get_decoys(args_str);\r\n\t\tconst ret = JSON.parse(ret_string);\r\n\t\t// special case: err_code of needMoreMoneyThanFound; rewrite err_msg\r\n\t\tif (ret.err_code == \"90\" || ret.err_code == 90) { // declared in mymonero-core-cpp/src/monero_transfer_utils.hpp\r\n\t\t\treturn { \r\n\t\t\t\trequired_balance: ret.required_balance,\r\n\t\t\t\tspendable_balance: ret.spendable_balance,\r\n\t\t\t\terr_msg: `Spendable balance too low. Have ${\r\n\t\t\t\t\tmonero_amount_format_utils.formatMoney(new JSBigInt(ret.spendable_balance))\r\n\t\t\t\t} ${monero_config.coinSymbol}; need ${\r\n\t\t\t\t\tmonero_amount_format_utils.formatMoney(new JSBigInt(ret.required_balance))\r\n\t\t\t\t} ${monero_config.coinSymbol}.` \r\n\t\t\t};\r\n\t\t}\r\n\t\tif (typeof ret.err_msg !== 'undefined' && ret.err_msg) {\r\n\t\t\treturn { err_msg: ret.err_msg };\r\n\t\t}\r\n\t\treturn { // calling these out to set an interface\r\n\t\t\tmixin: parseInt(ret.mixin), // for the server API request to RandomOuts\r\n\t\t\tusing_fee: ret.using_fee, // string; can be passed to step2\r\n\t\t\tchange_amount: ret.change_amount, // string for step2\r\n\t\t\tusing_outs: ret.using_outs, // this can be passed straight to step2\r\n\t\t\tfinal_total_wo_fee: ret.final_total_wo_fee // aka sending_amount for step2\r\n\t\t};\r\n\t}\r\n\tsend_step2__try_create_transaction( // send only IPC-safe vals - no JSBigInts\r\n\t\tfrom_address_string,\r\n\t\tsec_keys,\r\n\t\tto_address_string,\r\n\t\tusing_outs,\r\n\t\tmix_outs,\r\n\t\tfake_outputs_count,\r\n\t\tfinal_total_wo_fee,\r\n\t\tchange_amount,\r\n\t\tfee_amount,\r\n\t\tpayment_id,\r\n\t\tpriority,\r\n\t\tfee_per_b, // not kib - if fee_per_kb, /= 1024\r\n\t\tunlock_time,\r\n\t\tnettype\r\n\t) {\r\n\t\tunlock_time = unlock_time || 0;\r\n\t\tmix_outs = mix_outs || [];\r\n\t\t// NOTE: we also do this check in the C++... may as well remove it from here\r\n\t\tif (mix_outs.length !== using_outs.length && fake_outputs_count !== 0) {\r\n\t\t\treturn { \r\n\t\t\t\terr_msg: \"Wrong number of mix outs provided (\" +\r\n\t\t\t\t\tusing_outs.length + \" using_outs, \" +\r\n\t\t\t\t\tmix_outs.length + \" mix outs)\"\r\n\t\t\t};\r\n\t\t}\r\n\t\tfor (var i = 0; i < mix_outs.length; i++) {\r\n\t\t\tif ((mix_outs[i].outputs || []).length < fake_outputs_count) {\r\n\t\t\t\treturn { err_msg: \"Not enough outputs to mix with\" };\r\n\t\t\t}\r\n\t\t}\r\n\t\t//\r\n\t\t// Now we need to convert all non-JSON-serializable objects such as JSBigInts to strings etc - not that there should be any!\r\n\t\t// - and all numbers to strings - especially those which may be uint64_t on the receiving side\r\n\t\tvar sanitary__using_outs = [];\r\n\t\tfor (let i in using_outs) {\r\n\t\t\tconst sanitary__output = bridge_sanitized__spendable_out(using_outs[i])\r\n\t\t\tsanitary__using_outs.push(sanitary__output);\r\n\t\t}\r\n\t\tvar sanitary__mix_outs = [];\r\n\t\tfor (let i in mix_outs) {\r\n\t\t\tconst sanitary__mix_outs_and_amount =\r\n\t\t\t{\r\n\t\t\t\tamount: mix_outs[i].amount.toString(), // it should be a string, but in case it's not\r\n\t\t\t\toutputs: [] \r\n\t\t\t};\r\n\t\t\tif (mix_outs[i].outputs && typeof mix_outs[i].outputs !== 'undefined') {\r\n\t\t\t\tfor (let j in mix_outs[i].outputs) {\r\n\t\t\t\t\tconst sanitary__mix_out =\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tglobal_index: \"\" + mix_outs[i].outputs[j].global_index, // number to string\r\n\t\t\t\t\t\tpublic_key: mix_outs[i].outputs[j].public_key\r\n\t\t\t\t\t};\r\n\t\t\t\t\tif (mix_outs[i].outputs[j].rct && typeof mix_outs[i].outputs[j].rct !== 'undefined') {\r\n\t\t\t\t\t\tsanitary__mix_out.rct = mix_outs[i].outputs[j].rct;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsanitary__mix_outs_and_amount.outputs.push(sanitary__mix_out);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tsanitary__mix_outs.push(sanitary__mix_outs_and_amount);\r\n\t\t}\r\n\t\tconst args =\r\n\t\t{\r\n\t\t\tfrom_address_string: from_address_string,\r\n\t\t\tsec_viewKey_string: sec_keys.view,\r\n\t\t\tsec_spendKey_string: sec_keys.spend,\r\n\t\t\tto_address_string: to_address_string,\r\n\t\t\tfinal_total_wo_fee: final_total_wo_fee.toString(),\r\n\t\t\tchange_amount: change_amount.toString(),\r\n\t\t\tfee_amount: fee_amount.toString(),\r\n\t\t\tpriority: \"\" + priority,\r\n\t\t\tfee_per_b: fee_per_b.toString(),\r\n\t\t\tusing_outs: sanitary__using_outs,\r\n\t\t\tmix_outs: sanitary__mix_outs,\r\n\t\t\tunlock_time: \"\" + unlock_time, // bridge is expecting a string\r\n\t\t\tnettype_string: nettype_utils.nettype_to_API_string(nettype)\r\n\t\t};\r\n\t\tif (typeof payment_id !== \"undefined\" && payment_id) {\r\n\t\t\targs.payment_id_string = payment_id;\r\n\t\t}\r\n\t\tconst args_str = JSON.stringify(args);\r\n\t\tconst ret_string = this.Module.send_step2__try_create_transaction(args_str);\r\n\t\tconst ret = JSON.parse(ret_string);\r\n\t\t//\r\n\t\tif (typeof ret.err_msg !== 'undefined' && ret.err_msg) {\r\n\t\t\treturn { err_msg: ret.err_msg, tx_must_be_reconstructed: false };\r\n\t\t}\r\n\t\tif (ret.tx_must_be_reconstructed == \"true\" || ret.tx_must_be_reconstructed == true) {\r\n\t\t\tif (typeof ret.fee_actually_needed == 'undefined' || !ret.fee_actually_needed) {\r\n\t\t\t\tthrow \"tx_must_be_reconstructed; expected non-nil fee_actually_needed\"\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\ttx_must_be_reconstructed: ret.tx_must_be_reconstructed, // if true, re-do procedure from step1 except for requesting UnspentOuts (that can be done oncet)\r\n\t\t\t\tfee_actually_needed: ret.fee_actually_needed // can be passed back to step1\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn { // calling these out to set an interface\r\n\t\t\ttx_must_be_reconstructed: false, // in case caller is not checking for nil\r\n\t\t\tsigned_serialized_tx: ret.serialized_signed_tx, // this name change should be fixed to serialized_signed_tx\r\n\t\t\ttx_hash: ret.tx_hash,\r\n\t\t\ttx_key: ret.tx_key\r\n\t\t};\r\n\t}\r\n\r\n}\r\n//\r\nmodule.exports = function(options)\r\n{\r\n\toptions = options || {}\r\n\t//\r\n\tconst ENVIRONMENT_IS_WEB = typeof window===\"object\";\r\n\tconst ENVIRONMENT_IS_WORKER = typeof importScripts===\"function\";\r\n\tconst ENVIRONMENT_IS_NODE = typeof process===\"object\" && process.browser !== true && \"function\"===\"function\" && ENVIRONMENT_IS_WORKER == false; // we want this to be true for Electron but not for a WebView\r\n\tconst ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\r\n\tfunction locateFile(filename, scriptDirectory)\r\n\t{\r\n\t\t// if (options[\"locateFile\"]) {\r\n\t\t// \treturn options[\"locateFile\"](filename, scriptDirectory)\r\n\t\t// }\r\n\t\tvar this_scriptDirectory = scriptDirectory\r\n\t\tconst lastChar = this_scriptDirectory.charAt(this_scriptDirectory.length - 1)\r\n\t\tif (lastChar == \"/\" || lastChar == \"\\\\\") { \r\n\t\t\t// ^-- this is not a '\\\\' on Windows because emscripten actually appends a '/'\r\n\t\t\tthis_scriptDirectory = this_scriptDirectory.substring(0, this_scriptDirectory.length - 1) // remove trailing \"/\"\r\n\t\t}\r\n\t\tvar fullPath = null; // add trailing slash to this\r\n\t\tif (ENVIRONMENT_IS_NODE) {\r\n\t\t\tconst path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\")\r\n\t\t\tconst lastPathComponent = path.basename(this_scriptDirectory)\r\n\t\t\tif (lastPathComponent == \"monero_utils\") { // typical node or electron-main process\r\n\t\t\t\tfullPath = path.format({\r\n\t\t\t\t\tdir: this_scriptDirectory,\r\n\t\t\t\t\tbase: filename\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tconsole.warn(\"MyMoneroCoreBridge/locateFile() on node.js didn't find \\\"monero_utils\\\" (or possibly MyMoneroCoreBridge.js) itself in the expected location in the following path. The function may need to be expanded but it might in normal situations be likely to be another bug.\" ,  pathTo_cryptonoteUtilsDir)\r\n\t\t\t}\r\n\t\t} else if (ENVIRONMENT_IS_WEB) {\r\n\t\t\tvar pathTo_cryptonoteUtilsDir;\r\n\t\t\tif (typeof __dirname !== undefined && __dirname !== \"/\") { // looks like node running in browser.. (but not going to assume it's electron-renderer since that should be taken care of by monero_utils.js itself)\r\n\t\t\t\t// but just in case it is... here's an attempt to support it\r\n\t\t\t\t// have to check != \"/\" b/c webpack (I think) replaces __dirname\r\n\t\t\t\tpathTo_cryptonoteUtilsDir = \"file://\" + __dirname + \"/\" // prepending \"file://\" because it's going to try to stream it\r\n\t\t\t} else { // actual web browser\r\n\t\t\t\tpathTo_cryptonoteUtilsDir = this_scriptDirectory + \"/mymonero_core_js/monero_utils/\" // this works for the MyMonero browser build, and is quite general, at least\r\n\t\t\t}\r\n\t\t\tfullPath = pathTo_cryptonoteUtilsDir + filename\r\n\t\t}\r\n\t\tif (fullPath == null) {\r\n\t\t\tthrow \"Unable to derive fullPath. Please pass locateFile() to cryptonote_utils init.\"\r\n\t\t}\r\n\t\t//\r\n\t\treturn fullPath\r\n\t}\r\n\treturn new Promise(function(resolve, reject) {\r\n\t\tvar Module_template = {}\r\n\t\tif (options.asmjs != true || options.wasm == true) { // wasm\r\n\t\t\tModule_template[\"locateFile\"] = locateFile\r\n\t\t\t//\r\n\t\t\t// NOTE: This requires src/module-post.js to be included as post-js in CMakeLists.txt under a wasm build\r\n\t\t\t__webpack_require__(/*! ./MyMoneroCoreCpp_WASM */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/MyMoneroCoreCpp_WASM.wasm\")(Module_template).ready.then(function(thisModule) \r\n\t\t\t{\r\n\t\t\t\tconst instance = new MyMoneroCoreBridge(thisModule);\r\n\t\t\t\tresolve(instance);\r\n\t\t\t}).catch(function(e) {\r\n\t\t\t\tconsole.error(\"Error loading MyMoneroCoreCpp_WASM:\", e);\r\n\t\t\t\treject(e);\r\n\t\t\t});\r\n\t\t} else { // this is synchronous so we can resolve immediately\r\n\t\t\tvar scriptDirectory=\"\"; // this was extracted from emscripten - it could get factored if anything else would ever need it\r\n\t\t\tif (ENVIRONMENT_IS_NODE) {\r\n\t\t\t\tscriptDirectory=__dirname+\"/\";\r\n\t\t\t} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\r\n\t\t\t\tif (ENVIRONMENT_IS_WORKER) {\r\n\t\t\t\t\tscriptDirectory = self.location.href\r\n\t\t\t\t} else if (document.currentScript) {\r\n\t\t\t\t\tscriptDirectory = document.currentScript.src\r\n\t\t\t\t}\r\n\t\t\t\tvar _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\r\n\t\t\t\tif(_scriptDir){\r\n\t\t\t\t\tscriptDirectory = _scriptDir\r\n\t\t\t\t}\r\n\t\t\t\tif (scriptDirectory.indexOf(\"blob:\") !== 0) {\r\n\t\t\t\t\tscriptDirectory = scriptDirectory.substr(0,scriptDirectory.lastIndexOf(\"/\")+1)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tscriptDirectory = \"\"\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar read_fn;\r\n\t\t\tif (ENVIRONMENT_IS_NODE) {\r\n\t\t\t\tread_fn = function(filepath)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn __webpack_require__(/*! fs */ \"./node_modules/html5-fs/src/api.js\").readFileSync(__webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\").normalize(filepath)).toString()\r\n\t\t\t\t};\r\n\t\t\t} else if (ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER) {\r\n\t\t\t\tread_fn = function(url)\r\n\t\t\t\t{ // it's an option to move this over to fetch, but, fetch requires a polyfill for these older browsers anyway - making fetch an automatic dep just for asmjs fallback - and the github/fetch polyfill does not appear to actually support mode (for 'same-origin' policy) anyway - probably not worth it yet \r\n\t\t\t\t\tvar xhr = new XMLHttpRequest()\r\n\t\t\t\t\txhr.open(\"GET\", url, false)\r\n\t\t\t\t\txhr.send(null)\r\n\t\t\t\t\t//\r\n\t\t\t\t\treturn xhr.responseText\r\n\t\t\t\t};\r\n\t\t\t} else {\r\n\t\t\t\tthrow \"Unsupported environment - please implement file reading for asmjs fallback case\"\r\n\t\t\t}\r\n\t\t\tconst filepath = locateFile('MyMoneroCoreCpp_ASMJS.asm.js', scriptDirectory)\r\n\t\t\tconst content = read_fn(filepath)\r\n\t\t\t// TODO: verify content - for now, relying on same-origin and tls/ssl\r\n\t\t\tvar Module = {}\r\n\t\t\ttry {\r\n\t\t\t\teval(content) // I do not believe this is a safety concern, because content is server-controlled; https://humanwhocodes.com/blog/2013/06/25/eval-isnt-evil-just-misunderstood/\r\n\t\t\t} catch (e) {\r\n\t\t\t\treject(e)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tsetTimeout(function()\r\n\t\t\t{ // \"delaying even 1ms is enough to allow compilation memory to be reclaimed\"\r\n\t\t\t\tModule_template['asm'] = Module['asm']\r\n\t\t\t\tModule = null\r\n\t\t\t\tresolve(new MyMoneroCoreBridge(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './MyMoneroCoreCpp_ASMJS'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))(Module_template)))\r\n\t\t\t}, 1) \r\n\t\t}\r\n\t});\r\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/process/browser.js */ \"./node_modules/process/browser.js\"), \"/\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvbW9uZXJvX3V0aWxzL015TW9uZXJvQ29yZUJyaWRnZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYnMvbXltb25lcm8tYXBwLWpzL2xvY2FsX21vZHVsZXMvbXltb25lcm9fY29yZV9qcy9tb25lcm9fdXRpbHMvTXlNb25lcm9Db3JlQnJpZGdlLmpzPzY1NDQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTgsIE15TW9uZXJvLmNvbVxyXG4vL1xyXG4vLyBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vL1xyXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmVcclxuLy8gcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbi8vXHJcbi8vIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mXHJcbi8vXHRjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbi8vXHJcbi8vIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0XHJcbi8vXHRvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyXHJcbi8vXHRtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4vL1xyXG4vLyAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBjb3B5cmlnaHQgaG9sZGVyIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmVcclxuLy9cdHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWNcclxuLy9cdHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuLy9cclxuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EIEFOWVxyXG4vLyBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcclxuLy8gTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTExcclxuLy8gVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXHJcbi8vIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcclxuLy8gUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXHJcbi8vIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxyXG4vLyBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcclxuLy8gVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG5cclxuLy8gT3JpZ2luYWwgQXV0aG9yOiBMdWNhcyBKb25lc1xyXG4vLyBNb2RpZmllZCB0byByZW1vdmUgalF1ZXJ5IGRlcCBhbmQgc3VwcG9ydCBtb2R1bGFyIGluY2x1c2lvbiBvZiBkZXBzIGJ5IFBhdWwgU2hhcGlybyAoMjAxNilcclxuLy8gTW9kaWZpZWQgdG8gYWRkIFJpbmdDVCBzdXBwb3J0IGJ5IGx1aWdpMTExMSAoMjAxNylcclxuLy9cclxuLy8gdi0tLSBUaGVzZSBzaG91bGQgbWF5YmUgYmUgaW5qZWN0ZWQgaW50byBhIGNvbnRleHQgYW5kIHN1cHBsaWVkIHRvIGN1cnJlbmN5Q29uZmlnIGZvciBmdXR1cmUgcGxhdGZvcm1zXHJcbmNvbnN0IEpTQmlnSW50ID0gcmVxdWlyZShcIi4uL2NyeXB0b25vdGVfdXRpbHMvYmlnaW50ZWdlclwiKS5CaWdJbnRlZ2VyO1xyXG5jb25zdCBuZXR0eXBlX3V0aWxzID0gcmVxdWlyZShcIi4uL2NyeXB0b25vdGVfdXRpbHMvbmV0dHlwZVwiKTtcclxuY29uc3QgbW9uZXJvX2NvbmZpZyA9IHJlcXVpcmUoJy4vbW9uZXJvX2NvbmZpZycpO1xyXG5jb25zdCBtb25lcm9fYW1vdW50X2Zvcm1hdF91dGlscyA9IHJlcXVpcmUoXCIuLi9jcnlwdG9ub3RlX3V0aWxzL21vbmV5X2Zvcm1hdF91dGlsc1wiKShtb25lcm9fY29uZmlnKTtcclxuLy9cclxuZnVuY3Rpb24gcmV0X3ZhbF9ib29sc3RyaW5nX3RvX2Jvb2woYm9vbHN0cmluZylcclxue1xyXG5cdGlmICh0eXBlb2YgYm9vbHN0cmluZyAhPT0gXCJzdHJpbmdcIikge1xyXG5cdFx0dGhyb3cgXCJyZXRfdmFsX2Jvb2xzdHJpbmdfdG9fYm9vbCBleHBlY3RlZCBzdHJpbmcgaW5wdXRcIlxyXG5cdH1cclxuXHRpZiAoYm9vbHN0cmluZyA9PT0gXCJ0cnVlXCIpIHtcclxuXHRcdHJldHVybiB0cnVlXHJcblx0fSBlbHNlIGlmIChib29sc3RyaW5nID09PSBcImZhbHNlXCIpIHtcclxuXHRcdHJldHVybiBmYWxzZVxyXG5cdH1cclxuXHR0aHJvdyBcInJldF92YWxfYm9vbHN0cmluZ190b19ib29sIGdpdmVuIGlsbGVnYWwgaW5wdXRcIlxyXG59XHJcbmZ1bmN0aW9uIGFwaV9zYWZlX3dvcmRzZXRfbmFtZSh3b3Jkc2V0X25hbWUpXHJcbntcclxuXHQvLyBjb252ZXJ0IGFsbCBsb3dlcmNhc2UsIGxlZ2FjeSB2YWx1ZXMgdG8gY29yZS1jcHAgY29tcGF0aWJsZVxyXG5cdGlmICh3b3Jkc2V0X25hbWUgPT0gXCJlbmdsaXNoXCIpIHtcclxuXHRcdHJldHVybiBcIkVuZ2xpc2hcIlxyXG5cdH0gZWxzZSBpZiAod29yZHNldF9uYW1lID09IFwic3BhbmlzaFwiKSB7XHJcblx0XHRyZXR1cm4gXCJFc3Bhw7FvbFwiXHJcblx0fSBlbHNlIGlmICh3b3Jkc2V0X25hbWUgPT0gXCJwb3J0dWd1ZXNlXCIpIHtcclxuXHRcdHJldHVybiBcIlBvcnR1Z3XDqnNcIlxyXG5cdH0gZWxzZSBpZiAod29yZHNldF9uYW1lID09IFwiamFwYW5lc2VcIikge1xyXG5cdFx0cmV0dXJuIFwi5pel5pys6KqeXCJcclxuXHR9XHJcblx0cmV0dXJuIHdvcmRzZXRfbmFtZSAvLyBtdXN0IGJlIGEgdmFsdWUgcmV0dXJuZWQgYnkgY29yZS1jcHBcclxufVxyXG5mdW5jdGlvbiBicmlkZ2Vfc2FuaXRpemVkX19zcGVuZGFibGVfb3V0KHJhd19fb3V0KVxyXG57XHJcblx0Y29uc3Qgc2FuaXRhcnlfX291dHB1dCA9IFxyXG5cdHtcclxuXHRcdGFtb3VudDogcmF3X19vdXQuYW1vdW50LnRvU3RyaW5nKCksXHJcblx0XHRwdWJsaWNfa2V5OiByYXdfX291dC5wdWJsaWNfa2V5LFxyXG5cdFx0Z2xvYmFsX2luZGV4OiBcIlwiICsgcmF3X19vdXQuZ2xvYmFsX2luZGV4LFxyXG5cdFx0aW5kZXg6IFwiXCIgKyByYXdfX291dC5pbmRleCxcclxuXHRcdHR4X3B1Yl9rZXk6IHJhd19fb3V0LnR4X3B1Yl9rZXlcclxuXHR9O1xyXG5cdGlmIChyYXdfX291dC5yY3QgJiYgdHlwZW9mIHJhd19fb3V0LnJjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdHNhbml0YXJ5X19vdXRwdXQucmN0ID0gcmF3X19vdXQucmN0O1xyXG5cdH1cclxuXHRyZXR1cm4gc2FuaXRhcnlfX291dHB1dDtcclxufVxyXG4vL1xyXG5jbGFzcyBNeU1vbmVyb0NvcmVCcmlkZ2Vcclxue1xyXG5cdGNvbnN0cnVjdG9yKHRoaXNfTW9kdWxlKVxyXG5cdHtcclxuXHRcdHRoaXMuTW9kdWxlID0gdGhpc19Nb2R1bGU7XHJcblx0fVxyXG5cdC8vXHJcblx0Ly9cclxuXHRpc19zdWJhZGRyZXNzKGFkZHIsIG5ldHR5cGUpIHtcclxuXHRcdGNvbnN0IGFyZ3MgPVxyXG5cdFx0e1xyXG5cdFx0XHRhZGRyZXNzOiBhZGRyLFxyXG5cdFx0XHRuZXR0eXBlX3N0cmluZzogbmV0dHlwZV91dGlscy5uZXR0eXBlX3RvX0FQSV9zdHJpbmcobmV0dHlwZSlcclxuXHRcdH07XHJcblx0XHRjb25zdCBhcmdzX3N0ciA9IEpTT04uc3RyaW5naWZ5KGFyZ3MpO1xyXG5cdFx0Y29uc3QgcmV0X3N0cmluZyA9IHRoaXMuTW9kdWxlLmlzX3N1YmFkZHJlc3MoYXJnc19zdHIpO1xyXG5cdFx0Y29uc3QgcmV0ID0gSlNPTi5wYXJzZShyZXRfc3RyaW5nKTtcclxuXHRcdGlmICh0eXBlb2YgcmV0LmVycl9tc2cgIT09ICd1bmRlZmluZWQnICYmIHJldC5lcnJfbXNnKSB7XHJcblx0XHRcdHJldHVybiB7IGVycl9tc2c6IHJldC5lcnJfbXNnIH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXRfdmFsX2Jvb2xzdHJpbmdfdG9fYm9vbChyZXQucmV0VmFsKTtcclxuXHR9XHJcblxyXG5cdGlzX2ludGVncmF0ZWRfYWRkcmVzcyhhZGRyLCBuZXR0eXBlKSB7XHJcblx0XHRjb25zdCBhcmdzID1cclxuXHRcdHtcclxuXHRcdFx0YWRkcmVzczogYWRkcixcclxuXHRcdFx0bmV0dHlwZV9zdHJpbmc6IG5ldHR5cGVfdXRpbHMubmV0dHlwZV90b19BUElfc3RyaW5nKG5ldHR5cGUpXHJcblx0XHR9O1xyXG5cdFx0Y29uc3QgYXJnc19zdHIgPSBKU09OLnN0cmluZ2lmeShhcmdzKTtcclxuXHRcdGNvbnN0IHJldF9zdHJpbmcgPSB0aGlzLk1vZHVsZS5pc19pbnRlZ3JhdGVkX2FkZHJlc3MoYXJnc19zdHIpO1xyXG5cdFx0Y29uc3QgcmV0ID0gSlNPTi5wYXJzZShyZXRfc3RyaW5nKTtcclxuXHRcdGlmICh0eXBlb2YgcmV0LmVycl9tc2cgIT09ICd1bmRlZmluZWQnICYmIHJldC5lcnJfbXNnKSB7XHJcblx0XHRcdHJldHVybiB7IGVycl9tc2c6IHJldC5lcnJfbXNnIH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXRfdmFsX2Jvb2xzdHJpbmdfdG9fYm9vbChyZXQucmV0VmFsKTtcclxuXHR9XHJcblxyXG5cdG5ld19wYXltZW50X2lkKCkge1xyXG5cdFx0Y29uc3QgYXJncyA9IHt9O1xyXG5cdFx0Y29uc3QgYXJnc19zdHIgPSBKU09OLnN0cmluZ2lmeShhcmdzKTtcclxuXHRcdGNvbnN0IHJldF9zdHJpbmcgPSB0aGlzLk1vZHVsZS5uZXdfcGF5bWVudF9pZChhcmdzX3N0cik7XHJcblx0XHRjb25zdCByZXQgPSBKU09OLnBhcnNlKHJldF9zdHJpbmcpO1xyXG5cdFx0aWYgKHR5cGVvZiByZXQuZXJyX21zZyAhPT0gJ3VuZGVmaW5lZCcgJiYgcmV0LmVycl9tc2cpIHtcclxuXHRcdFx0cmV0dXJuIHsgZXJyX21zZzogcmV0LmVycl9tc2cgfVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJldC5yZXRWYWw7XHJcblx0fVxyXG5cclxuXHRuZXdfX2ludF9hZGRyX2Zyb21fYWRkcl9hbmRfc2hvcnRfcGlkKFxyXG5cdFx0YWRkcmVzcyxcclxuXHRcdHNob3J0X3BpZCxcclxuXHRcdG5ldHR5cGVcclxuXHQpIHtcclxuXHRcdGlmICghc2hvcnRfcGlkIHx8IHNob3J0X3BpZC5sZW5ndGggIT0gMTYpIHtcclxuXHRcdFx0cmV0dXJuIHsgZXJyX21zZzogXCJleHBlY3RlZCB2YWxpZCBzaG9ydF9waWRcIiB9O1xyXG5cdFx0fVxyXG5cdFx0Y29uc3QgYXJncyA9XHJcblx0XHR7XHJcblx0XHRcdGFkZHJlc3M6IGFkZHJlc3MsXHJcblx0XHRcdHNob3J0X3BpZDogc2hvcnRfcGlkLFxyXG5cdFx0XHRuZXR0eXBlX3N0cmluZzogbmV0dHlwZV91dGlscy5uZXR0eXBlX3RvX0FQSV9zdHJpbmcobmV0dHlwZSlcclxuXHRcdH07XHJcblx0XHRjb25zdCBhcmdzX3N0ciA9IEpTT04uc3RyaW5naWZ5KGFyZ3MpO1xyXG5cdFx0Y29uc3QgcmV0X3N0cmluZyA9IHRoaXMuTW9kdWxlLm5ld19pbnRlZ3JhdGVkX2FkZHJlc3MoYXJnc19zdHIpO1xyXG5cdFx0Y29uc3QgcmV0ID0gSlNPTi5wYXJzZShyZXRfc3RyaW5nKTtcclxuXHRcdGlmICh0eXBlb2YgcmV0LmVycl9tc2cgIT09ICd1bmRlZmluZWQnICYmIHJldC5lcnJfbXNnKSB7XHJcblx0XHRcdHJldHVybiB7IGVycl9tc2c6IHJldC5lcnJfbXNnIH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXQucmV0VmFsO1xyXG5cdH1cclxuXHJcblx0ZGVjb2RlX2FkZHJlc3MoYWRkcmVzcywgbmV0dHlwZSlcclxuXHR7XHJcblx0XHRjb25zdCBhcmdzID1cclxuXHRcdHtcclxuXHRcdFx0YWRkcmVzczogYWRkcmVzcyxcclxuXHRcdFx0bmV0dHlwZV9zdHJpbmc6IG5ldHR5cGVfdXRpbHMubmV0dHlwZV90b19BUElfc3RyaW5nKG5ldHR5cGUpXHJcblx0XHR9O1xyXG5cdFx0Y29uc3QgYXJnc19zdHIgPSBKU09OLnN0cmluZ2lmeShhcmdzKTtcclxuXHRcdGNvbnN0IHJldF9zdHJpbmcgPSB0aGlzLk1vZHVsZS5kZWNvZGVfYWRkcmVzcyhhcmdzX3N0cik7XHJcblx0XHRjb25zdCByZXQgPSBKU09OLnBhcnNlKHJldF9zdHJpbmcpO1xyXG5cdFx0aWYgKHR5cGVvZiByZXQuZXJyX21zZyAhPT0gJ3VuZGVmaW5lZCcgJiYgcmV0LmVycl9tc2cpIHtcclxuXHRcdFx0cmV0dXJuIHsgZXJyX21zZzogcmV0LmVycl9tc2cgfVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0c3BlbmQ6IHJldC5wdWJfc3BlbmRLZXlfc3RyaW5nLFxyXG5cdFx0XHR2aWV3OiByZXQucHViX3ZpZXdLZXlfc3RyaW5nLFxyXG5cdFx0XHRpbnRQYXltZW50SWQ6IHJldC5wYXltZW50SURfc3RyaW5nLCAvLyBtYXkgYmUgdW5kZWZpbmVkXHJcblx0XHRcdGlzU3ViYWRkcmVzczogcmV0X3ZhbF9ib29sc3RyaW5nX3RvX2Jvb2wocmV0LmlzU3ViYWRkcmVzcylcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdG5ld2x5X2NyZWF0ZWRfd2FsbGV0KFxyXG5cdFx0bG9jYWxlX2xhbmd1YWdlX2NvZGUsXHJcblx0XHRuZXR0eXBlXHJcblx0KSB7XHJcblx0XHRjb25zdCBhcmdzID1cclxuXHRcdHtcclxuXHRcdFx0bG9jYWxlX2xhbmd1YWdlX2NvZGU6IGxvY2FsZV9sYW5ndWFnZV9jb2RlLCAvLyBOT1RFOiB0aGlzIGZ1bmN0aW9uIHRha2VzIHRoZSBsb2NhbGUsIG5vdCB0aGUgd29yZHNldCBuYW1lXHJcblx0XHRcdG5ldHR5cGVfc3RyaW5nOiBuZXR0eXBlX3V0aWxzLm5ldHR5cGVfdG9fQVBJX3N0cmluZyhuZXR0eXBlKVxyXG5cdFx0fTtcclxuXHRcdGNvbnN0IGFyZ3Nfc3RyID0gSlNPTi5zdHJpbmdpZnkoYXJncyk7XHJcblx0XHRjb25zdCByZXRfc3RyaW5nID0gdGhpcy5Nb2R1bGUubmV3bHlfY3JlYXRlZF93YWxsZXQoYXJnc19zdHIpO1xyXG5cdFx0Y29uc3QgcmV0ID0gSlNPTi5wYXJzZShyZXRfc3RyaW5nKTtcclxuXHRcdGlmICh0eXBlb2YgcmV0LmVycl9tc2cgIT09ICd1bmRlZmluZWQnICYmIHJldC5lcnJfbXNnKSB7XHJcblx0XHRcdHJldHVybiB7IGVycl9tc2c6IHJldC5lcnJfbXNnIH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB7IC8vIGNhbGxpbmcgdGhlc2Ugb3V0IHNvIGFzIHRvIHByb3ZpZGUgYSBzdGFibGUgcmV0IHZhbCBpbnRlcmZhY2VcclxuXHRcdFx0bW5lbW9uaWNfc3RyaW5nOiByZXQubW5lbW9uaWNfc3RyaW5nLFxyXG5cdFx0XHRtbmVtb25pY19sYW5ndWFnZTogcmV0Lm1uZW1vbmljX2xhbmd1YWdlLFxyXG5cdFx0XHRzZWNfc2VlZF9zdHJpbmc6IHJldC5zZWNfc2VlZF9zdHJpbmcsXHJcblx0XHRcdGFkZHJlc3Nfc3RyaW5nOiByZXQuYWRkcmVzc19zdHJpbmcsXHJcblx0XHRcdHB1Yl92aWV3S2V5X3N0cmluZzogcmV0LnB1Yl92aWV3S2V5X3N0cmluZyxcclxuXHRcdFx0c2VjX3ZpZXdLZXlfc3RyaW5nOiByZXQuc2VjX3ZpZXdLZXlfc3RyaW5nLFxyXG5cdFx0XHRwdWJfc3BlbmRLZXlfc3RyaW5nOiByZXQucHViX3NwZW5kS2V5X3N0cmluZyxcclxuXHRcdFx0c2VjX3NwZW5kS2V5X3N0cmluZzogcmV0LnNlY19zcGVuZEtleV9zdHJpbmdcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRhcmVfZXF1YWxfbW5lbW9uaWNzKGEsIGIpIHtcclxuXHRcdGNvbnN0IGFyZ3MgPVxyXG5cdFx0e1xyXG5cdFx0XHRhOiBhLFxyXG5cdFx0XHRiOiBiXHJcblx0XHR9O1xyXG5cdFx0Y29uc3QgYXJnc19zdHIgPSBKU09OLnN0cmluZ2lmeShhcmdzKTtcclxuXHRcdGNvbnN0IHJldF9zdHJpbmcgPSB0aGlzLk1vZHVsZS5hcmVfZXF1YWxfbW5lbW9uaWNzKGFyZ3Nfc3RyKTtcclxuXHRcdGNvbnN0IHJldCA9IEpTT04ucGFyc2UocmV0X3N0cmluZyk7XHJcblx0XHRpZiAodHlwZW9mIHJldC5lcnJfbXNnICE9PSAndW5kZWZpbmVkJyAmJiByZXQuZXJyX21zZykge1xyXG5cdFx0XHRyZXR1cm4geyBlcnJfbXNnOiByZXQuZXJyX21zZyB9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmV0X3ZhbF9ib29sc3RyaW5nX3RvX2Jvb2wocmV0LnJldFZhbCk7XHJcblx0fVxyXG5cclxuXHRtbmVtb25pY19mcm9tX3NlZWQoXHJcblx0XHRzZWVkX3N0cmluZyxcclxuXHRcdHdvcmRzZXRfbmFtZVxyXG5cdCkge1xyXG5cdFx0Y29uc3QgYXJncyA9XHJcblx0XHR7XHJcblx0XHRcdHNlZWRfc3RyaW5nOiBzZWVkX3N0cmluZyxcclxuXHRcdFx0d29yZHNldF9uYW1lOiBhcGlfc2FmZV93b3Jkc2V0X25hbWUod29yZHNldF9uYW1lKVxyXG5cdFx0fTtcclxuXHRcdGNvbnN0IGFyZ3Nfc3RyID0gSlNPTi5zdHJpbmdpZnkoYXJncyk7XHJcblx0XHRjb25zdCByZXRfc3RyaW5nID0gdGhpcy5Nb2R1bGUubW5lbW9uaWNfZnJvbV9zZWVkKGFyZ3Nfc3RyKTtcclxuXHRcdGNvbnN0IHJldCA9IEpTT04ucGFyc2UocmV0X3N0cmluZyk7XHJcblx0XHRpZiAodHlwZW9mIHJldC5lcnJfbXNnICE9PSAndW5kZWZpbmVkJyAmJiByZXQuZXJyX21zZykge1xyXG5cdFx0XHRyZXR1cm4geyBlcnJfbXNnOiByZXQuZXJyX21zZyB9IC8vIFRPRE86IG1heWJlIHJldHVybiB0aGlzIHNvbWVob3dcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXQucmV0VmFsO1xyXG5cdH1cclxuXHJcblx0c2VlZF9hbmRfa2V5c19mcm9tX21uZW1vbmljKFxyXG5cdFx0bW5lbW9uaWNfc3RyaW5nLFxyXG5cdFx0bmV0dHlwZVxyXG5cdCkge1xyXG5cdFx0Y29uc3QgYXJncyA9XHJcblx0XHR7XHJcblx0XHRcdG1uZW1vbmljX3N0cmluZzogbW5lbW9uaWNfc3RyaW5nLFxyXG5cdFx0XHRuZXR0eXBlX3N0cmluZzogbmV0dHlwZV91dGlscy5uZXR0eXBlX3RvX0FQSV9zdHJpbmcobmV0dHlwZSlcclxuXHRcdH07XHJcblx0XHRjb25zdCBhcmdzX3N0ciA9IEpTT04uc3RyaW5naWZ5KGFyZ3MpO1xyXG5cdFx0Y29uc3QgcmV0X3N0cmluZyA9IHRoaXMuTW9kdWxlLnNlZWRfYW5kX2tleXNfZnJvbV9tbmVtb25pYyhhcmdzX3N0cik7XHJcblx0XHRjb25zdCByZXQgPSBKU09OLnBhcnNlKHJldF9zdHJpbmcpO1xyXG5cdFx0aWYgKHR5cGVvZiByZXQuZXJyX21zZyAhPT0gJ3VuZGVmaW5lZCcgJiYgcmV0LmVycl9tc2cpIHtcclxuXHRcdFx0cmV0dXJuIHsgZXJyX21zZzogcmV0LmVycl9tc2cgfVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHsgLy8gY2FsbGluZyB0aGVzZSBvdXQgc28gYXMgdG8gcHJvdmlkZSBhIHN0YWJsZSByZXQgdmFsIGludGVyZmFjZVxyXG5cdFx0XHRzZWNfc2VlZF9zdHJpbmc6IHJldC5zZWNfc2VlZF9zdHJpbmcsXHJcblx0XHRcdG1uZW1vbmljX2xhbmd1YWdlOiByZXQubW5lbW9uaWNfbGFuZ3VhZ2UsXHJcblx0XHRcdGFkZHJlc3Nfc3RyaW5nOiByZXQuYWRkcmVzc19zdHJpbmcsXHJcblx0XHRcdHB1Yl92aWV3S2V5X3N0cmluZzogcmV0LnB1Yl92aWV3S2V5X3N0cmluZyxcclxuXHRcdFx0c2VjX3ZpZXdLZXlfc3RyaW5nOiByZXQuc2VjX3ZpZXdLZXlfc3RyaW5nLFxyXG5cdFx0XHRwdWJfc3BlbmRLZXlfc3RyaW5nOiByZXQucHViX3NwZW5kS2V5X3N0cmluZyxcclxuXHRcdFx0c2VjX3NwZW5kS2V5X3N0cmluZzogcmV0LnNlY19zcGVuZEtleV9zdHJpbmdcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHR2YWxpZGF0ZV9jb21wb25lbnRzX2Zvcl9sb2dpbihcclxuXHRcdGFkZHJlc3Nfc3RyaW5nLFxyXG5cdFx0c2VjX3ZpZXdLZXlfc3RyaW5nLFxyXG5cdFx0c2VjX3NwZW5kS2V5X3N0cmluZyxcclxuXHRcdHNlZWRfc3RyaW5nLFxyXG5cdFx0bmV0dHlwZVxyXG5cdCkge1xyXG5cdFx0Y29uc3QgYXJncyA9XHJcblx0XHR7XHJcblx0XHRcdGFkZHJlc3Nfc3RyaW5nOiBhZGRyZXNzX3N0cmluZyxcclxuXHRcdFx0c2VjX3ZpZXdLZXlfc3RyaW5nOiBzZWNfdmlld0tleV9zdHJpbmcsXHJcblx0XHRcdHNlY19zcGVuZEtleV9zdHJpbmc6IHNlY19zcGVuZEtleV9zdHJpbmcsXHJcblx0XHRcdHNlZWRfc3RyaW5nOiBzZWVkX3N0cmluZyxcclxuXHRcdFx0bmV0dHlwZV9zdHJpbmc6IG5ldHR5cGVfdXRpbHMubmV0dHlwZV90b19BUElfc3RyaW5nKG5ldHR5cGUpXHJcblx0XHR9O1xyXG5cdFx0Y29uc3QgYXJnc19zdHIgPSBKU09OLnN0cmluZ2lmeShhcmdzKTtcclxuXHRcdGNvbnN0IHJldF9zdHJpbmcgPSB0aGlzLk1vZHVsZS52YWxpZGF0ZV9jb21wb25lbnRzX2Zvcl9sb2dpbihhcmdzX3N0cik7XHJcblx0XHRjb25zdCByZXQgPSBKU09OLnBhcnNlKHJldF9zdHJpbmcpO1xyXG5cdFx0aWYgKHR5cGVvZiByZXQuZXJyX21zZyAhPT0gJ3VuZGVmaW5lZCcgJiYgcmV0LmVycl9tc2cpIHtcclxuXHRcdFx0cmV0dXJuIHsgZXJyX21zZzogcmV0LmVycl9tc2cgfVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHsgLy8gY2FsbGluZyB0aGVzZSBvdXQgc28gYXMgdG8gcHJvdmlkZSBhIHN0YWJsZSByZXQgdmFsIGludGVyZmFjZVxyXG5cdFx0XHRpc1ZhbGlkOiByZXRfdmFsX2Jvb2xzdHJpbmdfdG9fYm9vbChyZXQuaXNWYWxpZCksXHJcblx0XHRcdGlzSW5WaWV3T25seU1vZGU6IHJldF92YWxfYm9vbHN0cmluZ190b19ib29sKHJldC5pc0luVmlld09ubHlNb2RlKSxcclxuXHRcdFx0cHViX3ZpZXdLZXlfc3RyaW5nOiByZXQucHViX3ZpZXdLZXlfc3RyaW5nLFxyXG5cdFx0XHRwdWJfc3BlbmRLZXlfc3RyaW5nOiByZXQucHViX3NwZW5kS2V5X3N0cmluZ1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdGFkZHJlc3NfYW5kX2tleXNfZnJvbV9zZWVkKFxyXG5cdFx0c2VlZF9zdHJpbmcsXHJcblx0XHRuZXR0eXBlXHJcblx0KSB7XHJcblx0XHRjb25zdCBhcmdzID1cclxuXHRcdHtcclxuXHRcdFx0c2VlZF9zdHJpbmc6IHNlZWRfc3RyaW5nLFxyXG5cdFx0XHRuZXR0eXBlX3N0cmluZzogbmV0dHlwZV91dGlscy5uZXR0eXBlX3RvX0FQSV9zdHJpbmcobmV0dHlwZSlcclxuXHRcdH07XHJcblx0XHRjb25zdCBhcmdzX3N0ciA9IEpTT04uc3RyaW5naWZ5KGFyZ3MpO1xyXG5cdFx0Y29uc3QgcmV0X3N0cmluZyA9IHRoaXMuTW9kdWxlLmFkZHJlc3NfYW5kX2tleXNfZnJvbV9zZWVkKGFyZ3Nfc3RyKTtcclxuXHRcdGNvbnN0IHJldCA9IEpTT04ucGFyc2UocmV0X3N0cmluZyk7XHJcblx0XHRpZiAodHlwZW9mIHJldC5lcnJfbXNnICE9PSAndW5kZWZpbmVkJyAmJiByZXQuZXJyX21zZykge1xyXG5cdFx0XHRyZXR1cm4geyBlcnJfbXNnOiByZXQuZXJyX21zZyB9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4geyAvLyBjYWxsaW5nIHRoZXNlIG91dCBzbyBhcyB0byBwcm92aWRlIGEgc3RhYmxlIHJldCB2YWwgaW50ZXJmYWNlXHJcblx0XHRcdGFkZHJlc3Nfc3RyaW5nOiByZXQuYWRkcmVzc19zdHJpbmcsXHJcblx0XHRcdHB1Yl92aWV3S2V5X3N0cmluZzogcmV0LnB1Yl92aWV3S2V5X3N0cmluZyxcclxuXHRcdFx0c2VjX3ZpZXdLZXlfc3RyaW5nOiByZXQuc2VjX3ZpZXdLZXlfc3RyaW5nLFxyXG5cdFx0XHRwdWJfc3BlbmRLZXlfc3RyaW5nOiByZXQucHViX3NwZW5kS2V5X3N0cmluZyxcclxuXHRcdFx0c2VjX3NwZW5kS2V5X3N0cmluZzogcmV0LnNlY19zcGVuZEtleV9zdHJpbmdcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZV9rZXlfaW1hZ2UoXHJcblx0XHR0eF9wdWIsXHJcblx0XHR2aWV3X3NlYyxcclxuXHRcdHNwZW5kX3B1YixcclxuXHRcdHNwZW5kX3NlYyxcclxuXHRcdG91dHB1dF9pbmRleFxyXG5cdCkge1xyXG5cdFx0aWYgKHR4X3B1Yi5sZW5ndGggIT09IDY0KSB7XHJcblx0XHRcdHJldHVybiB7IGVycl9tc2c6IFwiSW52YWxpZCB0eF9wdWIgbGVuZ3RoXCIgfTtcclxuXHRcdH1cclxuXHRcdGlmICh2aWV3X3NlYy5sZW5ndGggIT09IDY0KSB7XHJcblx0XHRcdHJldHVybiB7IGVycl9tc2c6IFwiSW52YWxpZCB2aWV3X3NlYyBsZW5ndGhcIiB9O1xyXG5cdFx0fVxyXG5cdFx0aWYgKHNwZW5kX3B1Yi5sZW5ndGggIT09IDY0KSB7XHJcblx0XHRcdHJldHVybiB7IGVycl9tc2c6IFwiSW52YWxpZCBzcGVuZF9wdWIgbGVuZ3RoXCIgfTtcclxuXHRcdH1cclxuXHRcdGlmIChzcGVuZF9zZWMubGVuZ3RoICE9PSA2NCkge1xyXG5cdFx0XHRyZXR1cm4geyBlcnJfbXNnOiBcIkludmFsaWQgc3BlbmRfc2VjIGxlbmd0aFwiIH07XHJcblx0XHR9XHJcblx0XHRjb25zdCBhcmdzID1cclxuXHRcdHtcclxuXHRcdFx0c2VjX3ZpZXdLZXlfc3RyaW5nOiB2aWV3X3NlYyxcclxuXHRcdFx0c2VjX3NwZW5kS2V5X3N0cmluZzogc3BlbmRfc2VjLFxyXG5cdFx0XHRwdWJfc3BlbmRLZXlfc3RyaW5nOiBzcGVuZF9wdWIsXHJcblx0XHRcdHR4X3B1Yl9rZXk6IHR4X3B1YixcclxuXHRcdFx0b3V0X2luZGV4OiBcIlwiICsgb3V0cHV0X2luZGV4XHJcblx0XHR9O1xyXG5cdFx0Y29uc3QgYXJnc19zdHIgPSBKU09OLnN0cmluZ2lmeShhcmdzKTtcclxuXHRcdGNvbnN0IHJldF9zdHJpbmcgPSB0aGlzLk1vZHVsZS5nZW5lcmF0ZV9rZXlfaW1hZ2UoYXJnc19zdHIpO1xyXG5cdFx0Y29uc3QgcmV0ID0gSlNPTi5wYXJzZShyZXRfc3RyaW5nKTtcclxuXHRcdGlmICh0eXBlb2YgcmV0LmVycl9tc2cgIT09ICd1bmRlZmluZWQnICYmIHJldC5lcnJfbXNnKSB7XHJcblx0XHRcdHJldHVybiB7IGVycl9tc2c6IHJldC5lcnJfbXNnIH07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmV0LnJldFZhbDtcclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlX2tleV9kZXJpdmF0aW9uKFxyXG5cdFx0cHViLFxyXG5cdFx0c2VjLFxyXG5cdCkge1xyXG5cdFx0Y29uc3QgYXJncyA9XHJcblx0XHR7XHJcblx0XHRcdHB1YjogcHViLFxyXG5cdFx0XHRzZWM6IHNlYyxcclxuXHRcdH07XHJcblx0XHRjb25zdCBhcmdzX3N0ciA9IEpTT04uc3RyaW5naWZ5KGFyZ3MpO1xyXG5cdFx0Y29uc3QgcmV0X3N0cmluZyA9IHRoaXMuTW9kdWxlLmdlbmVyYXRlX2tleV9kZXJpdmF0aW9uKGFyZ3Nfc3RyKTtcclxuXHRcdGNvbnN0IHJldCA9IEpTT04ucGFyc2UocmV0X3N0cmluZyk7XHJcblx0XHRpZiAodHlwZW9mIHJldC5lcnJfbXNnICE9PSAndW5kZWZpbmVkJyAmJiByZXQuZXJyX21zZykge1xyXG5cdFx0XHRyZXR1cm4geyBlcnJfbXNnOiByZXQuZXJyX21zZyB9O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJldC5yZXRWYWw7XHJcblx0fVxyXG5cdGRlcml2ZV9wdWJsaWNfa2V5KGRlcml2YXRpb24sIG91dF9pbmRleCwgcHViKVxyXG5cdHtcclxuXHRcdGNvbnN0IGFyZ3MgPVxyXG5cdFx0e1xyXG5cdFx0XHRwdWI6IHB1YixcclxuXHRcdFx0ZGVyaXZhdGlvbjogZGVyaXZhdGlvbiwgXHJcblx0XHRcdG91dF9pbmRleDogb3V0X2luZGV4LFxyXG5cdFx0fTtcclxuXHRcdGNvbnN0IGFyZ3Nfc3RyID0gSlNPTi5zdHJpbmdpZnkoYXJncyk7XHJcblx0XHRjb25zdCByZXRfc3RyaW5nID0gdGhpcy5Nb2R1bGUuZGVyaXZlX3B1YmxpY19rZXkoYXJnc19zdHIpO1xyXG5cdFx0Y29uc3QgcmV0ID0gSlNPTi5wYXJzZShyZXRfc3RyaW5nKTtcclxuXHRcdGlmICh0eXBlb2YgcmV0LmVycl9tc2cgIT09ICd1bmRlZmluZWQnICYmIHJldC5lcnJfbXNnKSB7XHJcblx0XHRcdHJldHVybiB7IGVycl9tc2c6IHJldC5lcnJfbXNnIH07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmV0LnJldFZhbDtcclxuXHR9XHJcblx0ZGVyaXZlX3N1YmFkZHJlc3NfcHVibGljX2tleShcclxuXHRcdG91dHB1dF9rZXksXHJcblx0XHRkZXJpdmF0aW9uLFxyXG5cdFx0b3V0X2luZGV4XHJcblx0KSB7XHJcblx0XHRjb25zdCBhcmdzID1cclxuXHRcdHtcclxuXHRcdFx0b3V0cHV0X2tleTogb3V0cHV0X2tleSxcclxuXHRcdFx0ZGVyaXZhdGlvbjogZGVyaXZhdGlvbixcclxuXHRcdFx0b3V0X2luZGV4OiBcIlwiICsgb3V0X2luZGV4LCAvLyBtdXN0IGJlIHBhc3NlZCBhcyBzdHJpbmdcclxuXHRcdH07XHJcblx0XHRjb25zdCBhcmdzX3N0ciA9IEpTT04uc3RyaW5naWZ5KGFyZ3MpO1xyXG5cdFx0Y29uc3QgcmV0X3N0cmluZyA9IHRoaXMuTW9kdWxlLmRlcml2ZV9zdWJhZGRyZXNzX3B1YmxpY19rZXkoYXJnc19zdHIpO1xyXG5cdFx0Y29uc3QgcmV0ID0gSlNPTi5wYXJzZShyZXRfc3RyaW5nKTtcclxuXHRcdGlmICh0eXBlb2YgcmV0LmVycl9tc2cgIT09ICd1bmRlZmluZWQnICYmIHJldC5lcnJfbXNnKSB7XHJcblx0XHRcdHJldHVybiB7IGVycl9tc2c6IHJldC5lcnJfbXNnIH07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmV0LnJldFZhbDtcdFx0XHJcblx0fVxyXG5cdGRlY29kZVJjdChydiwgc2ssIGkpXHJcblx0e1xyXG5cdFx0Y29uc3QgZWNkaEluZm8gPSBbXTsgLy8gc2hvdWxkIG9idnMgYmUgcGx1cmFsIGJ1dCBqdXN0IGtlZXBpbmcgZXhhY3QgbmFtZXMgaW4tdGFjdFxyXG5cdFx0Zm9yICh2YXIgaiA9IDAgOyBqIDwgcnYub3V0UGsubGVuZ3RoIDsgaisrKSB7XHJcblx0XHRcdHZhciB0aGlzX2VjZGhJbmZvID0gcnYuZWNkaEluZm9bal07XHJcbiAgXHRcdFx0ZWNkaEluZm8ucHVzaCh7XHJcblx0XHRcdFx0bWFzazogdGhpc19lY2RoSW5mby5tYXNrLFxyXG5cdFx0XHRcdGFtb3VudDogdGhpc19lY2RoSW5mby5hbW91bnRcclxuXHRcdFx0fSlcclxuXHRcdH1cclxuXHRcdGNvbnN0IG91dFBrID0gW107XHJcblx0XHRmb3IgKHZhciBqID0gMCA7IGogPCBydi5vdXRQay5sZW5ndGggOyBqKyspIHtcclxuXHRcdFx0dmFyIHRoaXNfb3V0UGtfbWFzayA9IG51bGw7XHJcblx0XHRcdHZhciB0aGlzX291dFBrID0gcnYub3V0UGtbal07XHJcblx0XHRcdGlmICh0eXBlb2YgdGhpc19vdXRQayA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0XHR0aGlzX291dFBrX21hc2sgPSB0aGlzX291dFBrO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB0aGlzX291dFBrID09PSBcIm9iamVjdFwiKSB7XHJcblx0XHRcdFx0dGhpc19vdXRQa19tYXNrID0gdGhpc19vdXRQay5tYXNrOyBcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGhpc19vdXRQa19tYXNrID09IG51bGwpIHtcclxuXHRcdFx0XHRyZXR1cm4geyBlcnJfbXNnOiBcIkNvdWxkbid0IGxvY2F0ZSBvdXRQayBtYXNrIHZhbHVlXCIgfVxyXG5cdFx0XHR9XHJcbiAgXHRcdFx0b3V0UGsucHVzaCh7XHJcblx0XHRcdFx0bWFzazogdGhpc19vdXRQa19tYXNrXHJcblx0XHRcdH0pXHJcblx0XHR9XHJcblx0XHRjb25zdCBhcmdzID1cclxuXHRcdHtcclxuXHRcdFx0aTogXCJcIiArIGksICAvLyBtdXN0IGJlIHBhc3NlZCBhcyBzdHJpbmdcclxuXHRcdFx0c2s6IHNrLFxyXG5cdFx0XHRydjoge1xyXG5cdFx0XHRcdHR5cGU6IFwiXCIgKyBydi50eXBlLyptdXN0IGJlIHN0cmluZyovLCAvLyBlLmcuIDEsIDMgLi4uIGNvcnJlc3BvbmRpbmcgdG8gcmN0OjpSQ1RUeXBlKiBpbiByY3RTaWdzLmNwcFxyXG5cdFx0XHRcdGVjZGhJbmZvOiBlY2RoSW5mbyxcclxuXHRcdFx0XHRvdXRQazogb3V0UGtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHRcdGNvbnN0IGFyZ3Nfc3RyID0gSlNPTi5zdHJpbmdpZnkoYXJncyk7XHJcblx0XHRjb25zdCByZXRfc3RyaW5nID0gdGhpcy5Nb2R1bGUuZGVjb2RlUmN0KGFyZ3Nfc3RyKTtcclxuXHRcdGNvbnN0IHJldCA9IEpTT04ucGFyc2UocmV0X3N0cmluZyk7XHJcblx0XHRpZiAodHlwZW9mIHJldC5lcnJfbXNnICE9PSAndW5kZWZpbmVkJyAmJiByZXQuZXJyX21zZykge1xyXG5cdFx0XHRyZXR1cm4geyBlcnJfbXNnOiByZXQuZXJyX21zZyB9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4geyAvLyBjYWxsaW5nIHRoZXNlIG91dCBzbyBhcyB0byBwcm92aWRlIGEgc3RhYmxlIHJldCB2YWwgaW50ZXJmYWNlXHJcblx0XHRcdGFtb3VudDogcmV0LmFtb3VudCwgLy8gc3RyaW5nXHJcblx0XHRcdG1hc2s6IHJldC5tYXNrLFxyXG5cdFx0fTtcclxuXHR9XHJcblx0ZXN0aW1hdGVkX3R4X25ldHdvcmtfZmVlKGZlZV9wZXJfa2JfX3N0cmluZywgcHJpb3JpdHksIG9wdGxfX2ZlZV9wZXJfYl9zdHJpbmcpIC8vIHRoaXMgaXMgdW50aWwgd2Ugc3dpdGNoIHRoZSBzZXJ2ZXIgb3ZlciB0byBmZWUgcGVyIGJcclxuXHR7IC8vIFRPRE8gdXBkYXRlIHRoaXMgQVBJIHRvIHRha2Ugb2JqZWN0IHJhdGhlciB0aGFuIGFyZyBsaXN0XHJcblx0XHRjb25zdCBhcmdzID1cclxuXHRcdHtcclxuXHRcdFx0ZmVlX3Blcl9iOiB0eXBlb2Ygb3B0bF9fZmVlX3Blcl9iX3N0cmluZyAhPT0gdW5kZWZpbmVkICYmIG9wdGxfX2ZlZV9wZXJfYl9zdHJpbmcgIT0gbnVsbCBcclxuXHRcdFx0XHQ/IG9wdGxfX2ZlZV9wZXJfYl9zdHJpbmcgXHJcblx0XHRcdFx0OiAobmV3IEpTQmlnSW50KGZlZV9wZXJfa2JfX3N0cmluZykpLmRpdmlkZSgxMDI0KS50b1N0cmluZygpLypraWIgLT4gYiovLCBcclxuXHRcdFx0cHJpb3JpdHk6IFwiXCIgKyBwcmlvcml0eSxcclxuXHRcdH07XHJcblx0XHRjb25zdCBhcmdzX3N0ciA9IEpTT04uc3RyaW5naWZ5KGFyZ3MpO1xyXG5cdFx0Y29uc3QgcmV0X3N0cmluZyA9IHRoaXMuTW9kdWxlLmVzdGltYXRlZF90eF9uZXR3b3JrX2ZlZShhcmdzX3N0cik7XHJcblx0XHRjb25zdCByZXQgPSBKU09OLnBhcnNlKHJldF9zdHJpbmcpO1xyXG5cdFx0aWYgKHR5cGVvZiByZXQuZXJyX21zZyAhPT0gJ3VuZGVmaW5lZCcgJiYgcmV0LmVycl9tc2cpIHtcclxuXHRcdFx0cmV0dXJuIHsgZXJyX21zZzogcmV0LmVycl9tc2cgfSAvLyBUT0RPOiBtYXliZSByZXR1cm4gdGhpcyBzb21laG93XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmV0LnJldFZhbDsgLy8gdGhpcyBpcyBhIHN0cmluZyAtIHBhc3MgaXQgdG8gbmV3IEpTQmlnSW50KOKApilcclxuXHR9XHJcblx0c2VuZF9zdGVwMV9fcHJlcGFyZV9wYXJhbXNfZm9yX2dldF9kZWNveXMoXHJcblx0XHRpc19zd2VlcGluZyxcclxuXHRcdHNlbmRpbmdfYW1vdW50LCAvLyB0aGlzIG1heSBiZSAwIGlmIHN3ZWVwaW5nXHJcblx0XHRmZWVfcGVyX2IsXHJcblx0XHRwcmlvcml0eSxcclxuXHRcdHVuc3BlbnRfb3V0cHV0cyxcclxuXHRcdG9wdGxfX3BheW1lbnRfaWRfc3RyaW5nLCAvLyB0aGlzIG1heSBiZSBuaWxcclxuXHRcdG9wdGxfX3Bhc3NlZEluX2F0dGVtcHRBdF9mZWVcclxuXHQpIHtcclxuXHRcdHZhciBzYW5pdGFyeV9fdW5zcGVudF9vdXRwdXRzID0gW107XHJcblx0XHRmb3IgKGxldCBpIGluIHVuc3BlbnRfb3V0cHV0cykge1xyXG5cdFx0XHRjb25zdCBzYW5pdGFyeV9fb3V0cHV0ID0gYnJpZGdlX3Nhbml0aXplZF9fc3BlbmRhYmxlX291dCh1bnNwZW50X291dHB1dHNbaV0pXHJcblx0XHRcdHNhbml0YXJ5X191bnNwZW50X291dHB1dHMucHVzaChzYW5pdGFyeV9fb3V0cHV0KTtcclxuXHRcdH1cclxuXHRcdGNvbnN0IGFyZ3MgPVxyXG5cdFx0e1xyXG5cdFx0XHRzZW5kaW5nX2Ftb3VudDogc2VuZGluZ19hbW91bnQudG9TdHJpbmcoKSxcclxuXHRcdFx0aXNfc3dlZXBpbmc6IFwiXCIgKyBpc19zd2VlcGluZywgLy8gYm9vbCAtPiBzdHJpbmdcclxuXHRcdFx0cHJpb3JpdHk6IFwiXCIgKyBwcmlvcml0eSxcclxuXHRcdFx0ZmVlX3Blcl9iOiBmZWVfcGVyX2IudG9TdHJpbmcoKSxcclxuXHRcdFx0dW5zcGVudF9vdXRzOiBzYW5pdGFyeV9fdW5zcGVudF9vdXRwdXRzIC8vIG91dHMsIG5vdCBvdXRwdXRzXHJcblx0XHR9O1xyXG5cdFx0aWYgKHR5cGVvZiBvcHRsX19wYXltZW50X2lkX3N0cmluZyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvcHRsX19wYXltZW50X2lkX3N0cmluZyAmJiBvcHRsX19wYXltZW50X2lkX3N0cmluZyAhPSBcIlwiKSB7XHJcblx0XHRcdGFyZ3MucGF5bWVudF9pZF9zdHJpbmcgPSBvcHRsX19wYXltZW50X2lkX3N0cmluZztcclxuXHRcdH1cclxuXHRcdGlmICh0eXBlb2Ygb3B0bF9fcGFzc2VkSW5fYXR0ZW1wdEF0X2ZlZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvcHRsX19wYXNzZWRJbl9hdHRlbXB0QXRfZmVlICYmIG9wdGxfX3Bhc3NlZEluX2F0dGVtcHRBdF9mZWUgIT0gXCJcIikge1xyXG5cdFx0XHRhcmdzLnBhc3NlZEluX2F0dGVtcHRBdF9mZWUgPSBvcHRsX19wYXNzZWRJbl9hdHRlbXB0QXRfZmVlLnRvU3RyaW5nKCk7IC8vIG91Z2h0IHRvIGJlIGEgc3RyaW5nIGJ1dCBpbiBjYXNlIGl0J3MgYSBKU0JpZ0ludOKAplxyXG5cdFx0fVxyXG5cdFx0Y29uc3QgYXJnc19zdHIgPSBKU09OLnN0cmluZ2lmeShhcmdzKTtcclxuXHRcdGNvbnN0IHJldF9zdHJpbmcgPSB0aGlzLk1vZHVsZS5zZW5kX3N0ZXAxX19wcmVwYXJlX3BhcmFtc19mb3JfZ2V0X2RlY295cyhhcmdzX3N0cik7XHJcblx0XHRjb25zdCByZXQgPSBKU09OLnBhcnNlKHJldF9zdHJpbmcpO1xyXG5cdFx0Ly8gc3BlY2lhbCBjYXNlOiBlcnJfY29kZSBvZiBuZWVkTW9yZU1vbmV5VGhhbkZvdW5kOyByZXdyaXRlIGVycl9tc2dcclxuXHRcdGlmIChyZXQuZXJyX2NvZGUgPT0gXCI5MFwiIHx8IHJldC5lcnJfY29kZSA9PSA5MCkgeyAvLyBkZWNsYXJlZCBpbiBteW1vbmVyby1jb3JlLWNwcC9zcmMvbW9uZXJvX3RyYW5zZmVyX3V0aWxzLmhwcFxyXG5cdFx0XHRyZXR1cm4geyBcclxuXHRcdFx0XHRyZXF1aXJlZF9iYWxhbmNlOiByZXQucmVxdWlyZWRfYmFsYW5jZSxcclxuXHRcdFx0XHRzcGVuZGFibGVfYmFsYW5jZTogcmV0LnNwZW5kYWJsZV9iYWxhbmNlLFxyXG5cdFx0XHRcdGVycl9tc2c6IGBTcGVuZGFibGUgYmFsYW5jZSB0b28gbG93LiBIYXZlICR7XHJcblx0XHRcdFx0XHRtb25lcm9fYW1vdW50X2Zvcm1hdF91dGlscy5mb3JtYXRNb25leShuZXcgSlNCaWdJbnQocmV0LnNwZW5kYWJsZV9iYWxhbmNlKSlcclxuXHRcdFx0XHR9ICR7bW9uZXJvX2NvbmZpZy5jb2luU3ltYm9sfTsgbmVlZCAke1xyXG5cdFx0XHRcdFx0bW9uZXJvX2Ftb3VudF9mb3JtYXRfdXRpbHMuZm9ybWF0TW9uZXkobmV3IEpTQmlnSW50KHJldC5yZXF1aXJlZF9iYWxhbmNlKSlcclxuXHRcdFx0XHR9ICR7bW9uZXJvX2NvbmZpZy5jb2luU3ltYm9sfS5gIFxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdFx0aWYgKHR5cGVvZiByZXQuZXJyX21zZyAhPT0gJ3VuZGVmaW5lZCcgJiYgcmV0LmVycl9tc2cpIHtcclxuXHRcdFx0cmV0dXJuIHsgZXJyX21zZzogcmV0LmVycl9tc2cgfTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB7IC8vIGNhbGxpbmcgdGhlc2Ugb3V0IHRvIHNldCBhbiBpbnRlcmZhY2VcclxuXHRcdFx0bWl4aW46IHBhcnNlSW50KHJldC5taXhpbiksIC8vIGZvciB0aGUgc2VydmVyIEFQSSByZXF1ZXN0IHRvIFJhbmRvbU91dHNcclxuXHRcdFx0dXNpbmdfZmVlOiByZXQudXNpbmdfZmVlLCAvLyBzdHJpbmc7IGNhbiBiZSBwYXNzZWQgdG8gc3RlcDJcclxuXHRcdFx0Y2hhbmdlX2Ftb3VudDogcmV0LmNoYW5nZV9hbW91bnQsIC8vIHN0cmluZyBmb3Igc3RlcDJcclxuXHRcdFx0dXNpbmdfb3V0czogcmV0LnVzaW5nX291dHMsIC8vIHRoaXMgY2FuIGJlIHBhc3NlZCBzdHJhaWdodCB0byBzdGVwMlxyXG5cdFx0XHRmaW5hbF90b3RhbF93b19mZWU6IHJldC5maW5hbF90b3RhbF93b19mZWUgLy8gYWthIHNlbmRpbmdfYW1vdW50IGZvciBzdGVwMlxyXG5cdFx0fTtcclxuXHR9XHJcblx0c2VuZF9zdGVwMl9fdHJ5X2NyZWF0ZV90cmFuc2FjdGlvbiggLy8gc2VuZCBvbmx5IElQQy1zYWZlIHZhbHMgLSBubyBKU0JpZ0ludHNcclxuXHRcdGZyb21fYWRkcmVzc19zdHJpbmcsXHJcblx0XHRzZWNfa2V5cyxcclxuXHRcdHRvX2FkZHJlc3Nfc3RyaW5nLFxyXG5cdFx0dXNpbmdfb3V0cyxcclxuXHRcdG1peF9vdXRzLFxyXG5cdFx0ZmFrZV9vdXRwdXRzX2NvdW50LFxyXG5cdFx0ZmluYWxfdG90YWxfd29fZmVlLFxyXG5cdFx0Y2hhbmdlX2Ftb3VudCxcclxuXHRcdGZlZV9hbW91bnQsXHJcblx0XHRwYXltZW50X2lkLFxyXG5cdFx0cHJpb3JpdHksXHJcblx0XHRmZWVfcGVyX2IsIC8vIG5vdCBraWIgLSBpZiBmZWVfcGVyX2tiLCAvPSAxMDI0XHJcblx0XHR1bmxvY2tfdGltZSxcclxuXHRcdG5ldHR5cGVcclxuXHQpIHtcclxuXHRcdHVubG9ja190aW1lID0gdW5sb2NrX3RpbWUgfHwgMDtcclxuXHRcdG1peF9vdXRzID0gbWl4X291dHMgfHwgW107XHJcblx0XHQvLyBOT1RFOiB3ZSBhbHNvIGRvIHRoaXMgY2hlY2sgaW4gdGhlIEMrKy4uLiBtYXkgYXMgd2VsbCByZW1vdmUgaXQgZnJvbSBoZXJlXHJcblx0XHRpZiAobWl4X291dHMubGVuZ3RoICE9PSB1c2luZ19vdXRzLmxlbmd0aCAmJiBmYWtlX291dHB1dHNfY291bnQgIT09IDApIHtcclxuXHRcdFx0cmV0dXJuIHsgXHJcblx0XHRcdFx0ZXJyX21zZzogXCJXcm9uZyBudW1iZXIgb2YgbWl4IG91dHMgcHJvdmlkZWQgKFwiICtcclxuXHRcdFx0XHRcdHVzaW5nX291dHMubGVuZ3RoICsgXCIgdXNpbmdfb3V0cywgXCIgK1xyXG5cdFx0XHRcdFx0bWl4X291dHMubGVuZ3RoICsgXCIgbWl4IG91dHMpXCJcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWl4X291dHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKChtaXhfb3V0c1tpXS5vdXRwdXRzIHx8IFtdKS5sZW5ndGggPCBmYWtlX291dHB1dHNfY291bnQpIHtcclxuXHRcdFx0XHRyZXR1cm4geyBlcnJfbXNnOiBcIk5vdCBlbm91Z2ggb3V0cHV0cyB0byBtaXggd2l0aFwiIH07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdC8vXHJcblx0XHQvLyBOb3cgd2UgbmVlZCB0byBjb252ZXJ0IGFsbCBub24tSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0cyBzdWNoIGFzIEpTQmlnSW50cyB0byBzdHJpbmdzIGV0YyAtIG5vdCB0aGF0IHRoZXJlIHNob3VsZCBiZSBhbnkhXHJcblx0XHQvLyAtIGFuZCBhbGwgbnVtYmVycyB0byBzdHJpbmdzIC0gZXNwZWNpYWxseSB0aG9zZSB3aGljaCBtYXkgYmUgdWludDY0X3Qgb24gdGhlIHJlY2VpdmluZyBzaWRlXHJcblx0XHR2YXIgc2FuaXRhcnlfX3VzaW5nX291dHMgPSBbXTtcclxuXHRcdGZvciAobGV0IGkgaW4gdXNpbmdfb3V0cykge1xyXG5cdFx0XHRjb25zdCBzYW5pdGFyeV9fb3V0cHV0ID0gYnJpZGdlX3Nhbml0aXplZF9fc3BlbmRhYmxlX291dCh1c2luZ19vdXRzW2ldKVxyXG5cdFx0XHRzYW5pdGFyeV9fdXNpbmdfb3V0cy5wdXNoKHNhbml0YXJ5X19vdXRwdXQpO1xyXG5cdFx0fVxyXG5cdFx0dmFyIHNhbml0YXJ5X19taXhfb3V0cyA9IFtdO1xyXG5cdFx0Zm9yIChsZXQgaSBpbiBtaXhfb3V0cykge1xyXG5cdFx0XHRjb25zdCBzYW5pdGFyeV9fbWl4X291dHNfYW5kX2Ftb3VudCA9XHJcblx0XHRcdHtcclxuXHRcdFx0XHRhbW91bnQ6IG1peF9vdXRzW2ldLmFtb3VudC50b1N0cmluZygpLCAvLyBpdCBzaG91bGQgYmUgYSBzdHJpbmcsIGJ1dCBpbiBjYXNlIGl0J3Mgbm90XHJcblx0XHRcdFx0b3V0cHV0czogW10gXHJcblx0XHRcdH07XHJcblx0XHRcdGlmIChtaXhfb3V0c1tpXS5vdXRwdXRzICYmIHR5cGVvZiBtaXhfb3V0c1tpXS5vdXRwdXRzICE9PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdGZvciAobGV0IGogaW4gbWl4X291dHNbaV0ub3V0cHV0cykge1xyXG5cdFx0XHRcdFx0Y29uc3Qgc2FuaXRhcnlfX21peF9vdXQgPVxyXG5cdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHRnbG9iYWxfaW5kZXg6IFwiXCIgKyBtaXhfb3V0c1tpXS5vdXRwdXRzW2pdLmdsb2JhbF9pbmRleCwgLy8gbnVtYmVyIHRvIHN0cmluZ1xyXG5cdFx0XHRcdFx0XHRwdWJsaWNfa2V5OiBtaXhfb3V0c1tpXS5vdXRwdXRzW2pdLnB1YmxpY19rZXlcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHRpZiAobWl4X291dHNbaV0ub3V0cHV0c1tqXS5yY3QgJiYgdHlwZW9mIG1peF9vdXRzW2ldLm91dHB1dHNbal0ucmN0ICE9PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdFx0XHRzYW5pdGFyeV9fbWl4X291dC5yY3QgPSBtaXhfb3V0c1tpXS5vdXRwdXRzW2pdLnJjdDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHNhbml0YXJ5X19taXhfb3V0c19hbmRfYW1vdW50Lm91dHB1dHMucHVzaChzYW5pdGFyeV9fbWl4X291dCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHNhbml0YXJ5X19taXhfb3V0cy5wdXNoKHNhbml0YXJ5X19taXhfb3V0c19hbmRfYW1vdW50KTtcclxuXHRcdH1cclxuXHRcdGNvbnN0IGFyZ3MgPVxyXG5cdFx0e1xyXG5cdFx0XHRmcm9tX2FkZHJlc3Nfc3RyaW5nOiBmcm9tX2FkZHJlc3Nfc3RyaW5nLFxyXG5cdFx0XHRzZWNfdmlld0tleV9zdHJpbmc6IHNlY19rZXlzLnZpZXcsXHJcblx0XHRcdHNlY19zcGVuZEtleV9zdHJpbmc6IHNlY19rZXlzLnNwZW5kLFxyXG5cdFx0XHR0b19hZGRyZXNzX3N0cmluZzogdG9fYWRkcmVzc19zdHJpbmcsXHJcblx0XHRcdGZpbmFsX3RvdGFsX3dvX2ZlZTogZmluYWxfdG90YWxfd29fZmVlLnRvU3RyaW5nKCksXHJcblx0XHRcdGNoYW5nZV9hbW91bnQ6IGNoYW5nZV9hbW91bnQudG9TdHJpbmcoKSxcclxuXHRcdFx0ZmVlX2Ftb3VudDogZmVlX2Ftb3VudC50b1N0cmluZygpLFxyXG5cdFx0XHRwcmlvcml0eTogXCJcIiArIHByaW9yaXR5LFxyXG5cdFx0XHRmZWVfcGVyX2I6IGZlZV9wZXJfYi50b1N0cmluZygpLFxyXG5cdFx0XHR1c2luZ19vdXRzOiBzYW5pdGFyeV9fdXNpbmdfb3V0cyxcclxuXHRcdFx0bWl4X291dHM6IHNhbml0YXJ5X19taXhfb3V0cyxcclxuXHRcdFx0dW5sb2NrX3RpbWU6IFwiXCIgKyB1bmxvY2tfdGltZSwgLy8gYnJpZGdlIGlzIGV4cGVjdGluZyBhIHN0cmluZ1xyXG5cdFx0XHRuZXR0eXBlX3N0cmluZzogbmV0dHlwZV91dGlscy5uZXR0eXBlX3RvX0FQSV9zdHJpbmcobmV0dHlwZSlcclxuXHRcdH07XHJcblx0XHRpZiAodHlwZW9mIHBheW1lbnRfaWQgIT09IFwidW5kZWZpbmVkXCIgJiYgcGF5bWVudF9pZCkge1xyXG5cdFx0XHRhcmdzLnBheW1lbnRfaWRfc3RyaW5nID0gcGF5bWVudF9pZDtcclxuXHRcdH1cclxuXHRcdGNvbnN0IGFyZ3Nfc3RyID0gSlNPTi5zdHJpbmdpZnkoYXJncyk7XHJcblx0XHRjb25zdCByZXRfc3RyaW5nID0gdGhpcy5Nb2R1bGUuc2VuZF9zdGVwMl9fdHJ5X2NyZWF0ZV90cmFuc2FjdGlvbihhcmdzX3N0cik7XHJcblx0XHRjb25zdCByZXQgPSBKU09OLnBhcnNlKHJldF9zdHJpbmcpO1xyXG5cdFx0Ly9cclxuXHRcdGlmICh0eXBlb2YgcmV0LmVycl9tc2cgIT09ICd1bmRlZmluZWQnICYmIHJldC5lcnJfbXNnKSB7XHJcblx0XHRcdHJldHVybiB7IGVycl9tc2c6IHJldC5lcnJfbXNnLCB0eF9tdXN0X2JlX3JlY29uc3RydWN0ZWQ6IGZhbHNlIH07XHJcblx0XHR9XHJcblx0XHRpZiAocmV0LnR4X211c3RfYmVfcmVjb25zdHJ1Y3RlZCA9PSBcInRydWVcIiB8fCByZXQudHhfbXVzdF9iZV9yZWNvbnN0cnVjdGVkID09IHRydWUpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiByZXQuZmVlX2FjdHVhbGx5X25lZWRlZCA9PSAndW5kZWZpbmVkJyB8fCAhcmV0LmZlZV9hY3R1YWxseV9uZWVkZWQpIHtcclxuXHRcdFx0XHR0aHJvdyBcInR4X211c3RfYmVfcmVjb25zdHJ1Y3RlZDsgZXhwZWN0ZWQgbm9uLW5pbCBmZWVfYWN0dWFsbHlfbmVlZGVkXCJcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHR4X211c3RfYmVfcmVjb25zdHJ1Y3RlZDogcmV0LnR4X211c3RfYmVfcmVjb25zdHJ1Y3RlZCwgLy8gaWYgdHJ1ZSwgcmUtZG8gcHJvY2VkdXJlIGZyb20gc3RlcDEgZXhjZXB0IGZvciByZXF1ZXN0aW5nIFVuc3BlbnRPdXRzICh0aGF0IGNhbiBiZSBkb25lIG9uY2V0KVxyXG5cdFx0XHRcdGZlZV9hY3R1YWxseV9uZWVkZWQ6IHJldC5mZWVfYWN0dWFsbHlfbmVlZGVkIC8vIGNhbiBiZSBwYXNzZWQgYmFjayB0byBzdGVwMVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4geyAvLyBjYWxsaW5nIHRoZXNlIG91dCB0byBzZXQgYW4gaW50ZXJmYWNlXHJcblx0XHRcdHR4X211c3RfYmVfcmVjb25zdHJ1Y3RlZDogZmFsc2UsIC8vIGluIGNhc2UgY2FsbGVyIGlzIG5vdCBjaGVja2luZyBmb3IgbmlsXHJcblx0XHRcdHNpZ25lZF9zZXJpYWxpemVkX3R4OiByZXQuc2VyaWFsaXplZF9zaWduZWRfdHgsIC8vIHRoaXMgbmFtZSBjaGFuZ2Ugc2hvdWxkIGJlIGZpeGVkIHRvIHNlcmlhbGl6ZWRfc2lnbmVkX3R4XHJcblx0XHRcdHR4X2hhc2g6IHJldC50eF9oYXNoLFxyXG5cdFx0XHR0eF9rZXk6IHJldC50eF9rZXlcclxuXHRcdH07XHJcblx0fVxyXG5cclxufVxyXG4vL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpXHJcbntcclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxyXG5cdC8vXHJcblx0Y29uc3QgRU5WSVJPTk1FTlRfSVNfV0VCID0gdHlwZW9mIHdpbmRvdz09PVwib2JqZWN0XCI7XHJcblx0Y29uc3QgRU5WSVJPTk1FTlRfSVNfV09SS0VSID0gdHlwZW9mIGltcG9ydFNjcmlwdHM9PT1cImZ1bmN0aW9uXCI7XHJcblx0Y29uc3QgRU5WSVJPTk1FTlRfSVNfTk9ERSA9IHR5cGVvZiBwcm9jZXNzPT09XCJvYmplY3RcIiAmJiBwcm9jZXNzLmJyb3dzZXIgIT09IHRydWUgJiYgdHlwZW9mIHJlcXVpcmU9PT1cImZ1bmN0aW9uXCIgJiYgRU5WSVJPTk1FTlRfSVNfV09SS0VSID09IGZhbHNlOyAvLyB3ZSB3YW50IHRoaXMgdG8gYmUgdHJ1ZSBmb3IgRWxlY3Ryb24gYnV0IG5vdCBmb3IgYSBXZWJWaWV3XHJcblx0Y29uc3QgRU5WSVJPTk1FTlRfSVNfU0hFTEwgPSAhRU5WSVJPTk1FTlRfSVNfV0VCICYmICFFTlZJUk9OTUVOVF9JU19OT0RFICYmICFFTlZJUk9OTUVOVF9JU19XT1JLRVI7XHJcblx0ZnVuY3Rpb24gbG9jYXRlRmlsZShmaWxlbmFtZSwgc2NyaXB0RGlyZWN0b3J5KVxyXG5cdHtcclxuXHRcdC8vIGlmIChvcHRpb25zW1wibG9jYXRlRmlsZVwiXSkge1xyXG5cdFx0Ly8gXHRyZXR1cm4gb3B0aW9uc1tcImxvY2F0ZUZpbGVcIl0oZmlsZW5hbWUsIHNjcmlwdERpcmVjdG9yeSlcclxuXHRcdC8vIH1cclxuXHRcdHZhciB0aGlzX3NjcmlwdERpcmVjdG9yeSA9IHNjcmlwdERpcmVjdG9yeVxyXG5cdFx0Y29uc3QgbGFzdENoYXIgPSB0aGlzX3NjcmlwdERpcmVjdG9yeS5jaGFyQXQodGhpc19zY3JpcHREaXJlY3RvcnkubGVuZ3RoIC0gMSlcclxuXHRcdGlmIChsYXN0Q2hhciA9PSBcIi9cIiB8fCBsYXN0Q2hhciA9PSBcIlxcXFxcIikgeyBcclxuXHRcdFx0Ly8gXi0tIHRoaXMgaXMgbm90IGEgJ1xcXFwnIG9uIFdpbmRvd3MgYmVjYXVzZSBlbXNjcmlwdGVuIGFjdHVhbGx5IGFwcGVuZHMgYSAnLydcclxuXHRcdFx0dGhpc19zY3JpcHREaXJlY3RvcnkgPSB0aGlzX3NjcmlwdERpcmVjdG9yeS5zdWJzdHJpbmcoMCwgdGhpc19zY3JpcHREaXJlY3RvcnkubGVuZ3RoIC0gMSkgLy8gcmVtb3ZlIHRyYWlsaW5nIFwiL1wiXHJcblx0XHR9XHJcblx0XHR2YXIgZnVsbFBhdGggPSBudWxsOyAvLyBhZGQgdHJhaWxpbmcgc2xhc2ggdG8gdGhpc1xyXG5cdFx0aWYgKEVOVklST05NRU5UX0lTX05PREUpIHtcclxuXHRcdFx0Y29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxyXG5cdFx0XHRjb25zdCBsYXN0UGF0aENvbXBvbmVudCA9IHBhdGguYmFzZW5hbWUodGhpc19zY3JpcHREaXJlY3RvcnkpXHJcblx0XHRcdGlmIChsYXN0UGF0aENvbXBvbmVudCA9PSBcIm1vbmVyb191dGlsc1wiKSB7IC8vIHR5cGljYWwgbm9kZSBvciBlbGVjdHJvbi1tYWluIHByb2Nlc3NcclxuXHRcdFx0XHRmdWxsUGF0aCA9IHBhdGguZm9ybWF0KHtcclxuXHRcdFx0XHRcdGRpcjogdGhpc19zY3JpcHREaXJlY3RvcnksXHJcblx0XHRcdFx0XHRiYXNlOiBmaWxlbmFtZVxyXG5cdFx0XHRcdH0pXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y29uc29sZS53YXJuKFwiTXlNb25lcm9Db3JlQnJpZGdlL2xvY2F0ZUZpbGUoKSBvbiBub2RlLmpzIGRpZG4ndCBmaW5kIFxcXCJtb25lcm9fdXRpbHNcXFwiIChvciBwb3NzaWJseSBNeU1vbmVyb0NvcmVCcmlkZ2UuanMpIGl0c2VsZiBpbiB0aGUgZXhwZWN0ZWQgbG9jYXRpb24gaW4gdGhlIGZvbGxvd2luZyBwYXRoLiBUaGUgZnVuY3Rpb24gbWF5IG5lZWQgdG8gYmUgZXhwYW5kZWQgYnV0IGl0IG1pZ2h0IGluIG5vcm1hbCBzaXR1YXRpb25zIGJlIGxpa2VseSB0byBiZSBhbm90aGVyIGJ1Zy5cIiAsICBwYXRoVG9fY3J5cHRvbm90ZVV0aWxzRGlyKVxyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKEVOVklST05NRU5UX0lTX1dFQikge1xyXG5cdFx0XHR2YXIgcGF0aFRvX2NyeXB0b25vdGVVdGlsc0RpcjtcclxuXHRcdFx0aWYgKHR5cGVvZiBfX2Rpcm5hbWUgIT09IHVuZGVmaW5lZCAmJiBfX2Rpcm5hbWUgIT09IFwiL1wiKSB7IC8vIGxvb2tzIGxpa2Ugbm9kZSBydW5uaW5nIGluIGJyb3dzZXIuLiAoYnV0IG5vdCBnb2luZyB0byBhc3N1bWUgaXQncyBlbGVjdHJvbi1yZW5kZXJlciBzaW5jZSB0aGF0IHNob3VsZCBiZSB0YWtlbiBjYXJlIG9mIGJ5IG1vbmVyb191dGlscy5qcyBpdHNlbGYpXHJcblx0XHRcdFx0Ly8gYnV0IGp1c3QgaW4gY2FzZSBpdCBpcy4uLiBoZXJlJ3MgYW4gYXR0ZW1wdCB0byBzdXBwb3J0IGl0XHJcblx0XHRcdFx0Ly8gaGF2ZSB0byBjaGVjayAhPSBcIi9cIiBiL2Mgd2VicGFjayAoSSB0aGluaykgcmVwbGFjZXMgX19kaXJuYW1lXHJcblx0XHRcdFx0cGF0aFRvX2NyeXB0b25vdGVVdGlsc0RpciA9IFwiZmlsZTovL1wiICsgX19kaXJuYW1lICsgXCIvXCIgLy8gcHJlcGVuZGluZyBcImZpbGU6Ly9cIiBiZWNhdXNlIGl0J3MgZ29pbmcgdG8gdHJ5IHRvIHN0cmVhbSBpdFxyXG5cdFx0XHR9IGVsc2UgeyAvLyBhY3R1YWwgd2ViIGJyb3dzZXJcclxuXHRcdFx0XHRwYXRoVG9fY3J5cHRvbm90ZVV0aWxzRGlyID0gdGhpc19zY3JpcHREaXJlY3RvcnkgKyBcIi9teW1vbmVyb19jb3JlX2pzL21vbmVyb191dGlscy9cIiAvLyB0aGlzIHdvcmtzIGZvciB0aGUgTXlNb25lcm8gYnJvd3NlciBidWlsZCwgYW5kIGlzIHF1aXRlIGdlbmVyYWwsIGF0IGxlYXN0XHJcblx0XHRcdH1cclxuXHRcdFx0ZnVsbFBhdGggPSBwYXRoVG9fY3J5cHRvbm90ZVV0aWxzRGlyICsgZmlsZW5hbWVcclxuXHRcdH1cclxuXHRcdGlmIChmdWxsUGF0aCA9PSBudWxsKSB7XHJcblx0XHRcdHRocm93IFwiVW5hYmxlIHRvIGRlcml2ZSBmdWxsUGF0aC4gUGxlYXNlIHBhc3MgbG9jYXRlRmlsZSgpIHRvIGNyeXB0b25vdGVfdXRpbHMgaW5pdC5cIlxyXG5cdFx0fVxyXG5cdFx0Ly9cclxuXHRcdHJldHVybiBmdWxsUGF0aFxyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcblx0XHR2YXIgTW9kdWxlX3RlbXBsYXRlID0ge31cclxuXHRcdGlmIChvcHRpb25zLmFzbWpzICE9IHRydWUgfHwgb3B0aW9ucy53YXNtID09IHRydWUpIHsgLy8gd2FzbVxyXG5cdFx0XHRNb2R1bGVfdGVtcGxhdGVbXCJsb2NhdGVGaWxlXCJdID0gbG9jYXRlRmlsZVxyXG5cdFx0XHQvL1xyXG5cdFx0XHQvLyBOT1RFOiBUaGlzIHJlcXVpcmVzIHNyYy9tb2R1bGUtcG9zdC5qcyB0byBiZSBpbmNsdWRlZCBhcyBwb3N0LWpzIGluIENNYWtlTGlzdHMudHh0IHVuZGVyIGEgd2FzbSBidWlsZFxyXG5cdFx0XHRyZXF1aXJlKFwiLi9NeU1vbmVyb0NvcmVDcHBfV0FTTVwiKShNb2R1bGVfdGVtcGxhdGUpLnJlYWR5LnRoZW4oZnVuY3Rpb24odGhpc01vZHVsZSkgXHJcblx0XHRcdHtcclxuXHRcdFx0XHRjb25zdCBpbnN0YW5jZSA9IG5ldyBNeU1vbmVyb0NvcmVCcmlkZ2UodGhpc01vZHVsZSk7XHJcblx0XHRcdFx0cmVzb2x2ZShpbnN0YW5jZSk7XHJcblx0XHRcdH0pLmNhdGNoKGZ1bmN0aW9uKGUpIHtcclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKFwiRXJyb3IgbG9hZGluZyBNeU1vbmVyb0NvcmVDcHBfV0FTTTpcIiwgZSk7XHJcblx0XHRcdFx0cmVqZWN0KGUpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7IC8vIHRoaXMgaXMgc3luY2hyb25vdXMgc28gd2UgY2FuIHJlc29sdmUgaW1tZWRpYXRlbHlcclxuXHRcdFx0dmFyIHNjcmlwdERpcmVjdG9yeT1cIlwiOyAvLyB0aGlzIHdhcyBleHRyYWN0ZWQgZnJvbSBlbXNjcmlwdGVuIC0gaXQgY291bGQgZ2V0IGZhY3RvcmVkIGlmIGFueXRoaW5nIGVsc2Ugd291bGQgZXZlciBuZWVkIGl0XHJcblx0XHRcdGlmIChFTlZJUk9OTUVOVF9JU19OT0RFKSB7XHJcblx0XHRcdFx0c2NyaXB0RGlyZWN0b3J5PV9fZGlybmFtZStcIi9cIjtcclxuXHRcdFx0fSBlbHNlIGlmIChFTlZJUk9OTUVOVF9JU19XRUIgfHwgRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XHJcblx0XHRcdFx0aWYgKEVOVklST05NRU5UX0lTX1dPUktFUikge1xyXG5cdFx0XHRcdFx0c2NyaXB0RGlyZWN0b3J5ID0gc2VsZi5sb2NhdGlvbi5ocmVmXHJcblx0XHRcdFx0fSBlbHNlIGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KSB7XHJcblx0XHRcdFx0XHRzY3JpcHREaXJlY3RvcnkgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyY1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgX3NjcmlwdERpciA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdCA/IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjIDogdW5kZWZpbmVkO1xyXG5cdFx0XHRcdGlmKF9zY3JpcHREaXIpe1xyXG5cdFx0XHRcdFx0c2NyaXB0RGlyZWN0b3J5ID0gX3NjcmlwdERpclxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoc2NyaXB0RGlyZWN0b3J5LmluZGV4T2YoXCJibG9iOlwiKSAhPT0gMCkge1xyXG5cdFx0XHRcdFx0c2NyaXB0RGlyZWN0b3J5ID0gc2NyaXB0RGlyZWN0b3J5LnN1YnN0cigwLHNjcmlwdERpcmVjdG9yeS5sYXN0SW5kZXhPZihcIi9cIikrMSlcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0c2NyaXB0RGlyZWN0b3J5ID0gXCJcIlxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgcmVhZF9mbjtcclxuXHRcdFx0aWYgKEVOVklST05NRU5UX0lTX05PREUpIHtcclxuXHRcdFx0XHRyZWFkX2ZuID0gZnVuY3Rpb24oZmlsZXBhdGgpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0cmV0dXJuIHJlcXVpcmUoXCJmc1wiKS5yZWFkRmlsZVN5bmMocmVxdWlyZShcInBhdGhcIikubm9ybWFsaXplKGZpbGVwYXRoKSkudG9TdHJpbmcoKVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdH0gZWxzZSBpZiAoRU5WSVJPTk1FTlRfSVNfV0VCfHxFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHtcclxuXHRcdFx0XHRyZWFkX2ZuID0gZnVuY3Rpb24odXJsKVxyXG5cdFx0XHRcdHsgLy8gaXQncyBhbiBvcHRpb24gdG8gbW92ZSB0aGlzIG92ZXIgdG8gZmV0Y2gsIGJ1dCwgZmV0Y2ggcmVxdWlyZXMgYSBwb2x5ZmlsbCBmb3IgdGhlc2Ugb2xkZXIgYnJvd3NlcnMgYW55d2F5IC0gbWFraW5nIGZldGNoIGFuIGF1dG9tYXRpYyBkZXAganVzdCBmb3IgYXNtanMgZmFsbGJhY2sgLSBhbmQgdGhlIGdpdGh1Yi9mZXRjaCBwb2x5ZmlsbCBkb2VzIG5vdCBhcHBlYXIgdG8gYWN0dWFsbHkgc3VwcG9ydCBtb2RlIChmb3IgJ3NhbWUtb3JpZ2luJyBwb2xpY3kpIGFueXdheSAtIHByb2JhYmx5IG5vdCB3b3J0aCBpdCB5ZXQgXHJcblx0XHRcdFx0XHR2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcclxuXHRcdFx0XHRcdHhoci5vcGVuKFwiR0VUXCIsIHVybCwgZmFsc2UpXHJcblx0XHRcdFx0XHR4aHIuc2VuZChudWxsKVxyXG5cdFx0XHRcdFx0Ly9cclxuXHRcdFx0XHRcdHJldHVybiB4aHIucmVzcG9uc2VUZXh0XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJvdyBcIlVuc3VwcG9ydGVkIGVudmlyb25tZW50IC0gcGxlYXNlIGltcGxlbWVudCBmaWxlIHJlYWRpbmcgZm9yIGFzbWpzIGZhbGxiYWNrIGNhc2VcIlxyXG5cdFx0XHR9XHJcblx0XHRcdGNvbnN0IGZpbGVwYXRoID0gbG9jYXRlRmlsZSgnTXlNb25lcm9Db3JlQ3BwX0FTTUpTLmFzbS5qcycsIHNjcmlwdERpcmVjdG9yeSlcclxuXHRcdFx0Y29uc3QgY29udGVudCA9IHJlYWRfZm4oZmlsZXBhdGgpXHJcblx0XHRcdC8vIFRPRE86IHZlcmlmeSBjb250ZW50IC0gZm9yIG5vdywgcmVseWluZyBvbiBzYW1lLW9yaWdpbiBhbmQgdGxzL3NzbFxyXG5cdFx0XHR2YXIgTW9kdWxlID0ge31cclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRldmFsKGNvbnRlbnQpIC8vIEkgZG8gbm90IGJlbGlldmUgdGhpcyBpcyBhIHNhZmV0eSBjb25jZXJuLCBiZWNhdXNlIGNvbnRlbnQgaXMgc2VydmVyLWNvbnRyb2xsZWQ7IGh0dHBzOi8vaHVtYW53aG9jb2Rlcy5jb20vYmxvZy8yMDEzLzA2LzI1L2V2YWwtaXNudC1ldmlsLWp1c3QtbWlzdW5kZXJzdG9vZC9cclxuXHRcdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRcdHJlamVjdChlKVxyXG5cdFx0XHRcdHJldHVyblxyXG5cdFx0XHR9XHJcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKVxyXG5cdFx0XHR7IC8vIFwiZGVsYXlpbmcgZXZlbiAxbXMgaXMgZW5vdWdoIHRvIGFsbG93IGNvbXBpbGF0aW9uIG1lbW9yeSB0byBiZSByZWNsYWltZWRcIlxyXG5cdFx0XHRcdE1vZHVsZV90ZW1wbGF0ZVsnYXNtJ10gPSBNb2R1bGVbJ2FzbSddXHJcblx0XHRcdFx0TW9kdWxlID0gbnVsbFxyXG5cdFx0XHRcdHJlc29sdmUobmV3IE15TW9uZXJvQ29yZUJyaWRnZShyZXF1aXJlKFwiLi9NeU1vbmVyb0NvcmVDcHBfQVNNSlNcIikoTW9kdWxlX3RlbXBsYXRlKSkpXHJcblx0XHRcdH0sIDEpIFxyXG5cdFx0fVxyXG5cdH0pO1xyXG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/MyMoneroCoreBridge.js\n");

/***/ }),

/***/ "./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/MyMoneroCoreCpp_WASM.wasm":
/*!****************************************************************************************************!*\
  !*** ./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/MyMoneroCoreCpp_WASM.wasm ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"775d8a3345fe4504d0afe8f9aefb07e8.wasm\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvbW9uZXJvX3V0aWxzL015TW9uZXJvQ29yZUNwcF9XQVNNLndhc20uanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvbW9uZXJvX3V0aWxzL015TW9uZXJvQ29yZUNwcF9XQVNNLndhc20/NzgyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCI3NzVkOGEzMzQ1ZmU0NTA0ZDBhZmU4ZjlhZWZiMDdlOC53YXNtXCI7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/MyMoneroCoreCpp_WASM.wasm\n");

/***/ }),

/***/ "./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/__bridged_fns_spec.js":
/*!************************************************************************************************!*\
  !*** ./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/__bridged_fns_spec.js ***!
  \************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("// Copyright (c) 2014-2018, MyMonero.com\r\n//\r\n// All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without modification, are\r\n// permitted provided that the following conditions are met:\r\n//\r\n// 1. Redistributions of source code must retain the above copyright notice, this list of\r\n//\tconditions and the following disclaimer.\r\n//\r\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list\r\n//\tof conditions and the following disclaimer in the documentation and/or other\r\n//\tmaterials provided with the distribution.\r\n//\r\n// 3. Neither the name of the copyright holder nor the names of its contributors may be\r\n//\tused to endorse or promote products derived from this software without specific\r\n//\tprior written permission.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\r\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\r\n// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\r\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n//\r\n// This file is here merely to share configuration\r\n//\r\nexports.bridgedFn_names =\r\n[\r\n\t\"is_subaddress\",\r\n\t\"is_integrated_address\",\r\n\t\"new_payment_id\",\r\n\t\"new__int_addr_from_addr_and_short_pid\",\r\n\t\"decode_address\",\r\n\t\"newly_created_wallet\",\r\n\t\"are_equal_mnemonics\",\r\n\t\"mnemonic_from_seed\",\r\n\t\"seed_and_keys_from_mnemonic\",\r\n\t\"validate_components_for_login\",\r\n\t\"address_and_keys_from_seed\",\r\n\t\"generate_key_image\",\r\n\t\"generate_key_derivation\",\r\n\t\"derive_public_key\",\r\n\t\"derive_subaddress_public_key\",\r\n\t\"decodeRct\",\r\n\t\"estimate_rct_tx_size\",\r\n\t\"calculate_fee\",\r\n\t\"estimated_tx_network_fee\",\r\n\t\"send_step1__prepare_params_for_get_decoys\",\r\n\t\"send_step2__try_create_transaction\"\r\n];\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvbW9uZXJvX3V0aWxzL19fYnJpZGdlZF9mbnNfc3BlYy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYnMvbXltb25lcm8tYXBwLWpzL2xvY2FsX21vZHVsZXMvbXltb25lcm9fY29yZV9qcy9tb25lcm9fdXRpbHMvX19icmlkZ2VkX2Zuc19zcGVjLmpzPzMxZjIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTgsIE15TW9uZXJvLmNvbVxyXG4vL1xyXG4vLyBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vL1xyXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmVcclxuLy8gcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbi8vXHJcbi8vIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mXHJcbi8vXHRjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbi8vXHJcbi8vIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0XHJcbi8vXHRvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyXHJcbi8vXHRtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4vL1xyXG4vLyAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBjb3B5cmlnaHQgaG9sZGVyIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmVcclxuLy9cdHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWNcclxuLy9cdHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuLy9cclxuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EIEFOWVxyXG4vLyBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcclxuLy8gTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTExcclxuLy8gVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXHJcbi8vIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcclxuLy8gUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXHJcbi8vIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxyXG4vLyBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcclxuLy8gVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4vL1xyXG4vLyBUaGlzIGZpbGUgaXMgaGVyZSBtZXJlbHkgdG8gc2hhcmUgY29uZmlndXJhdGlvblxyXG4vL1xyXG5leHBvcnRzLmJyaWRnZWRGbl9uYW1lcyA9XHJcbltcclxuXHRcImlzX3N1YmFkZHJlc3NcIixcclxuXHRcImlzX2ludGVncmF0ZWRfYWRkcmVzc1wiLFxyXG5cdFwibmV3X3BheW1lbnRfaWRcIixcclxuXHRcIm5ld19faW50X2FkZHJfZnJvbV9hZGRyX2FuZF9zaG9ydF9waWRcIixcclxuXHRcImRlY29kZV9hZGRyZXNzXCIsXHJcblx0XCJuZXdseV9jcmVhdGVkX3dhbGxldFwiLFxyXG5cdFwiYXJlX2VxdWFsX21uZW1vbmljc1wiLFxyXG5cdFwibW5lbW9uaWNfZnJvbV9zZWVkXCIsXHJcblx0XCJzZWVkX2FuZF9rZXlzX2Zyb21fbW5lbW9uaWNcIixcclxuXHRcInZhbGlkYXRlX2NvbXBvbmVudHNfZm9yX2xvZ2luXCIsXHJcblx0XCJhZGRyZXNzX2FuZF9rZXlzX2Zyb21fc2VlZFwiLFxyXG5cdFwiZ2VuZXJhdGVfa2V5X2ltYWdlXCIsXHJcblx0XCJnZW5lcmF0ZV9rZXlfZGVyaXZhdGlvblwiLFxyXG5cdFwiZGVyaXZlX3B1YmxpY19rZXlcIixcclxuXHRcImRlcml2ZV9zdWJhZGRyZXNzX3B1YmxpY19rZXlcIixcclxuXHRcImRlY29kZVJjdFwiLFxyXG5cdFwiZXN0aW1hdGVfcmN0X3R4X3NpemVcIixcclxuXHRcImNhbGN1bGF0ZV9mZWVcIixcclxuXHRcImVzdGltYXRlZF90eF9uZXR3b3JrX2ZlZVwiLFxyXG5cdFwic2VuZF9zdGVwMV9fcHJlcGFyZV9wYXJhbXNfZm9yX2dldF9kZWNveXNcIixcclxuXHRcInNlbmRfc3RlcDJfX3RyeV9jcmVhdGVfdHJhbnNhY3Rpb25cIlxyXG5dO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/__bridged_fns_spec.js\n");

/***/ }),

/***/ "./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_amount_format_utils.js":
/*!********************************************************************************************************!*\
  !*** ./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_amount_format_utils.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2014-2018, MyMonero.com\r\n//\r\n// All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without modification, are\r\n// permitted provided that the following conditions are met:\r\n//\r\n// 1. Redistributions of source code must retain the above copyright notice, this list of\r\n//\tconditions and the following disclaimer.\r\n//\r\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list\r\n//\tof conditions and the following disclaimer in the documentation and/or other\r\n//\tmaterials provided with the distribution.\r\n//\r\n// 3. Neither the name of the copyright holder nor the names of its contributors may be\r\n//\tused to endorse or promote products derived from this software without specific\r\n//\tprior written permission.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\r\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\r\n// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\r\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n//\r\n\r\n//\r\nconst monero_config = __webpack_require__(/*! ./monero_config */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_config.js\")\r\nconst money_format_utils = __webpack_require__(/*! ../cryptonote_utils/money_format_utils */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/money_format_utils.js\")\r\nconst instance = money_format_utils(monero_config)\r\n//\r\nmodule.exports = instance;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvbW9uZXJvX3V0aWxzL21vbmVyb19hbW91bnRfZm9ybWF0X3V0aWxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGlicy9teW1vbmVyby1hcHAtanMvbG9jYWxfbW9kdWxlcy9teW1vbmVyb19jb3JlX2pzL21vbmVyb191dGlscy9tb25lcm9fYW1vdW50X2Zvcm1hdF91dGlscy5qcz83YmNkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNC0yMDE4LCBNeU1vbmVyby5jb21cclxuLy9cclxuLy8gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy9cclxuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlXHJcbi8vIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4vL1xyXG4vLyAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZlxyXG4vL1x0Y29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4vL1xyXG4vLyAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdFxyXG4vL1x0b2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlclxyXG4vL1x0bWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuLy9cclxuLy8gMy4gTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgY29weXJpZ2h0IGhvbGRlciBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlXHJcbi8vXHR1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljXHJcbi8vXHRwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcbi8vXHJcbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORCBBTllcclxuLy8gRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GXHJcbi8vIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMXHJcbi8vIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxyXG4vLyBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXHJcbi8vIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xyXG4vLyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCxcclxuLy8gU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXHJcbi8vIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuLy9cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8vXHJcbmNvbnN0IG1vbmVyb19jb25maWcgPSByZXF1aXJlKFwiLi9tb25lcm9fY29uZmlnXCIpXHJcbmNvbnN0IG1vbmV5X2Zvcm1hdF91dGlscyA9IHJlcXVpcmUoXCIuLi9jcnlwdG9ub3RlX3V0aWxzL21vbmV5X2Zvcm1hdF91dGlsc1wiKVxyXG5jb25zdCBpbnN0YW5jZSA9IG1vbmV5X2Zvcm1hdF91dGlscyhtb25lcm9fY29uZmlnKVxyXG4vL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGluc3RhbmNlOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_amount_format_utils.js\n");

/***/ }),

/***/ "./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_config.js":
/*!*******************************************************************************************!*\
  !*** ./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_config.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2014-2018, MyMonero.com\r\n//\r\n// All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without modification, are\r\n// permitted provided that the following conditions are met:\r\n//\r\n// 1. Redistributions of source code must retain the above copyright notice, this list of\r\n//\tconditions and the following disclaimer.\r\n//\r\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list\r\n//\tof conditions and the following disclaimer in the documentation and/or other\r\n//\tmaterials provided with the distribution.\r\n//\r\n// 3. Neither the name of the copyright holder nor the names of its contributors may be\r\n//\tused to endorse or promote products derived from this software without specific\r\n//\tprior written permission.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\r\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\r\n// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\r\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n//\r\n\r\n//\r\nconst JSBigInt = __webpack_require__(/*! ../cryptonote_utils/biginteger */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/biginteger.js\").BigInteger;\r\n//\r\nmodule.exports = {\r\n\t// Number of atomic units in one unit of currency. e.g. 12 => 10^12 = 1000000000000\r\n\tcoinUnitPlaces: 12,\r\n\r\n\t// Minimum number of confirmations for a transaction to show as confirmed\r\n\ttxMinConfirms: 10,\r\n\r\n\t// Currency symbol\r\n\tcoinSymbol: \"XMR\",\r\n\r\n\t// OpenAlias prefix\r\n\topenAliasPrefix: \"xmr\",\r\n\r\n\t// Currency name\r\n\tcoinName: \"Monero\",\r\n\r\n\t// Payment URI Prefix\r\n\tcoinUriPrefix: \"monero:\",\r\n\r\n\t// Dust threshold in atomic units\r\n\t// 2*10^9 used for choosing outputs/change - we decompose all the way down if the receiver wants now regardless of threshold\r\n\tdustThreshold: new JSBigInt(\"2000000000\"),\r\n\r\n\t// Maximum block number, used for tx unlock time\r\n\tmaxBlockNumber: 500000000,\r\n\r\n\t// Average block time in seconds, used for unlock time estimation\r\n\tavgBlockTime: 60,\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvbW9uZXJvX3V0aWxzL21vbmVyb19jb25maWcuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvbW9uZXJvX3V0aWxzL21vbmVyb19jb25maWcuanM/OWJjZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxOCwgTXlNb25lcm8uY29tXHJcbi8vXHJcbi8vIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vXHJcbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZVxyXG4vLyBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuLy9cclxuLy8gMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2ZcclxuLy9cdGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuLy9cclxuLy8gMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3RcclxuLy9cdG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXJcclxuLy9cdG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbi8vXHJcbi8vIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGNvcHlyaWdodCBob2xkZXIgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZVxyXG4vL1x0dXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xyXG4vL1x0cHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4vL1xyXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkQgQU5ZXHJcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRlxyXG4vLyBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTFxyXG4vLyBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcclxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxyXG4vLyBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcclxuLy8gSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsXHJcbi8vIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxyXG4vLyBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbi8vXHJcblwidXNlIHN0cmljdFwiO1xyXG4vL1xyXG5jb25zdCBKU0JpZ0ludCA9IHJlcXVpcmUoXCIuLi9jcnlwdG9ub3RlX3V0aWxzL2JpZ2ludGVnZXJcIikuQmlnSW50ZWdlcjtcclxuLy9cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0Ly8gTnVtYmVyIG9mIGF0b21pYyB1bml0cyBpbiBvbmUgdW5pdCBvZiBjdXJyZW5jeS4gZS5nLiAxMiA9PiAxMF4xMiA9IDEwMDAwMDAwMDAwMDBcclxuXHRjb2luVW5pdFBsYWNlczogMTIsXHJcblxyXG5cdC8vIE1pbmltdW0gbnVtYmVyIG9mIGNvbmZpcm1hdGlvbnMgZm9yIGEgdHJhbnNhY3Rpb24gdG8gc2hvdyBhcyBjb25maXJtZWRcclxuXHR0eE1pbkNvbmZpcm1zOiAxMCxcclxuXHJcblx0Ly8gQ3VycmVuY3kgc3ltYm9sXHJcblx0Y29pblN5bWJvbDogXCJYTVJcIixcclxuXHJcblx0Ly8gT3BlbkFsaWFzIHByZWZpeFxyXG5cdG9wZW5BbGlhc1ByZWZpeDogXCJ4bXJcIixcclxuXHJcblx0Ly8gQ3VycmVuY3kgbmFtZVxyXG5cdGNvaW5OYW1lOiBcIk1vbmVyb1wiLFxyXG5cclxuXHQvLyBQYXltZW50IFVSSSBQcmVmaXhcclxuXHRjb2luVXJpUHJlZml4OiBcIm1vbmVybzpcIixcclxuXHJcblx0Ly8gRHVzdCB0aHJlc2hvbGQgaW4gYXRvbWljIHVuaXRzXHJcblx0Ly8gMioxMF45IHVzZWQgZm9yIGNob29zaW5nIG91dHB1dHMvY2hhbmdlIC0gd2UgZGVjb21wb3NlIGFsbCB0aGUgd2F5IGRvd24gaWYgdGhlIHJlY2VpdmVyIHdhbnRzIG5vdyByZWdhcmRsZXNzIG9mIHRocmVzaG9sZFxyXG5cdGR1c3RUaHJlc2hvbGQ6IG5ldyBKU0JpZ0ludChcIjIwMDAwMDAwMDBcIiksXHJcblxyXG5cdC8vIE1heGltdW0gYmxvY2sgbnVtYmVyLCB1c2VkIGZvciB0eCB1bmxvY2sgdGltZVxyXG5cdG1heEJsb2NrTnVtYmVyOiA1MDAwMDAwMDAsXHJcblxyXG5cdC8vIEF2ZXJhZ2UgYmxvY2sgdGltZSBpbiBzZWNvbmRzLCB1c2VkIGZvciB1bmxvY2sgdGltZSBlc3RpbWF0aW9uXHJcblx0YXZnQmxvY2tUaW1lOiA2MCxcclxufTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_config.js\n");

/***/ }),

/***/ "./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_keyImage_cache_utils.js":
/*!*********************************************************************************************************!*\
  !*** ./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_keyImage_cache_utils.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2014-2018, MyMonero.com\r\n//\r\n// All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without modification, are\r\n// permitted provided that the following conditions are met:\r\n//\r\n// 1. Redistributions of source code must retain the above copyright notice, this list of\r\n//\tconditions and the following disclaimer.\r\n//\r\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list\r\n//\tof conditions and the following disclaimer in the documentation and/or other\r\n//\tmaterials provided with the distribution.\r\n//\r\n// 3. Neither the name of the copyright holder nor the names of its contributors may be\r\n//\tused to endorse or promote products derived from this software without specific\r\n//\tprior written permission.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\r\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\r\n// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\r\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n//\r\n\r\n//\r\nconst Lazy_KeyImage = function(\r\n\tmutable_keyImagesByCacheKey, // pass a mutable JS dictionary\r\n\ttx_pub_key,\r\n\tout_index,\r\n\tpublic_address,\r\n\tview_key__private,\r\n\tspend_key__public,\r\n\tspend_key__private,\r\n\tmonero_utils // must pass this so this fn can remain synchronous\r\n) {\r\n\tvar cache_index = tx_pub_key + \":\" + public_address + \":\" + out_index;\r\n\tconst cached__key_image = mutable_keyImagesByCacheKey[cache_index];\r\n\tif (\r\n\t\ttypeof cached__key_image !== \"undefined\" &&\r\n\t\tcached__key_image !== null\r\n\t) {\r\n\t\treturn cached__key_image;\r\n\t}\r\n\tvar key_image = monero_utils.generate_key_image(\r\n\t\ttx_pub_key,\r\n\t\tview_key__private,\r\n\t\tspend_key__public,\r\n\t\tspend_key__private,\r\n\t\tout_index,\r\n\t);\r\n\t// cache:\r\n\tmutable_keyImagesByCacheKey[cache_index] = key_image;\r\n\t//\r\n\treturn key_image;\r\n};\r\nexports.Lazy_KeyImage = Lazy_KeyImage;\r\n//\r\n//\r\n// Managed caches - Can be used by apps which can't send a mutable_keyImagesByCacheKey\r\nconst __global_managed_keyImageCaches_by_walletId = {};\r\nfunction _managedKeyImageCacheWalletIdForWalletWith(public_address) {\r\n\t// NOTE: making the assumption that public_address is unique enough to identify a wallet for caching....\r\n\t// FIXME: with subaddresses, is that still the case? would we need to split them up by subaddr anyway?\r\n\tif (\r\n\t\tpublic_address == \"\" ||\r\n\t\t!public_address ||\r\n\t\ttypeof public_address == \"undefined\"\r\n\t) {\r\n\t\tthrow \"managedKeyImageCacheIdentifierForWalletWith: Illegal public_address\";\r\n\t}\r\n\treturn \"\" + public_address;\r\n}\r\nconst Lazy_KeyImageCacheForWalletWith = function(public_address) {\r\n\tvar cacheId = _managedKeyImageCacheWalletIdForWalletWith(public_address);\r\n\tvar cache = __global_managed_keyImageCaches_by_walletId[cacheId];\r\n\tif (typeof cache === \"undefined\" || !cache) {\r\n\t\tcache = {};\r\n\t\t__global_managed_keyImageCaches_by_walletId[cacheId] = cache;\r\n\t}\r\n\treturn cache;\r\n};\r\nexports.Lazy_KeyImageCacheForWalletWith = Lazy_KeyImageCacheForWalletWith;\r\n//\r\nconst DeleteManagedKeyImagesForWalletWith = function(public_address) {\r\n\t// IMPORTANT: Ensure you call this method when you want to clear your wallet from\r\n\t// memory or delete it, or else you could leak key images and public addresses.\r\n\tconst cacheId = _managedKeyImageCacheWalletIdForWalletWith(public_address);\r\n\tdelete __global_managed_keyImageCaches_by_walletId[cacheId];\r\n\t//\r\n\tconst cache = __global_managed_keyImageCaches_by_walletId[cacheId];\r\n\tif (typeof cache !== \"undefined\") {\r\n\t\tthrow \"Key image cache still exists after deletion\";\r\n\t}\r\n};\r\nexports.DeleteManagedKeyImagesForWalletWith = DeleteManagedKeyImagesForWalletWith;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvbW9uZXJvX3V0aWxzL21vbmVyb19rZXlJbWFnZV9jYWNoZV91dGlscy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYnMvbXltb25lcm8tYXBwLWpzL2xvY2FsX21vZHVsZXMvbXltb25lcm9fY29yZV9qcy9tb25lcm9fdXRpbHMvbW9uZXJvX2tleUltYWdlX2NhY2hlX3V0aWxzLmpzPzA2YzIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTgsIE15TW9uZXJvLmNvbVxyXG4vL1xyXG4vLyBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vL1xyXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmVcclxuLy8gcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbi8vXHJcbi8vIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mXHJcbi8vXHRjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbi8vXHJcbi8vIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0XHJcbi8vXHRvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyXHJcbi8vXHRtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4vL1xyXG4vLyAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBjb3B5cmlnaHQgaG9sZGVyIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmVcclxuLy9cdHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWNcclxuLy9cdHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuLy9cclxuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EIEFOWVxyXG4vLyBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcclxuLy8gTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTExcclxuLy8gVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXHJcbi8vIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcclxuLy8gUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXHJcbi8vIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxyXG4vLyBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcclxuLy8gVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4vL1xyXG5cInVzZSBzdHJpY3RcIjtcclxuLy9cclxuY29uc3QgTGF6eV9LZXlJbWFnZSA9IGZ1bmN0aW9uKFxyXG5cdG11dGFibGVfa2V5SW1hZ2VzQnlDYWNoZUtleSwgLy8gcGFzcyBhIG11dGFibGUgSlMgZGljdGlvbmFyeVxyXG5cdHR4X3B1Yl9rZXksXHJcblx0b3V0X2luZGV4LFxyXG5cdHB1YmxpY19hZGRyZXNzLFxyXG5cdHZpZXdfa2V5X19wcml2YXRlLFxyXG5cdHNwZW5kX2tleV9fcHVibGljLFxyXG5cdHNwZW5kX2tleV9fcHJpdmF0ZSxcclxuXHRtb25lcm9fdXRpbHMgLy8gbXVzdCBwYXNzIHRoaXMgc28gdGhpcyBmbiBjYW4gcmVtYWluIHN5bmNocm9ub3VzXHJcbikge1xyXG5cdHZhciBjYWNoZV9pbmRleCA9IHR4X3B1Yl9rZXkgKyBcIjpcIiArIHB1YmxpY19hZGRyZXNzICsgXCI6XCIgKyBvdXRfaW5kZXg7XHJcblx0Y29uc3QgY2FjaGVkX19rZXlfaW1hZ2UgPSBtdXRhYmxlX2tleUltYWdlc0J5Q2FjaGVLZXlbY2FjaGVfaW5kZXhdO1xyXG5cdGlmIChcclxuXHRcdHR5cGVvZiBjYWNoZWRfX2tleV9pbWFnZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxyXG5cdFx0Y2FjaGVkX19rZXlfaW1hZ2UgIT09IG51bGxcclxuXHQpIHtcclxuXHRcdHJldHVybiBjYWNoZWRfX2tleV9pbWFnZTtcclxuXHR9XHJcblx0dmFyIGtleV9pbWFnZSA9IG1vbmVyb191dGlscy5nZW5lcmF0ZV9rZXlfaW1hZ2UoXHJcblx0XHR0eF9wdWJfa2V5LFxyXG5cdFx0dmlld19rZXlfX3ByaXZhdGUsXHJcblx0XHRzcGVuZF9rZXlfX3B1YmxpYyxcclxuXHRcdHNwZW5kX2tleV9fcHJpdmF0ZSxcclxuXHRcdG91dF9pbmRleCxcclxuXHQpO1xyXG5cdC8vIGNhY2hlOlxyXG5cdG11dGFibGVfa2V5SW1hZ2VzQnlDYWNoZUtleVtjYWNoZV9pbmRleF0gPSBrZXlfaW1hZ2U7XHJcblx0Ly9cclxuXHRyZXR1cm4ga2V5X2ltYWdlO1xyXG59O1xyXG5leHBvcnRzLkxhenlfS2V5SW1hZ2UgPSBMYXp5X0tleUltYWdlO1xyXG4vL1xyXG4vL1xyXG4vLyBNYW5hZ2VkIGNhY2hlcyAtIENhbiBiZSB1c2VkIGJ5IGFwcHMgd2hpY2ggY2FuJ3Qgc2VuZCBhIG11dGFibGVfa2V5SW1hZ2VzQnlDYWNoZUtleVxyXG5jb25zdCBfX2dsb2JhbF9tYW5hZ2VkX2tleUltYWdlQ2FjaGVzX2J5X3dhbGxldElkID0ge307XHJcbmZ1bmN0aW9uIF9tYW5hZ2VkS2V5SW1hZ2VDYWNoZVdhbGxldElkRm9yV2FsbGV0V2l0aChwdWJsaWNfYWRkcmVzcykge1xyXG5cdC8vIE5PVEU6IG1ha2luZyB0aGUgYXNzdW1wdGlvbiB0aGF0IHB1YmxpY19hZGRyZXNzIGlzIHVuaXF1ZSBlbm91Z2ggdG8gaWRlbnRpZnkgYSB3YWxsZXQgZm9yIGNhY2hpbmcuLi4uXHJcblx0Ly8gRklYTUU6IHdpdGggc3ViYWRkcmVzc2VzLCBpcyB0aGF0IHN0aWxsIHRoZSBjYXNlPyB3b3VsZCB3ZSBuZWVkIHRvIHNwbGl0IHRoZW0gdXAgYnkgc3ViYWRkciBhbnl3YXk/XHJcblx0aWYgKFxyXG5cdFx0cHVibGljX2FkZHJlc3MgPT0gXCJcIiB8fFxyXG5cdFx0IXB1YmxpY19hZGRyZXNzIHx8XHJcblx0XHR0eXBlb2YgcHVibGljX2FkZHJlc3MgPT0gXCJ1bmRlZmluZWRcIlxyXG5cdCkge1xyXG5cdFx0dGhyb3cgXCJtYW5hZ2VkS2V5SW1hZ2VDYWNoZUlkZW50aWZpZXJGb3JXYWxsZXRXaXRoOiBJbGxlZ2FsIHB1YmxpY19hZGRyZXNzXCI7XHJcblx0fVxyXG5cdHJldHVybiBcIlwiICsgcHVibGljX2FkZHJlc3M7XHJcbn1cclxuY29uc3QgTGF6eV9LZXlJbWFnZUNhY2hlRm9yV2FsbGV0V2l0aCA9IGZ1bmN0aW9uKHB1YmxpY19hZGRyZXNzKSB7XHJcblx0dmFyIGNhY2hlSWQgPSBfbWFuYWdlZEtleUltYWdlQ2FjaGVXYWxsZXRJZEZvcldhbGxldFdpdGgocHVibGljX2FkZHJlc3MpO1xyXG5cdHZhciBjYWNoZSA9IF9fZ2xvYmFsX21hbmFnZWRfa2V5SW1hZ2VDYWNoZXNfYnlfd2FsbGV0SWRbY2FjaGVJZF07XHJcblx0aWYgKHR5cGVvZiBjYWNoZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY2FjaGUpIHtcclxuXHRcdGNhY2hlID0ge307XHJcblx0XHRfX2dsb2JhbF9tYW5hZ2VkX2tleUltYWdlQ2FjaGVzX2J5X3dhbGxldElkW2NhY2hlSWRdID0gY2FjaGU7XHJcblx0fVxyXG5cdHJldHVybiBjYWNoZTtcclxufTtcclxuZXhwb3J0cy5MYXp5X0tleUltYWdlQ2FjaGVGb3JXYWxsZXRXaXRoID0gTGF6eV9LZXlJbWFnZUNhY2hlRm9yV2FsbGV0V2l0aDtcclxuLy9cclxuY29uc3QgRGVsZXRlTWFuYWdlZEtleUltYWdlc0ZvcldhbGxldFdpdGggPSBmdW5jdGlvbihwdWJsaWNfYWRkcmVzcykge1xyXG5cdC8vIElNUE9SVEFOVDogRW5zdXJlIHlvdSBjYWxsIHRoaXMgbWV0aG9kIHdoZW4geW91IHdhbnQgdG8gY2xlYXIgeW91ciB3YWxsZXQgZnJvbVxyXG5cdC8vIG1lbW9yeSBvciBkZWxldGUgaXQsIG9yIGVsc2UgeW91IGNvdWxkIGxlYWsga2V5IGltYWdlcyBhbmQgcHVibGljIGFkZHJlc3Nlcy5cclxuXHRjb25zdCBjYWNoZUlkID0gX21hbmFnZWRLZXlJbWFnZUNhY2hlV2FsbGV0SWRGb3JXYWxsZXRXaXRoKHB1YmxpY19hZGRyZXNzKTtcclxuXHRkZWxldGUgX19nbG9iYWxfbWFuYWdlZF9rZXlJbWFnZUNhY2hlc19ieV93YWxsZXRJZFtjYWNoZUlkXTtcclxuXHQvL1xyXG5cdGNvbnN0IGNhY2hlID0gX19nbG9iYWxfbWFuYWdlZF9rZXlJbWFnZUNhY2hlc19ieV93YWxsZXRJZFtjYWNoZUlkXTtcclxuXHRpZiAodHlwZW9mIGNhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHR0aHJvdyBcIktleSBpbWFnZSBjYWNoZSBzdGlsbCBleGlzdHMgYWZ0ZXIgZGVsZXRpb25cIjtcclxuXHR9XHJcbn07XHJcbmV4cG9ydHMuRGVsZXRlTWFuYWdlZEtleUltYWdlc0ZvcldhbGxldFdpdGggPSBEZWxldGVNYW5hZ2VkS2V5SW1hZ2VzRm9yV2FsbGV0V2l0aDtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_keyImage_cache_utils.js\n");

/***/ }),

/***/ "./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_paymentID_utils.js":
/*!****************************************************************************************************!*\
  !*** ./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_paymentID_utils.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2014-2018, MyMonero.com\r\n//\r\n// All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without modification, are\r\n// permitted provided that the following conditions are met:\r\n//\r\n// 1. Redistributions of source code must retain the above copyright notice, this list of\r\n//\tconditions and the following disclaimer.\r\n//\r\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list\r\n//\tof conditions and the following disclaimer in the documentation and/or other\r\n//\tmaterials provided with the distribution.\r\n//\r\n// 3. Neither the name of the copyright holder nor the names of its contributors may be\r\n//\tused to endorse or promote products derived from this software without specific\r\n//\tprior written permission.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\r\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\r\n// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\r\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n//\r\n\r\n//\r\nfunction IsValidPaymentIDOrNoPaymentID(payment_id__orNil) {\r\n\tif (\r\n\t\tpayment_id__orNil == null ||\r\n\t\tpayment_id__orNil == \"\" ||\r\n\t\ttypeof payment_id__orNil == \"undefined\"\r\n\t) {\r\n\t\treturn true; // no pid\r\n\t}\r\n\tlet payment_id = payment_id__orNil;\r\n\tif (IsValidShortPaymentID(payment_id)) {\r\n\t\treturn true;\r\n\t}\r\n\tif (IsValidLongPaymentID(payment_id)) {\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\nexports.IsValidPaymentIDOrNoPaymentID = IsValidPaymentIDOrNoPaymentID;\r\n//\r\nfunction IsValidShortPaymentID(payment_id) {\r\n\treturn IsValidPaymentIDOfLength(payment_id, 16);\r\n}\r\nexports.IsValidShortPaymentID = IsValidShortPaymentID;\r\n//\r\nfunction IsValidLongPaymentID(payment_id) {\r\n\treturn IsValidPaymentIDOfLength(payment_id, 64);\r\n}\r\nexports.IsValidLongPaymentID = IsValidLongPaymentID;\r\n//\r\nfunction IsValidPaymentIDOfLength(payment_id, required_length) {\r\n\tif (required_length != 16 && required_length != 64) {\r\n\t\tthrow \"unexpected IsValidPaymentIDOfLength required_length\";\r\n\t}\r\n\tlet payment_id_length = payment_id.length;\r\n\tif (payment_id_length !== required_length) {\r\n\t\t// new encrypted short\r\n\t\treturn false; // invalid length\r\n\t}\r\n\tlet pattern = RegExp(\"^[0-9a-fA-F]{\" + required_length + \"}$\");\r\n\tif (pattern.test(payment_id) != true) {\r\n\t\t// not a valid required_length char pid\r\n\t\treturn false; // then not valid\r\n\t}\r\n\treturn true;\r\n}\r\nexports.IsValidShortPaymentID = IsValidShortPaymentID;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvbW9uZXJvX3V0aWxzL21vbmVyb19wYXltZW50SURfdXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvbW9uZXJvX3V0aWxzL21vbmVyb19wYXltZW50SURfdXRpbHMuanM/Yzc4OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxOCwgTXlNb25lcm8uY29tXHJcbi8vXHJcbi8vIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vXHJcbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZVxyXG4vLyBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuLy9cclxuLy8gMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2ZcclxuLy9cdGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuLy9cclxuLy8gMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3RcclxuLy9cdG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXJcclxuLy9cdG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbi8vXHJcbi8vIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGNvcHlyaWdodCBob2xkZXIgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZVxyXG4vL1x0dXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xyXG4vL1x0cHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4vL1xyXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkQgQU5ZXHJcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRlxyXG4vLyBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTFxyXG4vLyBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcclxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxyXG4vLyBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcclxuLy8gSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsXHJcbi8vIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxyXG4vLyBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbi8vXHJcblwidXNlIHN0cmljdFwiO1xyXG4vL1xyXG5mdW5jdGlvbiBJc1ZhbGlkUGF5bWVudElET3JOb1BheW1lbnRJRChwYXltZW50X2lkX19vck5pbCkge1xyXG5cdGlmIChcclxuXHRcdHBheW1lbnRfaWRfX29yTmlsID09IG51bGwgfHxcclxuXHRcdHBheW1lbnRfaWRfX29yTmlsID09IFwiXCIgfHxcclxuXHRcdHR5cGVvZiBwYXltZW50X2lkX19vck5pbCA9PSBcInVuZGVmaW5lZFwiXHJcblx0KSB7XHJcblx0XHRyZXR1cm4gdHJ1ZTsgLy8gbm8gcGlkXHJcblx0fVxyXG5cdGxldCBwYXltZW50X2lkID0gcGF5bWVudF9pZF9fb3JOaWw7XHJcblx0aWYgKElzVmFsaWRTaG9ydFBheW1lbnRJRChwYXltZW50X2lkKSkge1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdGlmIChJc1ZhbGlkTG9uZ1BheW1lbnRJRChwYXltZW50X2lkKSkge1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdHJldHVybiBmYWxzZTtcclxufVxyXG5leHBvcnRzLklzVmFsaWRQYXltZW50SURPck5vUGF5bWVudElEID0gSXNWYWxpZFBheW1lbnRJRE9yTm9QYXltZW50SUQ7XHJcbi8vXHJcbmZ1bmN0aW9uIElzVmFsaWRTaG9ydFBheW1lbnRJRChwYXltZW50X2lkKSB7XHJcblx0cmV0dXJuIElzVmFsaWRQYXltZW50SURPZkxlbmd0aChwYXltZW50X2lkLCAxNik7XHJcbn1cclxuZXhwb3J0cy5Jc1ZhbGlkU2hvcnRQYXltZW50SUQgPSBJc1ZhbGlkU2hvcnRQYXltZW50SUQ7XHJcbi8vXHJcbmZ1bmN0aW9uIElzVmFsaWRMb25nUGF5bWVudElEKHBheW1lbnRfaWQpIHtcclxuXHRyZXR1cm4gSXNWYWxpZFBheW1lbnRJRE9mTGVuZ3RoKHBheW1lbnRfaWQsIDY0KTtcclxufVxyXG5leHBvcnRzLklzVmFsaWRMb25nUGF5bWVudElEID0gSXNWYWxpZExvbmdQYXltZW50SUQ7XHJcbi8vXHJcbmZ1bmN0aW9uIElzVmFsaWRQYXltZW50SURPZkxlbmd0aChwYXltZW50X2lkLCByZXF1aXJlZF9sZW5ndGgpIHtcclxuXHRpZiAocmVxdWlyZWRfbGVuZ3RoICE9IDE2ICYmIHJlcXVpcmVkX2xlbmd0aCAhPSA2NCkge1xyXG5cdFx0dGhyb3cgXCJ1bmV4cGVjdGVkIElzVmFsaWRQYXltZW50SURPZkxlbmd0aCByZXF1aXJlZF9sZW5ndGhcIjtcclxuXHR9XHJcblx0bGV0IHBheW1lbnRfaWRfbGVuZ3RoID0gcGF5bWVudF9pZC5sZW5ndGg7XHJcblx0aWYgKHBheW1lbnRfaWRfbGVuZ3RoICE9PSByZXF1aXJlZF9sZW5ndGgpIHtcclxuXHRcdC8vIG5ldyBlbmNyeXB0ZWQgc2hvcnRcclxuXHRcdHJldHVybiBmYWxzZTsgLy8gaW52YWxpZCBsZW5ndGhcclxuXHR9XHJcblx0bGV0IHBhdHRlcm4gPSBSZWdFeHAoXCJeWzAtOWEtZkEtRl17XCIgKyByZXF1aXJlZF9sZW5ndGggKyBcIn0kXCIpO1xyXG5cdGlmIChwYXR0ZXJuLnRlc3QocGF5bWVudF9pZCkgIT0gdHJ1ZSkge1xyXG5cdFx0Ly8gbm90IGEgdmFsaWQgcmVxdWlyZWRfbGVuZ3RoIGNoYXIgcGlkXHJcblx0XHRyZXR1cm4gZmFsc2U7IC8vIHRoZW4gbm90IHZhbGlkXHJcblx0fVxyXG5cdHJldHVybiB0cnVlO1xyXG59XHJcbmV4cG9ydHMuSXNWYWxpZFNob3J0UGF5bWVudElEID0gSXNWYWxpZFNob3J0UGF5bWVudElEO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_paymentID_utils.js\n");

/***/ }),

/***/ "./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_requestURI_utils.js":
/*!*****************************************************************************************************!*\
  !*** ./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_requestURI_utils.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2014-2018, MyMonero.com\r\n//\r\n// All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without modification, are\r\n// permitted provided that the following conditions are met:\r\n//\r\n// 1. Redistributions of source code must retain the above copyright notice, this list of\r\n//\tconditions and the following disclaimer.\r\n//\r\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list\r\n//\tof conditions and the following disclaimer in the documentation and/or other\r\n//\tmaterials provided with the distribution.\r\n//\r\n// 3. Neither the name of the copyright holder nor the names of its contributors may be\r\n//\tused to endorse or promote products derived from this software without specific\r\n//\tprior written permission.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\r\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\r\n// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\r\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n//\r\n\r\n//\r\nconst monero_config = __webpack_require__(/*! ./monero_config */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_config.js\");\r\n//\r\nconst URITypes = {\r\n\taddressAsFirstPathComponent: 1,\r\n\taddressAsAuthority: 2,\r\n};\r\nexports.URITypes = URITypes;\r\n//\r\nfunction New_RequestFunds_URI(args) {\r\n\t// -> String?\r\n\tconst address = args.address;\r\n\tif (!address) {\r\n\t\tthrow \"missing address\";\r\n\t\t// return null\r\n\t}\r\n\tvar mutable_uri = \"\";\r\n\tmutable_uri += monero_config.coinUriPrefix;\r\n\t{\r\n\t\tconst uriType = args.uriType;\r\n\t\tif (uriType === URITypes.addressAsAuthority) {\r\n\t\t\tmutable_uri += \"//\"; // use for inserting a // so data detectors pick it up\r\n\t\t} else if (uriType === URITypes.addressAsFirstPathComponent) {\r\n\t\t\t// nothing to do\r\n\t\t} else {\r\n\t\t\tthrow \"Illegal args.uriType\";\r\n\t\t}\r\n\t}\r\n\tmutable_uri += address;\r\n\tvar isAppendingParam0 = true;\r\n\tfunction addParam(parameterName, value) {\r\n\t\tif (\r\n\t\t\tvalue == null ||\r\n\t\t\tvalue == \"\" /*important*/ ||\r\n\t\t\ttypeof value === \"undefined\"\r\n\t\t) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar conjunctionStr = \"&\";\r\n\t\tif (isAppendingParam0 === true) {\r\n\t\t\tisAppendingParam0 = false;\r\n\t\t\tconjunctionStr = \"?\";\r\n\t\t}\r\n\t\tmutable_uri += conjunctionStr;\r\n\t\tmutable_uri += parameterName + \"=\" + encodeURIComponent(value);\r\n\t}\r\n\t{\r\n\t\taddParam(\"tx_amount\", args.amount);\r\n\t\tif (\r\n\t\t\t(args.amountCcySymbol || \"\").toLowerCase() !=\r\n\t\t\tmonero_config.coinSymbol.toLowerCase()\r\n\t\t) {\r\n\t\t\taddParam(\"tx_amount_ccy\", args.amountCcySymbol);\r\n\t\t}\r\n\t\taddParam(\"tx_description\", args.description);\r\n\t\taddParam(\"tx_payment_id\", args.payment_id);\r\n\t\taddParam(\"tx_message\", args.message);\r\n\t}\r\n\treturn mutable_uri;\r\n}\r\nexports.New_RequestFunds_URI = New_RequestFunds_URI;\r\n//\r\nfunction New_ParsedPayload_FromPossibleRequestURIString(string, nettype, monero_utils/*pass this so this fn remains sync*/) {\r\n\t// throws; -> {}\r\n\t//\r\n\t// detect no-scheme moneroAddr and possible OA addr - if has no monero: prefix\r\n\tif (string.indexOf(monero_config.coinUriPrefix) !== 0) {\r\n\t\tconst stringHasQMark = string.indexOf(\"?\") !== -1;\r\n\t\tif (stringHasQMark) {\r\n\t\t\t// fairly sure this is correct.. (just an extra failsafe/filter)\r\n\t\t\tthrow \"Unrecognized URI format\";\r\n\t\t}\r\n\t\tlet couldBeOAAddress = string.indexOf(\".\") != -1; // contains period - would be nice to get this from DoesStringContainPeriodChar_excludingAsXMRAddress_qualifyingAsPossibleOAAddress so maybe mymonero_core_js should gain local_modules/OpenAlias\r\n\t\tif (couldBeOAAddress) {\r\n\t\t\treturn {\r\n\t\t\t\taddress: string,\r\n\t\t\t};\r\n\t\t}\r\n\t\tvar address__decode_result;\r\n\t\ttry {\r\n\t\t\taddress__decode_result = monero_utils.decode_address(\r\n\t\t\t\tstring,\r\n\t\t\t\tnettype,\r\n\t\t\t);\r\n\t\t} catch (e) {\r\n\t\t\tthrow \"No Monero request info\";\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// then it looks like a monero address\r\n\t\treturn {\r\n\t\t\taddress: string,\r\n\t\t};\r\n\t}\r\n\tconst uriString = string;\r\n\tconst url = new URL(uriString);\r\n\tconst protocol = url.protocol;\r\n\tif (protocol !== monero_config.coinUriPrefix) {\r\n\t\tthrow \"Request URI has non-Monero protocol\";\r\n\t}\r\n\tvar target_address = url.pathname; // var instead of const as have to finalize it\r\n\t// it seems that if the URL has // in it, pathname will be empty, but host will contain the address instead\r\n\tif (\r\n\t\ttarget_address === \"\" ||\r\n\t\ttypeof target_address === \"undefined\" ||\r\n\t\t!target_address\r\n\t) {\r\n\t\ttarget_address = url.host || url.hostname;\r\n\t}\r\n\tif (target_address.indexOf(\"//\") == 0) {\r\n\t\ttarget_address = target_address.slice(\r\n\t\t\t0 + \"//\".length,\r\n\t\t\ttarget_address.length,\r\n\t\t); // strip prefixing \"//\" in case URL had protocol:// instead of protocol:\r\n\t}\r\n\tconst searchParams = url.searchParams; // needs to be parsed it seems\r\n\t//\r\n\tconst payload = {\r\n\t\taddress: target_address,\r\n\t};\r\n\tconst keyPrefixToTrim = \"tx_\";\r\n\tconst lengthOf_keyPrefixToTrim = keyPrefixToTrim.length;\r\n\tsearchParams.forEach(function(value, key) {\r\n\t\tvar storeAt_key = key;\r\n\t\tif (key.indexOf(keyPrefixToTrim) === 0) {\r\n\t\t\tstoreAt_key = key.slice(lengthOf_keyPrefixToTrim, key.length);\r\n\t\t}\r\n\t\tpayload[\"\" + storeAt_key] = value;\r\n\t});\r\n\t//\r\n\treturn payload;\r\n}\r\nexports.New_ParsedPayload_FromPossibleRequestURIString = New_ParsedPayload_FromPossibleRequestURIString;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvbW9uZXJvX3V0aWxzL21vbmVyb19yZXF1ZXN0VVJJX3V0aWxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGlicy9teW1vbmVyby1hcHAtanMvbG9jYWxfbW9kdWxlcy9teW1vbmVyb19jb3JlX2pzL21vbmVyb191dGlscy9tb25lcm9fcmVxdWVzdFVSSV91dGlscy5qcz83YTFjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNC0yMDE4LCBNeU1vbmVyby5jb21cclxuLy9cclxuLy8gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy9cclxuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlXHJcbi8vIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4vL1xyXG4vLyAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZlxyXG4vL1x0Y29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4vL1xyXG4vLyAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdFxyXG4vL1x0b2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlclxyXG4vL1x0bWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuLy9cclxuLy8gMy4gTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgY29weXJpZ2h0IGhvbGRlciBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlXHJcbi8vXHR1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljXHJcbi8vXHRwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcbi8vXHJcbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORCBBTllcclxuLy8gRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GXHJcbi8vIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMXHJcbi8vIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxyXG4vLyBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXHJcbi8vIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xyXG4vLyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCxcclxuLy8gU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXHJcbi8vIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuLy9cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8vXHJcbmNvbnN0IG1vbmVyb19jb25maWcgPSByZXF1aXJlKFwiLi9tb25lcm9fY29uZmlnXCIpO1xyXG4vL1xyXG5jb25zdCBVUklUeXBlcyA9IHtcclxuXHRhZGRyZXNzQXNGaXJzdFBhdGhDb21wb25lbnQ6IDEsXHJcblx0YWRkcmVzc0FzQXV0aG9yaXR5OiAyLFxyXG59O1xyXG5leHBvcnRzLlVSSVR5cGVzID0gVVJJVHlwZXM7XHJcbi8vXHJcbmZ1bmN0aW9uIE5ld19SZXF1ZXN0RnVuZHNfVVJJKGFyZ3MpIHtcclxuXHQvLyAtPiBTdHJpbmc/XHJcblx0Y29uc3QgYWRkcmVzcyA9IGFyZ3MuYWRkcmVzcztcclxuXHRpZiAoIWFkZHJlc3MpIHtcclxuXHRcdHRocm93IFwibWlzc2luZyBhZGRyZXNzXCI7XHJcblx0XHQvLyByZXR1cm4gbnVsbFxyXG5cdH1cclxuXHR2YXIgbXV0YWJsZV91cmkgPSBcIlwiO1xyXG5cdG11dGFibGVfdXJpICs9IG1vbmVyb19jb25maWcuY29pblVyaVByZWZpeDtcclxuXHR7XHJcblx0XHRjb25zdCB1cmlUeXBlID0gYXJncy51cmlUeXBlO1xyXG5cdFx0aWYgKHVyaVR5cGUgPT09IFVSSVR5cGVzLmFkZHJlc3NBc0F1dGhvcml0eSkge1xyXG5cdFx0XHRtdXRhYmxlX3VyaSArPSBcIi8vXCI7IC8vIHVzZSBmb3IgaW5zZXJ0aW5nIGEgLy8gc28gZGF0YSBkZXRlY3RvcnMgcGljayBpdCB1cOKAplxyXG5cdFx0fSBlbHNlIGlmICh1cmlUeXBlID09PSBVUklUeXBlcy5hZGRyZXNzQXNGaXJzdFBhdGhDb21wb25lbnQpIHtcclxuXHRcdFx0Ly8gbm90aGluZyB0byBkb1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhyb3cgXCJJbGxlZ2FsIGFyZ3MudXJpVHlwZVwiO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRtdXRhYmxlX3VyaSArPSBhZGRyZXNzO1xyXG5cdHZhciBpc0FwcGVuZGluZ1BhcmFtMCA9IHRydWU7XHJcblx0ZnVuY3Rpb24gYWRkUGFyYW0ocGFyYW1ldGVyTmFtZSwgdmFsdWUpIHtcclxuXHRcdGlmIChcclxuXHRcdFx0dmFsdWUgPT0gbnVsbCB8fFxyXG5cdFx0XHR2YWx1ZSA9PSBcIlwiIC8qaW1wb3J0YW50Ki8gfHxcclxuXHRcdFx0dHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiXHJcblx0XHQpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGNvbmp1bmN0aW9uU3RyID0gXCImXCI7XHJcblx0XHRpZiAoaXNBcHBlbmRpbmdQYXJhbTAgPT09IHRydWUpIHtcclxuXHRcdFx0aXNBcHBlbmRpbmdQYXJhbTAgPSBmYWxzZTtcclxuXHRcdFx0Y29uanVuY3Rpb25TdHIgPSBcIj9cIjtcclxuXHRcdH1cclxuXHRcdG11dGFibGVfdXJpICs9IGNvbmp1bmN0aW9uU3RyO1xyXG5cdFx0bXV0YWJsZV91cmkgKz0gcGFyYW1ldGVyTmFtZSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcclxuXHR9XHJcblx0e1xyXG5cdFx0YWRkUGFyYW0oXCJ0eF9hbW91bnRcIiwgYXJncy5hbW91bnQpO1xyXG5cdFx0aWYgKFxyXG5cdFx0XHQoYXJncy5hbW91bnRDY3lTeW1ib2wgfHwgXCJcIikudG9Mb3dlckNhc2UoKSAhPVxyXG5cdFx0XHRtb25lcm9fY29uZmlnLmNvaW5TeW1ib2wudG9Mb3dlckNhc2UoKVxyXG5cdFx0KSB7XHJcblx0XHRcdGFkZFBhcmFtKFwidHhfYW1vdW50X2NjeVwiLCBhcmdzLmFtb3VudENjeVN5bWJvbCk7XHJcblx0XHR9XHJcblx0XHRhZGRQYXJhbShcInR4X2Rlc2NyaXB0aW9uXCIsIGFyZ3MuZGVzY3JpcHRpb24pO1xyXG5cdFx0YWRkUGFyYW0oXCJ0eF9wYXltZW50X2lkXCIsIGFyZ3MucGF5bWVudF9pZCk7XHJcblx0XHRhZGRQYXJhbShcInR4X21lc3NhZ2VcIiwgYXJncy5tZXNzYWdlKTtcclxuXHR9XHJcblx0cmV0dXJuIG11dGFibGVfdXJpO1xyXG59XHJcbmV4cG9ydHMuTmV3X1JlcXVlc3RGdW5kc19VUkkgPSBOZXdfUmVxdWVzdEZ1bmRzX1VSSTtcclxuLy9cclxuZnVuY3Rpb24gTmV3X1BhcnNlZFBheWxvYWRfRnJvbVBvc3NpYmxlUmVxdWVzdFVSSVN0cmluZyhzdHJpbmcsIG5ldHR5cGUsIG1vbmVyb191dGlscy8qcGFzcyB0aGlzIHNvIHRoaXMgZm4gcmVtYWlucyBzeW5jKi8pIHtcclxuXHQvLyB0aHJvd3M7IC0+IHt9XHJcblx0Ly9cclxuXHQvLyBkZXRlY3Qgbm8tc2NoZW1lIG1vbmVyb0FkZHIgYW5kIHBvc3NpYmxlIE9BIGFkZHIgLSBpZiBoYXMgbm8gbW9uZXJvOiBwcmVmaXhcclxuXHRpZiAoc3RyaW5nLmluZGV4T2YobW9uZXJvX2NvbmZpZy5jb2luVXJpUHJlZml4KSAhPT0gMCkge1xyXG5cdFx0Y29uc3Qgc3RyaW5nSGFzUU1hcmsgPSBzdHJpbmcuaW5kZXhPZihcIj9cIikgIT09IC0xO1xyXG5cdFx0aWYgKHN0cmluZ0hhc1FNYXJrKSB7XHJcblx0XHRcdC8vIGZhaXJseSBzdXJlIHRoaXMgaXMgY29ycmVjdC4uIChqdXN0IGFuIGV4dHJhIGZhaWxzYWZlL2ZpbHRlcilcclxuXHRcdFx0dGhyb3cgXCJVbnJlY29nbml6ZWQgVVJJIGZvcm1hdFwiO1xyXG5cdFx0fVxyXG5cdFx0bGV0IGNvdWxkQmVPQUFkZHJlc3MgPSBzdHJpbmcuaW5kZXhPZihcIi5cIikgIT0gLTE7IC8vIGNvbnRhaW5zIHBlcmlvZCAtIHdvdWxkIGJlIG5pY2UgdG8gZ2V0IHRoaXMgZnJvbSBEb2VzU3RyaW5nQ29udGFpblBlcmlvZENoYXJfZXhjbHVkaW5nQXNYTVJBZGRyZXNzX3F1YWxpZnlpbmdBc1Bvc3NpYmxlT0FBZGRyZXNzIHNvIG1heWJlIG15bW9uZXJvX2NvcmVfanMgc2hvdWxkIGdhaW4gbG9jYWxfbW9kdWxlcy9PcGVuQWxpYXNcclxuXHRcdGlmIChjb3VsZEJlT0FBZGRyZXNzKSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0YWRkcmVzczogc3RyaW5nLFxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdFx0dmFyIGFkZHJlc3NfX2RlY29kZV9yZXN1bHQ7XHJcblx0XHR0cnkge1xyXG5cdFx0XHRhZGRyZXNzX19kZWNvZGVfcmVzdWx0ID0gbW9uZXJvX3V0aWxzLmRlY29kZV9hZGRyZXNzKFxyXG5cdFx0XHRcdHN0cmluZyxcclxuXHRcdFx0XHRuZXR0eXBlLFxyXG5cdFx0XHQpO1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHR0aHJvdyBcIk5vIE1vbmVybyByZXF1ZXN0IGluZm9cIjtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0Ly8gdGhlbiBpdCBsb29rcyBsaWtlIGEgbW9uZXJvIGFkZHJlc3NcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGFkZHJlc3M6IHN0cmluZyxcclxuXHRcdH07XHJcblx0fVxyXG5cdGNvbnN0IHVyaVN0cmluZyA9IHN0cmluZztcclxuXHRjb25zdCB1cmwgPSBuZXcgVVJMKHVyaVN0cmluZyk7XHJcblx0Y29uc3QgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2w7XHJcblx0aWYgKHByb3RvY29sICE9PSBtb25lcm9fY29uZmlnLmNvaW5VcmlQcmVmaXgpIHtcclxuXHRcdHRocm93IFwiUmVxdWVzdCBVUkkgaGFzIG5vbi1Nb25lcm8gcHJvdG9jb2xcIjtcclxuXHR9XHJcblx0dmFyIHRhcmdldF9hZGRyZXNzID0gdXJsLnBhdGhuYW1lOyAvLyB2YXIgaW5zdGVhZCBvZiBjb25zdCBhcyBoYXZlIHRvIGZpbmFsaXplIGl0XHJcblx0Ly8gaXQgc2VlbXMgdGhhdCBpZiB0aGUgVVJMIGhhcyAvLyBpbiBpdCwgcGF0aG5hbWUgd2lsbCBiZSBlbXB0eSwgYnV0IGhvc3Qgd2lsbCBjb250YWluIHRoZSBhZGRyZXNzIGluc3RlYWRcclxuXHRpZiAoXHJcblx0XHR0YXJnZXRfYWRkcmVzcyA9PT0gXCJcIiB8fFxyXG5cdFx0dHlwZW9mIHRhcmdldF9hZGRyZXNzID09PSBcInVuZGVmaW5lZFwiIHx8XHJcblx0XHQhdGFyZ2V0X2FkZHJlc3NcclxuXHQpIHtcclxuXHRcdHRhcmdldF9hZGRyZXNzID0gdXJsLmhvc3QgfHwgdXJsLmhvc3RuYW1lO1xyXG5cdH1cclxuXHRpZiAodGFyZ2V0X2FkZHJlc3MuaW5kZXhPZihcIi8vXCIpID09IDApIHtcclxuXHRcdHRhcmdldF9hZGRyZXNzID0gdGFyZ2V0X2FkZHJlc3Muc2xpY2UoXHJcblx0XHRcdDAgKyBcIi8vXCIubGVuZ3RoLFxyXG5cdFx0XHR0YXJnZXRfYWRkcmVzcy5sZW5ndGgsXHJcblx0XHQpOyAvLyBzdHJpcCBwcmVmaXhpbmcgXCIvL1wiIGluIGNhc2UgVVJMIGhhZCBwcm90b2NvbDovLyBpbnN0ZWFkIG9mIHByb3RvY29sOlxyXG5cdH1cclxuXHRjb25zdCBzZWFyY2hQYXJhbXMgPSB1cmwuc2VhcmNoUGFyYW1zOyAvLyBuZWVkcyB0byBiZSBwYXJzZWQgaXQgc2VlbXNcclxuXHQvL1xyXG5cdGNvbnN0IHBheWxvYWQgPSB7XHJcblx0XHRhZGRyZXNzOiB0YXJnZXRfYWRkcmVzcyxcclxuXHR9O1xyXG5cdGNvbnN0IGtleVByZWZpeFRvVHJpbSA9IFwidHhfXCI7XHJcblx0Y29uc3QgbGVuZ3RoT2Zfa2V5UHJlZml4VG9UcmltID0ga2V5UHJlZml4VG9UcmltLmxlbmd0aDtcclxuXHRzZWFyY2hQYXJhbXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XHJcblx0XHR2YXIgc3RvcmVBdF9rZXkgPSBrZXk7XHJcblx0XHRpZiAoa2V5LmluZGV4T2Yoa2V5UHJlZml4VG9UcmltKSA9PT0gMCkge1xyXG5cdFx0XHRzdG9yZUF0X2tleSA9IGtleS5zbGljZShsZW5ndGhPZl9rZXlQcmVmaXhUb1RyaW0sIGtleS5sZW5ndGgpO1xyXG5cdFx0fVxyXG5cdFx0cGF5bG9hZFtcIlwiICsgc3RvcmVBdF9rZXldID0gdmFsdWU7XHJcblx0fSk7XHJcblx0Ly9cclxuXHRyZXR1cm4gcGF5bG9hZDtcclxufVxyXG5leHBvcnRzLk5ld19QYXJzZWRQYXlsb2FkX0Zyb21Qb3NzaWJsZVJlcXVlc3RVUklTdHJpbmcgPSBOZXdfUGFyc2VkUGF5bG9hZF9Gcm9tUG9zc2libGVSZXF1ZXN0VVJJU3RyaW5nO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_requestURI_utils.js\n");

/***/ }),

/***/ "./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_sendingFunds_utils.js":
/*!*******************************************************************************************************!*\
  !*** ./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_sendingFunds_utils.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2014-2018, MyMonero.com\r\n//\r\n// All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without modification, are\r\n// permitted provided that the following conditions are met:\r\n//\r\n// 1. Redistributions of source code must retain the above copyright notice, this list of\r\n//\tconditions and the following disclaimer.\r\n//\r\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list\r\n//\tof conditions and the following disclaimer in the documentation and/or other\r\n//\tmaterials provided with the distribution.\r\n//\r\n// 3. Neither the name of the copyright holder nor the names of its contributors may be\r\n//\tused to endorse or promote products derived from this software without specific\r\n//\tprior written permission.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\r\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\r\n// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\r\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n//\r\n\r\n//\r\nconst monero_config = __webpack_require__(/*! ./monero_config */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_config.js\");\r\nconst monero_utils_promise = __webpack_require__(/*! ./monero_utils */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_utils.js\")({})\r\nconst monero_amount_format_utils = __webpack_require__(/*! ./monero_amount_format_utils */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_amount_format_utils.js\");\r\nconst monero_paymentID_utils = __webpack_require__(/*! ./monero_paymentID_utils */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_paymentID_utils.js\");\r\nconst JSBigInt = __webpack_require__(/*! ../cryptonote_utils/biginteger */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/biginteger.js\").BigInteger;\r\n//\r\nconst hostAPI_net_service_utils = __webpack_require__(/*! ../hostAPI/net_service_utils */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/hostAPI/net_service_utils.js\");\r\n//\r\nfunction _mixinToRingsize(mixin) {\r\n\treturn mixin + 1;\r\n}\r\n//\r\nfunction thisFork_minMixin() {\r\n\treturn 10;\r\n}\r\nfunction thisFork_minRingSize() {\r\n\treturn _mixinToRingsize(thisFork_minMixin());\r\n}\r\nexports.thisFork_minMixin = thisFork_minMixin;\r\nexports.thisFork_minRingSize = thisFork_minRingSize;\r\n//\r\nfunction fixedMixin() {\r\n\treturn thisFork_minMixin(); /* using the monero app default to remove MM user identifiers */\r\n}\r\nfunction fixedRingsize() {\r\n\treturn _mixinToRingsize(fixedMixin());\r\n}\r\nexports.fixedMixin = fixedMixin;\r\nexports.fixedRingsize = fixedRingsize;\r\n//\r\n//\r\nfunction default_priority() {\r\n\treturn 1;\r\n} // aka .low\r\nexports.default_priority = default_priority;\r\n//\r\nconst newer_multipliers = [1, 4, 20, 166];\r\nfunction fee_multiplier_for_priority(priority__or0ForDefault) {\r\n\tconst final_priorityInt =\r\n\t\t!priority__or0ForDefault || priority__or0ForDefault == 0\r\n\t\t\t? default_priority()\r\n\t\t\t: priority__or0ForDefault;\r\n\tif (\r\n\t\tfinal_priorityInt <= 0 ||\r\n\t\tfinal_priorityInt > newer_multipliers.length\r\n\t) {\r\n\t\tthrow \"fee_multiplier_for_priority: simple_priority out of bounds\";\r\n\t}\r\n\tconst priority_as_idx = final_priorityInt - 1;\r\n\treturn newer_multipliers[priority_as_idx];\r\n}\r\n//\r\nconst SendFunds_ProcessStep_Code = {\r\n\tfetchingLatestBalance: 1,\r\n\tcalculatingFee: 2,\r\n\tfetchingDecoyOutputs: 3, // may get skipped if 0 mixin\r\n\tconstructingTransaction: 4, // may go back to .calculatingFee\r\n\tsubmittingTransaction: 5,\r\n};\r\nexports.SendFunds_ProcessStep_Code = SendFunds_ProcessStep_Code;\r\nconst SendFunds_ProcessStep_MessageSuffix = {\r\n\t1: \"Fetching latest balance.\",\r\n\t2: \"Calculating fee.\",\r\n\t3: \"Fetching decoy outputs.\",\r\n\t4: \"Constructing transaction.\", // may go back to .calculatingFee\r\n\t5: \"Submitting transaction.\",\r\n};\r\nexports.SendFunds_ProcessStep_MessageSuffix = SendFunds_ProcessStep_MessageSuffix;\r\n//\r\nfunction SendFunds( // TODO: migrate this to take a map of args\r\n\ttarget_address, // currency-ready wallet address, but not an OA address (resolve before calling)\r\n\tnettype,\r\n\tamount_orZeroWhenSweep, // number - value will be ignoring for sweep\r\n\tisSweep_orZeroWhenAmount, // send true to sweep - amount_orZeroWhenSweep will be ignored\r\n\twallet__public_address,\r\n\twallet__private_keys,\r\n\twallet__public_keys,\r\n\thostedMoneroAPIClient, // TODO: possibly factor this dependency\r\n\tpayment_id,\r\n\tsimple_priority,\r\n\tpreSuccess_nonTerminal_statusUpdate_fn, // (_ stepCode: SendFunds_ProcessStep_Code) -> Void\r\n\tsuccess_fn,\r\n\t// success_fn: ( // TODO: to be migrated to args as return obj\r\n\t//\t\tmoneroReady_targetDescription_address?,\r\n\t//\t\tsentAmount?,\r\n\t//\t\tfinal__payment_id?,\r\n\t//\t\ttx_hash?,\r\n\t//\t\ttx_fee?,\r\n\t//\t\ttx_key?,\r\n\t//\t\tmixin?,\r\n\t// )\r\n\tfailWithErr_fn\r\n\t// failWithErr_fn: (\r\n\t//\t\terr\r\n\t// )\r\n) {\r\n\tmonero_utils_promise.then(function(monero_utils)\r\n\t{\r\n\t\tconst mixin = fixedMixin(); // would be nice to eliminate this dependency or grab it from C++\r\n\t\t//\r\n\t\t// some callback trampoline function declarations\r\n\t\tfunction __trampolineFor_err_withErr(err) {\r\n\t\t\tfailWithErr_fn(err);\r\n\t\t}\r\n\t\tfunction __trampolineFor_err_withStr(errStr) {\r\n\t\t\tconst err = new Error(errStr);\r\n\t\t\tconsole.error(errStr);\r\n\t\t\tfailWithErr_fn(err);\r\n\t\t}\r\n\t\t//\r\n\t\tvar sweeping = isSweep_orZeroWhenAmount === true; // rather than, say, undefined\r\n\t\tvar amount = \"\" + (sweeping ? 0 : amount_orZeroWhenSweep); //TODO just send string\r\n\t\tvar sending_amount; // possibly need this ; here for the JS parser\r\n\t\tif (sweeping) {\r\n\t\t\tsending_amount = 0\r\n\t\t} else {\r\n\t\t\ttry {\r\n\t\t\t\tsending_amount = monero_amount_format_utils.parseMoney(amount);\r\n\t\t\t} catch (e) {\r\n\t\t\t\t__trampolineFor_err_withStr(`Couldn't parse amount ${amount}: ${e}`);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\t//\r\n\t\t// TODO:\r\n\t\t// const wallet__public_keys = decode_address(from_address, nettype);\r\n\t\t//\r\n\t\tpreSuccess_nonTerminal_statusUpdate_fn(SendFunds_ProcessStep_Code.fetchingLatestBalance);\r\n\t\tvar fee_per_b__string;\r\n\t\tvar unspent_outs; \r\n\t\thostedMoneroAPIClient.UnspentOuts(\r\n\t\t\twallet__public_address,\r\n\t\t\twallet__private_keys.view,\r\n\t\t\twallet__public_keys.spend,\r\n\t\t\twallet__private_keys.spend,\r\n\t\t\tmixin,\r\n\t\t\tsweeping,\r\n\t\t\tfunction(err, returned_unusedOuts, per_byte_fee__string)\r\n\t\t\t{\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\t__trampolineFor_err_withErr(err);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tconsole.log(\"Received dynamic per kb fee\", monero_amount_format_utils.formatMoneySymbol(new JSBigInt(per_byte_fee__string)));\r\n\t\t\t\t{ // save some values for re-enterable function\r\n\t\t\t\t\tunspent_outs = returned_unusedOuts; // TODO: which one should be used? delete the other\r\n\t\t\t\t\tfee_per_b__string = per_byte_fee__string; \r\n\t\t\t\t}\r\n\t\t\t\t__reenterable_constructAndSendTx(\r\n\t\t\t\t\tnull, // for the first try - passedIn_attemptAt_network_minimumFee\r\n\t\t\t\t\t1\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t\tfunction __reenterable_constructAndSendTx(optl__passedIn_attemptAt_fee, constructionAttempt)\r\n\t\t{\r\n\t\t\t// Now we need to establish some values for balance validation and to construct the transaction\r\n\t\t\tpreSuccess_nonTerminal_statusUpdate_fn(SendFunds_ProcessStep_Code.calculatingFee);\r\n\t\t\tvar step1_retVals;\r\n\t\t\ttry {\r\n\t\t\t\tstep1_retVals = monero_utils.send_step1__prepare_params_for_get_decoys(\r\n\t\t\t\t\tsweeping,\r\n\t\t\t\t\tsending_amount.toString(), // must be a string\r\n\t\t\t\t\tfee_per_b__string,\r\n\t\t\t\t\tsimple_priority,\r\n\t\t\t\t\tunspent_outs,\r\n\t\t\t\t\tpayment_id, // may be nil\r\n\t\t\t\t\toptl__passedIn_attemptAt_fee\r\n\t\t\t\t);\r\n\t\t\t} catch (e) {\r\n\t\t\t\tvar errStr;\r\n\t\t\t\tif (e) {\r\n\t\t\t\t\terrStr = typeof e == \"string\" ? e : e.toString();\r\n\t\t\t\t} else {\r\n\t\t\t\t\terrStr = \"Failed to create transaction (step 1) with unknown error.\";\r\n\t\t\t\t}\r\n\t\t\t\t__trampolineFor_err_withStr(errStr);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t//\r\n\t\t\t// prep for step2\r\n\t\t\t// first, grab RandomOuts, then enter step2\r\n\t\t\tpreSuccess_nonTerminal_statusUpdate_fn(SendFunds_ProcessStep_Code.fetchingDecoyOutputs);\r\n\t\t\thostedMoneroAPIClient.RandomOuts(\r\n\t\t\t\tstep1_retVals.using_outs, \r\n\t\t\t\tstep1_retVals.mixin, \r\n\t\t\t\tfunction(err, mix_outs)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\t__trampolineFor_err_withErr(err);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t___createTxAndAttemptToSend(mix_outs); \r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t\tfunction ___createTxAndAttemptToSend(mix_outs) \r\n\t\t\t{\r\n\t\t\t\tpreSuccess_nonTerminal_statusUpdate_fn(SendFunds_ProcessStep_Code.constructingTransaction);\r\n\t\t\t\tvar step2_retVals;\r\n\t\t\t\ttry {\r\n\t\t\t\t\tstep2_retVals = monero_utils.send_step2__try_create_transaction(\r\n\t\t\t\t\t\twallet__public_address,\r\n\t\t\t\t\t\twallet__private_keys,\r\n\t\t\t\t\t\ttarget_address,\r\n\t\t\t\t\t\tstep1_retVals.using_outs, // able to read this directly from step1 JSON\r\n\t\t\t\t\t\tmix_outs,\r\n\t\t\t\t\t\tstep1_retVals.mixin,\r\n\t\t\t\t\t\tstep1_retVals.final_total_wo_fee,\r\n\t\t\t\t\t\tstep1_retVals.change_amount,\r\n\t\t\t\t\t\tstep1_retVals.using_fee,\r\n\t\t\t\t\t\tpayment_id, \r\n\t\t\t\t\t\tsimple_priority,\r\n\t\t\t\t\t\tfee_per_b__string,\r\n\t\t\t\t\t\t0, // unlock time\r\n\t\t\t\t\t\tnettype\r\n\t\t\t\t\t);\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tvar errStr;\r\n\t\t\t\t\tif (e) {\r\n\t\t\t\t\t\terrStr = typeof e == \"string\" ? e : e.toString();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\terrStr = \"Failed to create transaction (step 2) with unknown error.\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\t__trampolineFor_err_withStr(errStr);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tif (typeof step2_retVals.err_msg !== 'undefined' && step2_retVals.err_msg) { // actually not expecting this! but just in case..\r\n\t\t\t\t\t__trampolineFor_err_withStr(step2_retVals.err_msg);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\t// if we need a higher fee\r\n\t\t\t\tif (step2_retVals.tx_must_be_reconstructed === true || step2_retVals.tx_must_be_reconstructed === \"true\") { // TODO\r\n\t\t\t\t\tconsole.log(\"Need to reconstruct the tx with enough of a network fee\");\r\n\t\t\t\t\t// this will update status back to .calculatingFee\r\n\t\t\t\t\tif (constructionAttempt > 30) { // just going to avoid an infinite loop here\r\n\t\t\t\t\t\t__trampolineFor_err_withStr(\"Unable to construct a transaction with sufficient fee for unknown reason.\");\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t__reenterable_constructAndSendTx(\r\n\t\t\t\t\t\tstep2_retVals.fee_actually_needed, // we are re-entering the step1->step2 codepath after updating fee_actually_needed\r\n\t\t\t\t\t\tconstructionAttempt + 1\r\n\t\t\t\t\t);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\t// Generated with correct fee\r\n\t\t\t\t// console.log(\"tx serialized: \" + step2_retVals.signed_serialized_tx);\r\n\t\t\t\t// console.log(\"Tx hash: \" + step2_retVals.tx_hash);\r\n\t\t\t\t// console.log(\"Tx key: \" + step2_retVals.tx_key);\r\n\t\t\t\t// console.log(\"Successful tx generation; submitting.\");\r\n\t\t\t\t// status: submitting\r\n\t\t\t\tpreSuccess_nonTerminal_statusUpdate_fn(SendFunds_ProcessStep_Code.submittingTransaction);\r\n\t\t\t\thostedMoneroAPIClient.SubmitSerializedSignedTransaction(\r\n\t\t\t\t\twallet__public_address,\r\n\t\t\t\t\twallet__private_keys.view,\r\n\t\t\t\t\tstep2_retVals.signed_serialized_tx,\r\n\t\t\t\t\tfunction(err) {\r\n\t\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\t\t__trampolineFor_err_withStr(\"Something unexpected occurred when submitting your transaction: \" + err);\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tconst final_fee_amount = new JSBigInt(step1_retVals.using_fee)\r\n\t\t\t\t\t\tconst finalTotalWOFee_amount = new JSBigInt(step1_retVals.final_total_wo_fee)\r\n\t\t\t\t\t\tvar final__payment_id = payment_id;\r\n\t\t\t\t\t\tif (final__payment_id === null || typeof final__payment_id == \"undefined\" || !final__payment_id) {\r\n\t\t\t\t\t\t\tconst decoded  = monero_utils.decode_address(target_address, nettype);\r\n\t\t\t\t\t\t\tif (decoded.intPaymentId && typeof decoded.intPaymentId !== 'undefined') {\r\n\t\t\t\t\t\t\t\tfinal__payment_id = decoded.intPaymentId // just preserving original return value - this retVal can eventually be removed\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tsuccess_fn( // TODO: port this to returning a dictionary\r\n\t\t\t\t\t\t\ttarget_address, // TODO: remove this\r\n\t\t\t\t\t\t\tfinalTotalWOFee_amount.add(final_fee_amount), // total sent\r\n\t\t\t\t\t\t\tfinal__payment_id, \r\n\t\t\t\t\t\t\tstep2_retVals.tx_hash,\r\n\t\t\t\t\t\t\tfinal_fee_amount,\r\n\t\t\t\t\t\t\tstep2_retVals.tx_key,\r\n\t\t\t\t\t\t\tparseInt(step1_retVals.mixin)\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n}\r\nexports.SendFunds = SendFunds;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvbW9uZXJvX3V0aWxzL21vbmVyb19zZW5kaW5nRnVuZHNfdXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvbW9uZXJvX3V0aWxzL21vbmVyb19zZW5kaW5nRnVuZHNfdXRpbHMuanM/Nzc3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxOCwgTXlNb25lcm8uY29tXHJcbi8vXHJcbi8vIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vXHJcbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZVxyXG4vLyBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuLy9cclxuLy8gMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2ZcclxuLy9cdGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuLy9cclxuLy8gMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3RcclxuLy9cdG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXJcclxuLy9cdG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbi8vXHJcbi8vIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGNvcHlyaWdodCBob2xkZXIgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZVxyXG4vL1x0dXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xyXG4vL1x0cHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4vL1xyXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkQgQU5ZXHJcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRlxyXG4vLyBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTFxyXG4vLyBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcclxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxyXG4vLyBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcclxuLy8gSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsXHJcbi8vIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxyXG4vLyBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbi8vXHJcblwidXNlIHN0cmljdFwiO1xyXG4vL1xyXG5jb25zdCBtb25lcm9fY29uZmlnID0gcmVxdWlyZShcIi4vbW9uZXJvX2NvbmZpZ1wiKTtcclxuY29uc3QgbW9uZXJvX3V0aWxzX3Byb21pc2UgPSByZXF1aXJlKCcuL21vbmVyb191dGlscycpKHt9KVxyXG5jb25zdCBtb25lcm9fYW1vdW50X2Zvcm1hdF91dGlscyA9IHJlcXVpcmUoXCIuL21vbmVyb19hbW91bnRfZm9ybWF0X3V0aWxzXCIpO1xyXG5jb25zdCBtb25lcm9fcGF5bWVudElEX3V0aWxzID0gcmVxdWlyZShcIi4vbW9uZXJvX3BheW1lbnRJRF91dGlsc1wiKTtcclxuY29uc3QgSlNCaWdJbnQgPSByZXF1aXJlKFwiLi4vY3J5cHRvbm90ZV91dGlscy9iaWdpbnRlZ2VyXCIpLkJpZ0ludGVnZXI7XHJcbi8vXHJcbmNvbnN0IGhvc3RBUElfbmV0X3NlcnZpY2VfdXRpbHMgPSByZXF1aXJlKFwiLi4vaG9zdEFQSS9uZXRfc2VydmljZV91dGlsc1wiKTtcclxuLy9cclxuZnVuY3Rpb24gX21peGluVG9SaW5nc2l6ZShtaXhpbikge1xyXG5cdHJldHVybiBtaXhpbiArIDE7XHJcbn1cclxuLy9cclxuZnVuY3Rpb24gdGhpc0ZvcmtfbWluTWl4aW4oKSB7XHJcblx0cmV0dXJuIDEwO1xyXG59XHJcbmZ1bmN0aW9uIHRoaXNGb3JrX21pblJpbmdTaXplKCkge1xyXG5cdHJldHVybiBfbWl4aW5Ub1JpbmdzaXplKHRoaXNGb3JrX21pbk1peGluKCkpO1xyXG59XHJcbmV4cG9ydHMudGhpc0ZvcmtfbWluTWl4aW4gPSB0aGlzRm9ya19taW5NaXhpbjtcclxuZXhwb3J0cy50aGlzRm9ya19taW5SaW5nU2l6ZSA9IHRoaXNGb3JrX21pblJpbmdTaXplO1xyXG4vL1xyXG5mdW5jdGlvbiBmaXhlZE1peGluKCkge1xyXG5cdHJldHVybiB0aGlzRm9ya19taW5NaXhpbigpOyAvKiB1c2luZyB0aGUgbW9uZXJvIGFwcCBkZWZhdWx0IHRvIHJlbW92ZSBNTSB1c2VyIGlkZW50aWZpZXJzICovXHJcbn1cclxuZnVuY3Rpb24gZml4ZWRSaW5nc2l6ZSgpIHtcclxuXHRyZXR1cm4gX21peGluVG9SaW5nc2l6ZShmaXhlZE1peGluKCkpO1xyXG59XHJcbmV4cG9ydHMuZml4ZWRNaXhpbiA9IGZpeGVkTWl4aW47XHJcbmV4cG9ydHMuZml4ZWRSaW5nc2l6ZSA9IGZpeGVkUmluZ3NpemU7XHJcbi8vXHJcbi8vXHJcbmZ1bmN0aW9uIGRlZmF1bHRfcHJpb3JpdHkoKSB7XHJcblx0cmV0dXJuIDE7XHJcbn0gLy8gYWthIC5sb3dcclxuZXhwb3J0cy5kZWZhdWx0X3ByaW9yaXR5ID0gZGVmYXVsdF9wcmlvcml0eTtcclxuLy9cclxuY29uc3QgbmV3ZXJfbXVsdGlwbGllcnMgPSBbMSwgNCwgMjAsIDE2Nl07XHJcbmZ1bmN0aW9uIGZlZV9tdWx0aXBsaWVyX2Zvcl9wcmlvcml0eShwcmlvcml0eV9fb3IwRm9yRGVmYXVsdCkge1xyXG5cdGNvbnN0IGZpbmFsX3ByaW9yaXR5SW50ID1cclxuXHRcdCFwcmlvcml0eV9fb3IwRm9yRGVmYXVsdCB8fCBwcmlvcml0eV9fb3IwRm9yRGVmYXVsdCA9PSAwXHJcblx0XHRcdD8gZGVmYXVsdF9wcmlvcml0eSgpXHJcblx0XHRcdDogcHJpb3JpdHlfX29yMEZvckRlZmF1bHQ7XHJcblx0aWYgKFxyXG5cdFx0ZmluYWxfcHJpb3JpdHlJbnQgPD0gMCB8fFxyXG5cdFx0ZmluYWxfcHJpb3JpdHlJbnQgPiBuZXdlcl9tdWx0aXBsaWVycy5sZW5ndGhcclxuXHQpIHtcclxuXHRcdHRocm93IFwiZmVlX211bHRpcGxpZXJfZm9yX3ByaW9yaXR5OiBzaW1wbGVfcHJpb3JpdHkgb3V0IG9mIGJvdW5kc1wiO1xyXG5cdH1cclxuXHRjb25zdCBwcmlvcml0eV9hc19pZHggPSBmaW5hbF9wcmlvcml0eUludCAtIDE7XHJcblx0cmV0dXJuIG5ld2VyX211bHRpcGxpZXJzW3ByaW9yaXR5X2FzX2lkeF07XHJcbn1cclxuLy9cclxuY29uc3QgU2VuZEZ1bmRzX1Byb2Nlc3NTdGVwX0NvZGUgPSB7XHJcblx0ZmV0Y2hpbmdMYXRlc3RCYWxhbmNlOiAxLFxyXG5cdGNhbGN1bGF0aW5nRmVlOiAyLFxyXG5cdGZldGNoaW5nRGVjb3lPdXRwdXRzOiAzLCAvLyBtYXkgZ2V0IHNraXBwZWQgaWYgMCBtaXhpblxyXG5cdGNvbnN0cnVjdGluZ1RyYW5zYWN0aW9uOiA0LCAvLyBtYXkgZ28gYmFjayB0byAuY2FsY3VsYXRpbmdGZWVcclxuXHRzdWJtaXR0aW5nVHJhbnNhY3Rpb246IDUsXHJcbn07XHJcbmV4cG9ydHMuU2VuZEZ1bmRzX1Byb2Nlc3NTdGVwX0NvZGUgPSBTZW5kRnVuZHNfUHJvY2Vzc1N0ZXBfQ29kZTtcclxuY29uc3QgU2VuZEZ1bmRzX1Byb2Nlc3NTdGVwX01lc3NhZ2VTdWZmaXggPSB7XHJcblx0MTogXCJGZXRjaGluZyBsYXRlc3QgYmFsYW5jZS5cIixcclxuXHQyOiBcIkNhbGN1bGF0aW5nIGZlZS5cIixcclxuXHQzOiBcIkZldGNoaW5nIGRlY295IG91dHB1dHMuXCIsXHJcblx0NDogXCJDb25zdHJ1Y3RpbmcgdHJhbnNhY3Rpb24uXCIsIC8vIG1heSBnbyBiYWNrIHRvIC5jYWxjdWxhdGluZ0ZlZVxyXG5cdDU6IFwiU3VibWl0dGluZyB0cmFuc2FjdGlvbi5cIixcclxufTtcclxuZXhwb3J0cy5TZW5kRnVuZHNfUHJvY2Vzc1N0ZXBfTWVzc2FnZVN1ZmZpeCA9IFNlbmRGdW5kc19Qcm9jZXNzU3RlcF9NZXNzYWdlU3VmZml4O1xyXG4vL1xyXG5mdW5jdGlvbiBTZW5kRnVuZHMoIC8vIFRPRE86IG1pZ3JhdGUgdGhpcyB0byB0YWtlIGEgbWFwIG9mIGFyZ3NcclxuXHR0YXJnZXRfYWRkcmVzcywgLy8gY3VycmVuY3ktcmVhZHkgd2FsbGV0IGFkZHJlc3MsIGJ1dCBub3QgYW4gT0EgYWRkcmVzcyAocmVzb2x2ZSBiZWZvcmUgY2FsbGluZylcclxuXHRuZXR0eXBlLFxyXG5cdGFtb3VudF9vclplcm9XaGVuU3dlZXAsIC8vIG51bWJlciAtIHZhbHVlIHdpbGwgYmUgaWdub3JpbmcgZm9yIHN3ZWVwXHJcblx0aXNTd2VlcF9vclplcm9XaGVuQW1vdW50LCAvLyBzZW5kIHRydWUgdG8gc3dlZXAgLSBhbW91bnRfb3JaZXJvV2hlblN3ZWVwIHdpbGwgYmUgaWdub3JlZFxyXG5cdHdhbGxldF9fcHVibGljX2FkZHJlc3MsXHJcblx0d2FsbGV0X19wcml2YXRlX2tleXMsXHJcblx0d2FsbGV0X19wdWJsaWNfa2V5cyxcclxuXHRob3N0ZWRNb25lcm9BUElDbGllbnQsIC8vIFRPRE86IHBvc3NpYmx5IGZhY3RvciB0aGlzIGRlcGVuZGVuY3lcclxuXHRwYXltZW50X2lkLFxyXG5cdHNpbXBsZV9wcmlvcml0eSxcclxuXHRwcmVTdWNjZXNzX25vblRlcm1pbmFsX3N0YXR1c1VwZGF0ZV9mbiwgLy8gKF8gc3RlcENvZGU6IFNlbmRGdW5kc19Qcm9jZXNzU3RlcF9Db2RlKSAtPiBWb2lkXHJcblx0c3VjY2Vzc19mbixcclxuXHQvLyBzdWNjZXNzX2ZuOiAoIC8vIFRPRE86IHRvIGJlIG1pZ3JhdGVkIHRvIGFyZ3MgYXMgcmV0dXJuIG9ialxyXG5cdC8vXHRcdG1vbmVyb1JlYWR5X3RhcmdldERlc2NyaXB0aW9uX2FkZHJlc3M/LFxyXG5cdC8vXHRcdHNlbnRBbW91bnQ/LFxyXG5cdC8vXHRcdGZpbmFsX19wYXltZW50X2lkPyxcclxuXHQvL1x0XHR0eF9oYXNoPyxcclxuXHQvL1x0XHR0eF9mZWU/LFxyXG5cdC8vXHRcdHR4X2tleT8sXHJcblx0Ly9cdFx0bWl4aW4/LFxyXG5cdC8vIClcclxuXHRmYWlsV2l0aEVycl9mblxyXG5cdC8vIGZhaWxXaXRoRXJyX2ZuOiAoXHJcblx0Ly9cdFx0ZXJyXHJcblx0Ly8gKVxyXG4pIHtcclxuXHRtb25lcm9fdXRpbHNfcHJvbWlzZS50aGVuKGZ1bmN0aW9uKG1vbmVyb191dGlscylcclxuXHR7XHJcblx0XHRjb25zdCBtaXhpbiA9IGZpeGVkTWl4aW4oKTsgLy8gd291bGQgYmUgbmljZSB0byBlbGltaW5hdGUgdGhpcyBkZXBlbmRlbmN5IG9yIGdyYWIgaXQgZnJvbSBDKytcclxuXHRcdC8vXHJcblx0XHQvLyBzb21lIGNhbGxiYWNrIHRyYW1wb2xpbmUgZnVuY3Rpb24gZGVjbGFyYXRpb25z4oCmXHJcblx0XHRmdW5jdGlvbiBfX3RyYW1wb2xpbmVGb3JfZXJyX3dpdGhFcnIoZXJyKSB7XHJcblx0XHRcdGZhaWxXaXRoRXJyX2ZuKGVycik7XHJcblx0XHR9XHJcblx0XHRmdW5jdGlvbiBfX3RyYW1wb2xpbmVGb3JfZXJyX3dpdGhTdHIoZXJyU3RyKSB7XHJcblx0XHRcdGNvbnN0IGVyciA9IG5ldyBFcnJvcihlcnJTdHIpO1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKGVyclN0cik7XHJcblx0XHRcdGZhaWxXaXRoRXJyX2ZuKGVycik7XHJcblx0XHR9XHJcblx0XHQvL1xyXG5cdFx0dmFyIHN3ZWVwaW5nID0gaXNTd2VlcF9vclplcm9XaGVuQW1vdW50ID09PSB0cnVlOyAvLyByYXRoZXIgdGhhbiwgc2F5LCB1bmRlZmluZWRcclxuXHRcdHZhciBhbW91bnQgPSBcIlwiICsgKHN3ZWVwaW5nID8gMCA6IGFtb3VudF9vclplcm9XaGVuU3dlZXApOyAvL1RPRE8ganVzdCBzZW5kIHN0cmluZ1xyXG5cdFx0dmFyIHNlbmRpbmdfYW1vdW50OyAvLyBwb3NzaWJseSBuZWVkIHRoaXMgOyBoZXJlIGZvciB0aGUgSlMgcGFyc2VyXHJcblx0XHRpZiAoc3dlZXBpbmcpIHtcclxuXHRcdFx0c2VuZGluZ19hbW91bnQgPSAwXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdHNlbmRpbmdfYW1vdW50ID0gbW9uZXJvX2Ftb3VudF9mb3JtYXRfdXRpbHMucGFyc2VNb25leShhbW91bnQpO1xyXG5cdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0X190cmFtcG9saW5lRm9yX2Vycl93aXRoU3RyKGBDb3VsZG4ndCBwYXJzZSBhbW91bnQgJHthbW91bnR9OiAke2V9YCk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHQvL1xyXG5cdFx0Ly8gVE9ETzpcclxuXHRcdC8vIGNvbnN0IHdhbGxldF9fcHVibGljX2tleXMgPSBkZWNvZGVfYWRkcmVzcyhmcm9tX2FkZHJlc3MsIG5ldHR5cGUpO1xyXG5cdFx0Ly9cclxuXHRcdHByZVN1Y2Nlc3Nfbm9uVGVybWluYWxfc3RhdHVzVXBkYXRlX2ZuKFNlbmRGdW5kc19Qcm9jZXNzU3RlcF9Db2RlLmZldGNoaW5nTGF0ZXN0QmFsYW5jZSk7XHJcblx0XHR2YXIgZmVlX3Blcl9iX19zdHJpbmc7XHJcblx0XHR2YXIgdW5zcGVudF9vdXRzOyBcclxuXHRcdGhvc3RlZE1vbmVyb0FQSUNsaWVudC5VbnNwZW50T3V0cyhcclxuXHRcdFx0d2FsbGV0X19wdWJsaWNfYWRkcmVzcyxcclxuXHRcdFx0d2FsbGV0X19wcml2YXRlX2tleXMudmlldyxcclxuXHRcdFx0d2FsbGV0X19wdWJsaWNfa2V5cy5zcGVuZCxcclxuXHRcdFx0d2FsbGV0X19wcml2YXRlX2tleXMuc3BlbmQsXHJcblx0XHRcdG1peGluLFxyXG5cdFx0XHRzd2VlcGluZyxcclxuXHRcdFx0ZnVuY3Rpb24oZXJyLCByZXR1cm5lZF91bnVzZWRPdXRzLCBwZXJfYnl0ZV9mZWVfX3N0cmluZylcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGlmIChlcnIpIHtcclxuXHRcdFx0XHRcdF9fdHJhbXBvbGluZUZvcl9lcnJfd2l0aEVycihlcnIpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjb25zb2xlLmxvZyhcIlJlY2VpdmVkIGR5bmFtaWMgcGVyIGtiIGZlZVwiLCBtb25lcm9fYW1vdW50X2Zvcm1hdF91dGlscy5mb3JtYXRNb25leVN5bWJvbChuZXcgSlNCaWdJbnQocGVyX2J5dGVfZmVlX19zdHJpbmcpKSk7XHJcblx0XHRcdFx0eyAvLyBzYXZlIHNvbWUgdmFsdWVzIGZvciByZS1lbnRlcmFibGUgZnVuY3Rpb25cclxuXHRcdFx0XHRcdHVuc3BlbnRfb3V0cyA9IHJldHVybmVkX3VudXNlZE91dHM7IC8vIFRPRE86IHdoaWNoIG9uZSBzaG91bGQgYmUgdXNlZD8gZGVsZXRlIHRoZSBvdGhlclxyXG5cdFx0XHRcdFx0ZmVlX3Blcl9iX19zdHJpbmcgPSBwZXJfYnl0ZV9mZWVfX3N0cmluZzsgXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdF9fcmVlbnRlcmFibGVfY29uc3RydWN0QW5kU2VuZFR4KFxyXG5cdFx0XHRcdFx0bnVsbCwgLy8gZm9yIHRoZSBmaXJzdCB0cnkgLSBwYXNzZWRJbl9hdHRlbXB0QXRfbmV0d29ya19taW5pbXVtRmVlXHJcblx0XHRcdFx0XHQxXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fVxyXG5cdFx0KTtcclxuXHRcdGZ1bmN0aW9uIF9fcmVlbnRlcmFibGVfY29uc3RydWN0QW5kU2VuZFR4KG9wdGxfX3Bhc3NlZEluX2F0dGVtcHRBdF9mZWUsIGNvbnN0cnVjdGlvbkF0dGVtcHQpXHJcblx0XHR7XHJcblx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIGVzdGFibGlzaCBzb21lIHZhbHVlcyBmb3IgYmFsYW5jZSB2YWxpZGF0aW9uIGFuZCB0byBjb25zdHJ1Y3QgdGhlIHRyYW5zYWN0aW9uXHJcblx0XHRcdHByZVN1Y2Nlc3Nfbm9uVGVybWluYWxfc3RhdHVzVXBkYXRlX2ZuKFNlbmRGdW5kc19Qcm9jZXNzU3RlcF9Db2RlLmNhbGN1bGF0aW5nRmVlKTtcclxuXHRcdFx0dmFyIHN0ZXAxX3JldFZhbHM7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0c3RlcDFfcmV0VmFscyA9IG1vbmVyb191dGlscy5zZW5kX3N0ZXAxX19wcmVwYXJlX3BhcmFtc19mb3JfZ2V0X2RlY295cyhcclxuXHRcdFx0XHRcdHN3ZWVwaW5nLFxyXG5cdFx0XHRcdFx0c2VuZGluZ19hbW91bnQudG9TdHJpbmcoKSwgLy8gbXVzdCBiZSBhIHN0cmluZ1xyXG5cdFx0XHRcdFx0ZmVlX3Blcl9iX19zdHJpbmcsXHJcblx0XHRcdFx0XHRzaW1wbGVfcHJpb3JpdHksXHJcblx0XHRcdFx0XHR1bnNwZW50X291dHMsXHJcblx0XHRcdFx0XHRwYXltZW50X2lkLCAvLyBtYXkgYmUgbmlsXHJcblx0XHRcdFx0XHRvcHRsX19wYXNzZWRJbl9hdHRlbXB0QXRfZmVlXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRcdHZhciBlcnJTdHI7XHJcblx0XHRcdFx0aWYgKGUpIHtcclxuXHRcdFx0XHRcdGVyclN0ciA9IHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBlIDogZS50b1N0cmluZygpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRlcnJTdHIgPSBcIkZhaWxlZCB0byBjcmVhdGUgdHJhbnNhY3Rpb24gKHN0ZXAgMSkgd2l0aCB1bmtub3duIGVycm9yLlwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRfX3RyYW1wb2xpbmVGb3JfZXJyX3dpdGhTdHIoZXJyU3RyKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0Ly9cclxuXHRcdFx0Ly8gcHJlcCBmb3Igc3RlcDJcclxuXHRcdFx0Ly8gZmlyc3QsIGdyYWIgUmFuZG9tT3V0cywgdGhlbiBlbnRlciBzdGVwMlxyXG5cdFx0XHRwcmVTdWNjZXNzX25vblRlcm1pbmFsX3N0YXR1c1VwZGF0ZV9mbihTZW5kRnVuZHNfUHJvY2Vzc1N0ZXBfQ29kZS5mZXRjaGluZ0RlY295T3V0cHV0cyk7XHJcblx0XHRcdGhvc3RlZE1vbmVyb0FQSUNsaWVudC5SYW5kb21PdXRzKFxyXG5cdFx0XHRcdHN0ZXAxX3JldFZhbHMudXNpbmdfb3V0cywgXHJcblx0XHRcdFx0c3RlcDFfcmV0VmFscy5taXhpbiwgXHJcblx0XHRcdFx0ZnVuY3Rpb24oZXJyLCBtaXhfb3V0cylcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRpZiAoZXJyKSB7XHJcblx0XHRcdFx0XHRcdF9fdHJhbXBvbGluZUZvcl9lcnJfd2l0aEVycihlcnIpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRfX19jcmVhdGVUeEFuZEF0dGVtcHRUb1NlbmQobWl4X291dHMpOyBcclxuXHRcdFx0XHR9XHJcblx0XHRcdCk7XHJcblx0XHRcdGZ1bmN0aW9uIF9fX2NyZWF0ZVR4QW5kQXR0ZW1wdFRvU2VuZChtaXhfb3V0cykgXHJcblx0XHRcdHtcclxuXHRcdFx0XHRwcmVTdWNjZXNzX25vblRlcm1pbmFsX3N0YXR1c1VwZGF0ZV9mbihTZW5kRnVuZHNfUHJvY2Vzc1N0ZXBfQ29kZS5jb25zdHJ1Y3RpbmdUcmFuc2FjdGlvbik7XHJcblx0XHRcdFx0dmFyIHN0ZXAyX3JldFZhbHM7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdHN0ZXAyX3JldFZhbHMgPSBtb25lcm9fdXRpbHMuc2VuZF9zdGVwMl9fdHJ5X2NyZWF0ZV90cmFuc2FjdGlvbihcclxuXHRcdFx0XHRcdFx0d2FsbGV0X19wdWJsaWNfYWRkcmVzcyxcclxuXHRcdFx0XHRcdFx0d2FsbGV0X19wcml2YXRlX2tleXMsXHJcblx0XHRcdFx0XHRcdHRhcmdldF9hZGRyZXNzLFxyXG5cdFx0XHRcdFx0XHRzdGVwMV9yZXRWYWxzLnVzaW5nX291dHMsIC8vIGFibGUgdG8gcmVhZCB0aGlzIGRpcmVjdGx5IGZyb20gc3RlcDEgSlNPTlxyXG5cdFx0XHRcdFx0XHRtaXhfb3V0cyxcclxuXHRcdFx0XHRcdFx0c3RlcDFfcmV0VmFscy5taXhpbixcclxuXHRcdFx0XHRcdFx0c3RlcDFfcmV0VmFscy5maW5hbF90b3RhbF93b19mZWUsXHJcblx0XHRcdFx0XHRcdHN0ZXAxX3JldFZhbHMuY2hhbmdlX2Ftb3VudCxcclxuXHRcdFx0XHRcdFx0c3RlcDFfcmV0VmFscy51c2luZ19mZWUsXHJcblx0XHRcdFx0XHRcdHBheW1lbnRfaWQsIFxyXG5cdFx0XHRcdFx0XHRzaW1wbGVfcHJpb3JpdHksXHJcblx0XHRcdFx0XHRcdGZlZV9wZXJfYl9fc3RyaW5nLFxyXG5cdFx0XHRcdFx0XHQwLCAvLyB1bmxvY2sgdGltZVxyXG5cdFx0XHRcdFx0XHRuZXR0eXBlXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0XHRcdHZhciBlcnJTdHI7XHJcblx0XHRcdFx0XHRpZiAoZSkge1xyXG5cdFx0XHRcdFx0XHRlcnJTdHIgPSB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gZSA6IGUudG9TdHJpbmcoKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGVyclN0ciA9IFwiRmFpbGVkIHRvIGNyZWF0ZSB0cmFuc2FjdGlvbiAoc3RlcCAyKSB3aXRoIHVua25vd24gZXJyb3IuXCI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRfX3RyYW1wb2xpbmVGb3JfZXJyX3dpdGhTdHIoZXJyU3RyKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHR5cGVvZiBzdGVwMl9yZXRWYWxzLmVycl9tc2cgIT09ICd1bmRlZmluZWQnICYmIHN0ZXAyX3JldFZhbHMuZXJyX21zZykgeyAvLyBhY3R1YWxseSBub3QgZXhwZWN0aW5nIHRoaXMhIGJ1dCBqdXN0IGluIGNhc2UuLlxyXG5cdFx0XHRcdFx0X190cmFtcG9saW5lRm9yX2Vycl93aXRoU3RyKHN0ZXAyX3JldFZhbHMuZXJyX21zZyk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIGlmIHdlIG5lZWQgYSBoaWdoZXIgZmVlXHJcblx0XHRcdFx0aWYgKHN0ZXAyX3JldFZhbHMudHhfbXVzdF9iZV9yZWNvbnN0cnVjdGVkID09PSB0cnVlIHx8IHN0ZXAyX3JldFZhbHMudHhfbXVzdF9iZV9yZWNvbnN0cnVjdGVkID09PSBcInRydWVcIikgeyAvLyBUT0RPXHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIk5lZWQgdG8gcmVjb25zdHJ1Y3QgdGhlIHR4IHdpdGggZW5vdWdoIG9mIGEgbmV0d29yayBmZWVcIik7XHJcblx0XHRcdFx0XHQvLyB0aGlzIHdpbGwgdXBkYXRlIHN0YXR1cyBiYWNrIHRvIC5jYWxjdWxhdGluZ0ZlZVxyXG5cdFx0XHRcdFx0aWYgKGNvbnN0cnVjdGlvbkF0dGVtcHQgPiAzMCkgeyAvLyBqdXN0IGdvaW5nIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AgaGVyZVxyXG5cdFx0XHRcdFx0XHRfX3RyYW1wb2xpbmVGb3JfZXJyX3dpdGhTdHIoXCJVbmFibGUgdG8gY29uc3RydWN0IGEgdHJhbnNhY3Rpb24gd2l0aCBzdWZmaWNpZW50IGZlZSBmb3IgdW5rbm93biByZWFzb24uXCIpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRfX3JlZW50ZXJhYmxlX2NvbnN0cnVjdEFuZFNlbmRUeChcclxuXHRcdFx0XHRcdFx0c3RlcDJfcmV0VmFscy5mZWVfYWN0dWFsbHlfbmVlZGVkLCAvLyB3ZSBhcmUgcmUtZW50ZXJpbmcgdGhlIHN0ZXAxLT5zdGVwMiBjb2RlcGF0aCBhZnRlciB1cGRhdGluZyBmZWVfYWN0dWFsbHlfbmVlZGVkXHJcblx0XHRcdFx0XHRcdGNvbnN0cnVjdGlvbkF0dGVtcHQgKyAxXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyBHZW5lcmF0ZWQgd2l0aCBjb3JyZWN0IGZlZVxyXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwidHggc2VyaWFsaXplZDogXCIgKyBzdGVwMl9yZXRWYWxzLnNpZ25lZF9zZXJpYWxpemVkX3R4KTtcclxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIlR4IGhhc2g6IFwiICsgc3RlcDJfcmV0VmFscy50eF9oYXNoKTtcclxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIlR4IGtleTogXCIgKyBzdGVwMl9yZXRWYWxzLnR4X2tleSk7XHJcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJTdWNjZXNzZnVsIHR4IGdlbmVyYXRpb247IHN1Ym1pdHRpbmcuXCIpO1xyXG5cdFx0XHRcdC8vIHN0YXR1czogc3VibWl0dGluZ+KAplxyXG5cdFx0XHRcdHByZVN1Y2Nlc3Nfbm9uVGVybWluYWxfc3RhdHVzVXBkYXRlX2ZuKFNlbmRGdW5kc19Qcm9jZXNzU3RlcF9Db2RlLnN1Ym1pdHRpbmdUcmFuc2FjdGlvbik7XHJcblx0XHRcdFx0aG9zdGVkTW9uZXJvQVBJQ2xpZW50LlN1Ym1pdFNlcmlhbGl6ZWRTaWduZWRUcmFuc2FjdGlvbihcclxuXHRcdFx0XHRcdHdhbGxldF9fcHVibGljX2FkZHJlc3MsXHJcblx0XHRcdFx0XHR3YWxsZXRfX3ByaXZhdGVfa2V5cy52aWV3LFxyXG5cdFx0XHRcdFx0c3RlcDJfcmV0VmFscy5zaWduZWRfc2VyaWFsaXplZF90eCxcclxuXHRcdFx0XHRcdGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRcdFx0XHRpZiAoZXJyKSB7XHJcblx0XHRcdFx0XHRcdFx0X190cmFtcG9saW5lRm9yX2Vycl93aXRoU3RyKFwiU29tZXRoaW5nIHVuZXhwZWN0ZWQgb2NjdXJyZWQgd2hlbiBzdWJtaXR0aW5nIHlvdXIgdHJhbnNhY3Rpb246IFwiICsgZXJyKTtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0Y29uc3QgZmluYWxfZmVlX2Ftb3VudCA9IG5ldyBKU0JpZ0ludChzdGVwMV9yZXRWYWxzLnVzaW5nX2ZlZSlcclxuXHRcdFx0XHRcdFx0Y29uc3QgZmluYWxUb3RhbFdPRmVlX2Ftb3VudCA9IG5ldyBKU0JpZ0ludChzdGVwMV9yZXRWYWxzLmZpbmFsX3RvdGFsX3dvX2ZlZSlcclxuXHRcdFx0XHRcdFx0dmFyIGZpbmFsX19wYXltZW50X2lkID0gcGF5bWVudF9pZDtcclxuXHRcdFx0XHRcdFx0aWYgKGZpbmFsX19wYXltZW50X2lkID09PSBudWxsIHx8IHR5cGVvZiBmaW5hbF9fcGF5bWVudF9pZCA9PSBcInVuZGVmaW5lZFwiIHx8ICFmaW5hbF9fcGF5bWVudF9pZCkge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGRlY29kZWQgID0gbW9uZXJvX3V0aWxzLmRlY29kZV9hZGRyZXNzKHRhcmdldF9hZGRyZXNzLCBuZXR0eXBlKTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoZGVjb2RlZC5pbnRQYXltZW50SWQgJiYgdHlwZW9mIGRlY29kZWQuaW50UGF5bWVudElkICE9PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdFx0XHRcdFx0ZmluYWxfX3BheW1lbnRfaWQgPSBkZWNvZGVkLmludFBheW1lbnRJZCAvLyBqdXN0IHByZXNlcnZpbmcgb3JpZ2luYWwgcmV0dXJuIHZhbHVlIC0gdGhpcyByZXRWYWwgY2FuIGV2ZW50dWFsbHkgYmUgcmVtb3ZlZFxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRzdWNjZXNzX2ZuKCAvLyBUT0RPOiBwb3J0IHRoaXMgdG8gcmV0dXJuaW5nIGEgZGljdGlvbmFyeVxyXG5cdFx0XHRcdFx0XHRcdHRhcmdldF9hZGRyZXNzLCAvLyBUT0RPOiByZW1vdmUgdGhpc1xyXG5cdFx0XHRcdFx0XHRcdGZpbmFsVG90YWxXT0ZlZV9hbW91bnQuYWRkKGZpbmFsX2ZlZV9hbW91bnQpLCAvLyB0b3RhbCBzZW50XHJcblx0XHRcdFx0XHRcdFx0ZmluYWxfX3BheW1lbnRfaWQsIFxyXG5cdFx0XHRcdFx0XHRcdHN0ZXAyX3JldFZhbHMudHhfaGFzaCxcclxuXHRcdFx0XHRcdFx0XHRmaW5hbF9mZWVfYW1vdW50LFxyXG5cdFx0XHRcdFx0XHRcdHN0ZXAyX3JldFZhbHMudHhfa2V5LFxyXG5cdFx0XHRcdFx0XHRcdHBhcnNlSW50KHN0ZXAxX3JldFZhbHMubWl4aW4pXHJcblx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHJcbmV4cG9ydHMuU2VuZEZ1bmRzID0gU2VuZEZ1bmRzOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_sendingFunds_utils.js\n");

/***/ }),

/***/ "./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_txParsing_utils.js":
/*!****************************************************************************************************!*\
  !*** ./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_txParsing_utils.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2014-2018, MyMonero.com\r\n//\r\n// All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without modification, are\r\n// permitted provided that the following conditions are met:\r\n//\r\n// 1. Redistributions of source code must retain the above copyright notice, this list of\r\n//\tconditions and the following disclaimer.\r\n//\r\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list\r\n//\tof conditions and the following disclaimer in the documentation and/or other\r\n//\tmaterials provided with the distribution.\r\n//\r\n// 3. Neither the name of the copyright holder nor the names of its contributors may be\r\n//\tused to endorse or promote products derived from this software without specific\r\n//\tprior written permission.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\r\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\r\n// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\r\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n//\r\n\r\n//\r\nconst monero_config = __webpack_require__(/*! ./monero_config */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_config.js\");\r\nconst moment = __webpack_require__(/*! ../cryptonote_utils/moment */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/cryptonote_utils/moment.js\")\r\n//\r\nfunction IsTransactionConfirmed(tx, blockchain_height) \r\n{\r\n\t// TODO: check tx.mempool here?\r\n\tif (tx.height === null || typeof tx.height == 'undefined') {\r\n\t\treturn false // supposing it hasn't made it into a block yet\r\n\t}\r\n\treturn blockchain_height - tx.height > monero_config.txMinConfirms;\r\n}\r\nexports.IsTransactionConfirmed = IsTransactionConfirmed;\r\n//\r\nfunction IsTransactionUnlocked(tx, blockchain_height) {\r\n\tconst unlock_time = tx.unlock_time || 0;\r\n\tif (!monero_config.maxBlockNumber) {\r\n\t\tthrow \"Max block number is not set in config!\";\r\n\t}\r\n\tif (unlock_time < monero_config.maxBlockNumber) {\r\n\t\t// unlock time is block height\r\n\t\treturn blockchain_height >= unlock_time;\r\n\t} else {\r\n\t\t// unlock time is timestamp\r\n\t\tvar current_time = Math.round(new Date().getTime() / 1000);\r\n\t\treturn current_time >= unlock_time;\r\n\t}\r\n}\r\nexports.IsTransactionUnlocked = IsTransactionUnlocked;\r\n//\r\nfunction TransactionLockedReason(tx, blockchain_height)\r\n{\r\n\tconst unlock_time = tx.unlock_time || 0;\r\n\tif (unlock_time < monero_config.maxBlockNumber) {\r\n\t\t// unlock time is block height\r\n\t\tvar numBlocks = unlock_time - blockchain_height;\r\n\t\tif (numBlocks <= 0) {\r\n\t\t\treturn \"Transaction is unlocked\";\r\n\t\t}\r\n\t\tvar unlock_prediction = moment().add(\r\n\t\t\tnumBlocks * monero_config.avgBlockTime,\r\n\t\t\t\"seconds\"\r\n\t\t);\r\n\t\treturn (\r\n\t\t\t\"Will be unlocked in \" +\r\n\t\t\tnumBlocks +\r\n\t\t\t\" blocks, ~\" +\r\n\t\t\tunlock_prediction.fromNow(true) +\r\n\t\t\t\", \" +\r\n\t\t\tunlock_prediction.calendar() +\r\n\t\t\t\"\"\r\n\t\t);\r\n\t} else {\r\n\t\t// unlock time is timestamp\r\n\t\tvar current_time = Math.round(new Date().getTime() / 1000);\r\n\t\tvar time_difference = unlock_time - current_time;\r\n\t\tif (time_difference <= 0) {\r\n\t\t\treturn \"Transaction is unlocked\";\r\n\t\t}\r\n\t\tvar unlock_moment = moment(unlock_time * 1000);\r\n\t\treturn (\r\n\t\t\t\"Will be unlocked \" +\r\n\t\t\tunlock_moment.fromNow() +\r\n\t\t\t\", \" +\r\n\t\t\tunlock_moment.calendar()\r\n\t\t);\r\n\t}\r\n}\r\nexports.TransactionLockedReason = TransactionLockedReason;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvbW9uZXJvX3V0aWxzL21vbmVyb190eFBhcnNpbmdfdXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvbW9uZXJvX3V0aWxzL21vbmVyb190eFBhcnNpbmdfdXRpbHMuanM/YWQ4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxOCwgTXlNb25lcm8uY29tXHJcbi8vXHJcbi8vIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vXHJcbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZVxyXG4vLyBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuLy9cclxuLy8gMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2ZcclxuLy9cdGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuLy9cclxuLy8gMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3RcclxuLy9cdG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXJcclxuLy9cdG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbi8vXHJcbi8vIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGNvcHlyaWdodCBob2xkZXIgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZVxyXG4vL1x0dXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xyXG4vL1x0cHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4vL1xyXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkQgQU5ZXHJcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRlxyXG4vLyBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTFxyXG4vLyBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcclxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxyXG4vLyBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcclxuLy8gSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsXHJcbi8vIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxyXG4vLyBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbi8vXHJcblwidXNlIHN0cmljdFwiO1xyXG4vL1xyXG5jb25zdCBtb25lcm9fY29uZmlnID0gcmVxdWlyZShcIi4vbW9uZXJvX2NvbmZpZ1wiKTtcclxuY29uc3QgbW9tZW50ID0gcmVxdWlyZShcIi4uL2NyeXB0b25vdGVfdXRpbHMvbW9tZW50XCIpXHJcbi8vXHJcbmZ1bmN0aW9uIElzVHJhbnNhY3Rpb25Db25maXJtZWQodHgsIGJsb2NrY2hhaW5faGVpZ2h0KSBcclxue1xyXG5cdC8vIFRPRE86IGNoZWNrIHR4Lm1lbXBvb2wgaGVyZT9cclxuXHRpZiAodHguaGVpZ2h0ID09PSBudWxsIHx8IHR5cGVvZiB0eC5oZWlnaHQgPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdHJldHVybiBmYWxzZSAvLyBzdXBwb3NpbmcgaXQgaGFzbid0IG1hZGUgaXQgaW50byBhIGJsb2NrIHlldFxyXG5cdH1cclxuXHRyZXR1cm4gYmxvY2tjaGFpbl9oZWlnaHQgLSB0eC5oZWlnaHQgPiBtb25lcm9fY29uZmlnLnR4TWluQ29uZmlybXM7XHJcbn1cclxuZXhwb3J0cy5Jc1RyYW5zYWN0aW9uQ29uZmlybWVkID0gSXNUcmFuc2FjdGlvbkNvbmZpcm1lZDtcclxuLy9cclxuZnVuY3Rpb24gSXNUcmFuc2FjdGlvblVubG9ja2VkKHR4LCBibG9ja2NoYWluX2hlaWdodCkge1xyXG5cdGNvbnN0IHVubG9ja190aW1lID0gdHgudW5sb2NrX3RpbWUgfHwgMDtcclxuXHRpZiAoIW1vbmVyb19jb25maWcubWF4QmxvY2tOdW1iZXIpIHtcclxuXHRcdHRocm93IFwiTWF4IGJsb2NrIG51bWJlciBpcyBub3Qgc2V0IGluIGNvbmZpZyFcIjtcclxuXHR9XHJcblx0aWYgKHVubG9ja190aW1lIDwgbW9uZXJvX2NvbmZpZy5tYXhCbG9ja051bWJlcikge1xyXG5cdFx0Ly8gdW5sb2NrIHRpbWUgaXMgYmxvY2sgaGVpZ2h0XHJcblx0XHRyZXR1cm4gYmxvY2tjaGFpbl9oZWlnaHQgPj0gdW5sb2NrX3RpbWU7XHJcblx0fSBlbHNlIHtcclxuXHRcdC8vIHVubG9jayB0aW1lIGlzIHRpbWVzdGFtcFxyXG5cdFx0dmFyIGN1cnJlbnRfdGltZSA9IE1hdGgucm91bmQobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKTtcclxuXHRcdHJldHVybiBjdXJyZW50X3RpbWUgPj0gdW5sb2NrX3RpbWU7XHJcblx0fVxyXG59XHJcbmV4cG9ydHMuSXNUcmFuc2FjdGlvblVubG9ja2VkID0gSXNUcmFuc2FjdGlvblVubG9ja2VkO1xyXG4vL1xyXG5mdW5jdGlvbiBUcmFuc2FjdGlvbkxvY2tlZFJlYXNvbih0eCwgYmxvY2tjaGFpbl9oZWlnaHQpXHJcbntcclxuXHRjb25zdCB1bmxvY2tfdGltZSA9IHR4LnVubG9ja190aW1lIHx8IDA7XHJcblx0aWYgKHVubG9ja190aW1lIDwgbW9uZXJvX2NvbmZpZy5tYXhCbG9ja051bWJlcikge1xyXG5cdFx0Ly8gdW5sb2NrIHRpbWUgaXMgYmxvY2sgaGVpZ2h0XHJcblx0XHR2YXIgbnVtQmxvY2tzID0gdW5sb2NrX3RpbWUgLSBibG9ja2NoYWluX2hlaWdodDtcclxuXHRcdGlmIChudW1CbG9ja3MgPD0gMCkge1xyXG5cdFx0XHRyZXR1cm4gXCJUcmFuc2FjdGlvbiBpcyB1bmxvY2tlZFwiO1xyXG5cdFx0fVxyXG5cdFx0dmFyIHVubG9ja19wcmVkaWN0aW9uID0gbW9tZW50KCkuYWRkKFxyXG5cdFx0XHRudW1CbG9ja3MgKiBtb25lcm9fY29uZmlnLmF2Z0Jsb2NrVGltZSxcclxuXHRcdFx0XCJzZWNvbmRzXCJcclxuXHRcdCk7XHJcblx0XHRyZXR1cm4gKFxyXG5cdFx0XHRcIldpbGwgYmUgdW5sb2NrZWQgaW4gXCIgK1xyXG5cdFx0XHRudW1CbG9ja3MgK1xyXG5cdFx0XHRcIiBibG9ja3MsIH5cIiArXHJcblx0XHRcdHVubG9ja19wcmVkaWN0aW9uLmZyb21Ob3codHJ1ZSkgK1xyXG5cdFx0XHRcIiwgXCIgK1xyXG5cdFx0XHR1bmxvY2tfcHJlZGljdGlvbi5jYWxlbmRhcigpICtcclxuXHRcdFx0XCJcIlxyXG5cdFx0KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gdW5sb2NrIHRpbWUgaXMgdGltZXN0YW1wXHJcblx0XHR2YXIgY3VycmVudF90aW1lID0gTWF0aC5yb3VuZChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApO1xyXG5cdFx0dmFyIHRpbWVfZGlmZmVyZW5jZSA9IHVubG9ja190aW1lIC0gY3VycmVudF90aW1lO1xyXG5cdFx0aWYgKHRpbWVfZGlmZmVyZW5jZSA8PSAwKSB7XHJcblx0XHRcdHJldHVybiBcIlRyYW5zYWN0aW9uIGlzIHVubG9ja2VkXCI7XHJcblx0XHR9XHJcblx0XHR2YXIgdW5sb2NrX21vbWVudCA9IG1vbWVudCh1bmxvY2tfdGltZSAqIDEwMDApO1xyXG5cdFx0cmV0dXJuIChcclxuXHRcdFx0XCJXaWxsIGJlIHVubG9ja2VkIFwiICtcclxuXHRcdFx0dW5sb2NrX21vbWVudC5mcm9tTm93KCkgK1xyXG5cdFx0XHRcIiwgXCIgK1xyXG5cdFx0XHR1bmxvY2tfbW9tZW50LmNhbGVuZGFyKClcclxuXHRcdCk7XHJcblx0fVxyXG59XHJcbmV4cG9ydHMuVHJhbnNhY3Rpb25Mb2NrZWRSZWFzb24gPSBUcmFuc2FjdGlvbkxvY2tlZFJlYXNvbjtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_txParsing_utils.js\n");

/***/ }),

/***/ "./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_utils.js":
/*!******************************************************************************************!*\
  !*** ./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_utils.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright (c) 2014-2018, MyMonero.com\r\n//\r\n// All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without modification, are\r\n// permitted provided that the following conditions are met:\r\n//\r\n// 1. Redistributions of source code must retain the above copyright notice, this list of\r\n//\tconditions and the following disclaimer.\r\n//\r\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list\r\n//\tof conditions and the following disclaimer in the documentation and/or other\r\n//\tmaterials provided with the distribution.\r\n//\r\n// 3. Neither the name of the copyright holder nor the names of its contributors may be\r\n//\tused to endorse or promote products derived from this software without specific\r\n//\tprior written permission.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\r\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\r\n// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\r\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n//\r\n\r\n//\r\nconst ENVIRONMENT_IS_WEB = typeof window===\"object\";\r\nconst ENVIRONMENT_IS_WORKER = typeof importScripts===\"function\";\r\nconst ENVIRONMENT_IS_NODE = typeof process===\"object\" && process.browser !== true && \"function\"===\"function\" && ENVIRONMENT_IS_WORKER == false; // we want this to be true for Electron but not for a WebView\r\nconst wants_electronRemote = (ENVIRONMENT_IS_NODE&&ENVIRONMENT_IS_WEB)/*this may become insufficient*/\r\n\t|| (typeof window !== 'undefined' && window.IsElectronRendererProcess == true);\r\n//\r\nvar use_asmjs = false;\r\nif (ENVIRONMENT_IS_WEB) {\r\n\tvar hasWebAssembly = false\r\n\ttry {\r\n\t\tif (typeof WebAssembly === \"object\" && typeof WebAssembly.instantiate === \"function\") {\r\n\t\t\tconst module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));\r\n\t\t\tif (module instanceof WebAssembly.Module) {\r\n\t\t\t\tvar isInstance = new WebAssembly.Instance(module) instanceof WebAssembly.Instance;\r\n\t\t\t\tif (isInstance) {\r\n\t\t\t\t\t// TODO: add ios 11 mobile safari bug check to hasWebAssembly\r\n\t\t\t\t}\r\n\t\t\t\t// until then\r\n\t\t\t\thasWebAssembly = isInstance\r\n\t\t\t}\r\n\t\t}\r\n\t} catch (e) {\r\n\t\t// avoiding empty block statement warning..\r\n\t\thasWebAssembly = false // to be clear\r\n\t}\r\n\tuse_asmjs = hasWebAssembly != true\r\n}\r\nconsole.log(\"Using wasm: \", !use_asmjs)\r\n//\r\nconst fn_names = __webpack_require__(/*! ./__bridged_fns_spec */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/__bridged_fns_spec.js\").bridgedFn_names;\r\nconst moneroUtils_promise_fn = function(options)\r\n{\r\n\toptions = options || {}\r\n\t//\r\n\treturn new Promise(function(resolve, reject)\r\n\t{\r\n\t\tfunction _didLoad(coreBridge_instance)\r\n\t\t{\r\n\t\t\tif (coreBridge_instance == null) {\r\n\t\t\t\tthrow \"Unable to make coreBridge_instance\"\r\n\t\t\t}\r\n\t\t\tconst local_fns = {};\r\n\t\t\tfor (const i in fn_names) {\r\n\t\t\t\tconst name = fn_names[i]\r\n\t\t\t\tlocal_fns[name] = function()\r\n\t\t\t\t{\r\n\t\t\t\t\tconst retVal = coreBridge_instance[name].apply(coreBridge_instance, arguments); // called on the cached value\r\n\t\t\t\t\tif (typeof retVal === \"object\") {\r\n\t\t\t\t\t\tconst err_msg = retVal.err_msg\r\n\t\t\t\t\t\tif (typeof err_msg !== 'undefined' && err_msg) {\r\n\t\t\t\t\t\t\tthrow err_msg; // because we can't throw from electron remote w/o killing fn call\r\n\t\t\t\t\t\t\t// ... and because parsing out this err_msg everywhere is sorta inefficient\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn retVal;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlocal_fns.Module = coreBridge_instance.Module;\r\n\t\t\tresolve(local_fns);\r\n\t\t}\r\n\t\tif (wants_electronRemote) {\r\n\t\t\t// Require file again except on the main process ...\r\n\t\t\t// this avoids a host of issues running wasm on the renderer side, \r\n\t\t\t// for right now until we can load such files raw w/o unsafe-eval\r\n\t\t\t// script-src CSP. makes calls synchronous. if that is a perf problem \r\n\t\t\t// we can make API async.\r\n\t\t\t// \r\n\t\t\t// Resolves relative to the entrypoint of the main process.\r\n\t\t\tconst remoteModule = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'electron'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())).remote.require(\r\n\t\t\t\t\"../mymonero_core_js/monero_utils/__IPCSafe_remote_monero_utils\"\r\n\t\t\t);\r\n\t\t\t// Oftentimes this will be ready right away.. somehow.. but just in case.. the readiness\r\n\t\t\t// state promise behavior should be preserved by the following codepath...\r\n\t\t\tvar _try;\r\n\t\t\tfunction __retryAfter(attemptN)\r\n\t\t\t{\r\n\t\t\t\tconsole.warn(\"Checking remote module readiness again after a few ms...\")\r\n\t\t\t\tsetTimeout(function()\r\n\t\t\t\t{\r\n\t\t\t\t\t_try(attemptN + 1)\r\n\t\t\t\t}, 30)\r\n\t\t\t}\r\n\t\t\t_try = function(attemptN)\r\n\t\t\t{\r\n\t\t\t\tif (attemptN > 10000) {\r\n\t\t\t\t\tthrow \"Expected remote module to be ready\"\r\n\t\t\t\t}\r\n\t\t\t\tif (remoteModule.isReady) {\r\n\t\t\t\t\t_didLoad(remoteModule);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t__retryAfter(attemptN)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t_try(0)\r\n\t\t} else {\r\n\t\t\tconst coreBridgeLoading_promise = __webpack_require__(/*! ./MyMoneroCoreBridge */ \"./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/MyMoneroCoreBridge.js\")({ asmjs: use_asmjs });\r\n\t\t\tcoreBridgeLoading_promise.catch(function(e)\r\n\t\t\t{\r\n\t\t\t\tconsole.error(\"Error: \", e);\r\n\t\t\t\t// this may be insufficient being able to throw would be nice\r\n\t\t\t\tif (reject) {\r\n\t\t\t\t\treject(e)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow \"Promise passed no reject function to monero_utils load fn\"\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tcoreBridgeLoading_promise.then(_didLoad);\r\n\t\t}\r\n\t});\r\n}\r\n//\r\n//\r\n// Since we actually are constructing bridge functions we technically have the export ready \r\n// synchronously but that would lose the ability to wait until the core bridge is actually ready.\r\n//\r\n// TODO: in future, possibly return function which takes options instead to support better env.\r\n//\r\nmodule.exports = moneroUtils_promise_fn;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL215bW9uZXJvLWFwcC1qcy9sb2NhbF9tb2R1bGVzL215bW9uZXJvX2NvcmVfanMvbW9uZXJvX3V0aWxzL21vbmVyb191dGlscy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYnMvbXltb25lcm8tYXBwLWpzL2xvY2FsX21vZHVsZXMvbXltb25lcm9fY29yZV9qcy9tb25lcm9fdXRpbHMvbW9uZXJvX3V0aWxzLmpzPzIzZDIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTgsIE15TW9uZXJvLmNvbVxyXG4vL1xyXG4vLyBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vL1xyXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmVcclxuLy8gcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbi8vXHJcbi8vIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mXHJcbi8vXHRjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbi8vXHJcbi8vIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0XHJcbi8vXHRvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyXHJcbi8vXHRtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4vL1xyXG4vLyAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBjb3B5cmlnaHQgaG9sZGVyIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmVcclxuLy9cdHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWNcclxuLy9cdHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuLy9cclxuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EIEFOWVxyXG4vLyBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcclxuLy8gTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTExcclxuLy8gVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXHJcbi8vIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcclxuLy8gUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXHJcbi8vIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxyXG4vLyBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcclxuLy8gVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4vL1xyXG5cInVzZSBzdHJpY3RcIjtcclxuLy9cclxuY29uc3QgRU5WSVJPTk1FTlRfSVNfV0VCID0gdHlwZW9mIHdpbmRvdz09PVwib2JqZWN0XCI7XHJcbmNvbnN0IEVOVklST05NRU5UX0lTX1dPUktFUiA9IHR5cGVvZiBpbXBvcnRTY3JpcHRzPT09XCJmdW5jdGlvblwiO1xyXG5jb25zdCBFTlZJUk9OTUVOVF9JU19OT0RFID0gdHlwZW9mIHByb2Nlc3M9PT1cIm9iamVjdFwiICYmIHByb2Nlc3MuYnJvd3NlciAhPT0gdHJ1ZSAmJiB0eXBlb2YgcmVxdWlyZT09PVwiZnVuY3Rpb25cIiAmJiBFTlZJUk9OTUVOVF9JU19XT1JLRVIgPT0gZmFsc2U7IC8vIHdlIHdhbnQgdGhpcyB0byBiZSB0cnVlIGZvciBFbGVjdHJvbiBidXQgbm90IGZvciBhIFdlYlZpZXdcclxuY29uc3Qgd2FudHNfZWxlY3Ryb25SZW1vdGUgPSAoRU5WSVJPTk1FTlRfSVNfTk9ERSYmRU5WSVJPTk1FTlRfSVNfV0VCKS8qdGhpcyBtYXkgYmVjb21lIGluc3VmZmljaWVudCovXHJcblx0fHwgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5Jc0VsZWN0cm9uUmVuZGVyZXJQcm9jZXNzID09IHRydWUpO1xyXG4vL1xyXG52YXIgdXNlX2FzbWpzID0gZmFsc2U7XHJcbmlmIChFTlZJUk9OTUVOVF9JU19XRUIpIHtcclxuXHR2YXIgaGFzV2ViQXNzZW1ibHkgPSBmYWxzZVxyXG5cdHRyeSB7XHJcblx0XHRpZiAodHlwZW9mIFdlYkFzc2VtYmx5ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRcdGNvbnN0IG1vZHVsZSA9IG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUoVWludDhBcnJheS5vZigweDAsIDB4NjEsIDB4NzMsIDB4NmQsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDApKTtcclxuXHRcdFx0aWYgKG1vZHVsZSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1vZHVsZSkge1xyXG5cdFx0XHRcdHZhciBpc0luc3RhbmNlID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG1vZHVsZSkgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5JbnN0YW5jZTtcclxuXHRcdFx0XHRpZiAoaXNJbnN0YW5jZSkge1xyXG5cdFx0XHRcdFx0Ly8gVE9ETzogYWRkIGlvcyAxMSBtb2JpbGUgc2FmYXJpIGJ1ZyBjaGVjayB0byBoYXNXZWJBc3NlbWJseVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyB1bnRpbCB0aGVu4oCmXHJcblx0XHRcdFx0aGFzV2ViQXNzZW1ibHkgPSBpc0luc3RhbmNlXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvLyBhdm9pZGluZyBlbXB0eSBibG9jayBzdGF0ZW1lbnQgd2FybmluZy4uXHJcblx0XHRoYXNXZWJBc3NlbWJseSA9IGZhbHNlIC8vIHRvIGJlIGNsZWFyXHJcblx0fVxyXG5cdHVzZV9hc21qcyA9IGhhc1dlYkFzc2VtYmx5ICE9IHRydWVcclxufVxyXG5jb25zb2xlLmxvZyhcIlVzaW5nIHdhc206IFwiLCAhdXNlX2FzbWpzKVxyXG4vL1xyXG5jb25zdCBmbl9uYW1lcyA9IHJlcXVpcmUoJy4vX19icmlkZ2VkX2Zuc19zcGVjJykuYnJpZGdlZEZuX25hbWVzO1xyXG5jb25zdCBtb25lcm9VdGlsc19wcm9taXNlX2ZuID0gZnVuY3Rpb24ob3B0aW9ucylcclxue1xyXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XHJcblx0Ly9cclxuXHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KVxyXG5cdHtcclxuXHRcdGZ1bmN0aW9uIF9kaWRMb2FkKGNvcmVCcmlkZ2VfaW5zdGFuY2UpXHJcblx0XHR7XHJcblx0XHRcdGlmIChjb3JlQnJpZGdlX2luc3RhbmNlID09IG51bGwpIHtcclxuXHRcdFx0XHR0aHJvdyBcIlVuYWJsZSB0byBtYWtlIGNvcmVCcmlkZ2VfaW5zdGFuY2VcIlxyXG5cdFx0XHR9XHJcblx0XHRcdGNvbnN0IGxvY2FsX2ZucyA9IHt9O1xyXG5cdFx0XHRmb3IgKGNvbnN0IGkgaW4gZm5fbmFtZXMpIHtcclxuXHRcdFx0XHRjb25zdCBuYW1lID0gZm5fbmFtZXNbaV1cclxuXHRcdFx0XHRsb2NhbF9mbnNbbmFtZV0gPSBmdW5jdGlvbigpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0Y29uc3QgcmV0VmFsID0gY29yZUJyaWRnZV9pbnN0YW5jZVtuYW1lXS5hcHBseShjb3JlQnJpZGdlX2luc3RhbmNlLCBhcmd1bWVudHMpOyAvLyBjYWxsZWQgb24gdGhlIGNhY2hlZCB2YWx1ZVxyXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiByZXRWYWwgPT09IFwib2JqZWN0XCIpIHtcclxuXHRcdFx0XHRcdFx0Y29uc3QgZXJyX21zZyA9IHJldFZhbC5lcnJfbXNnXHJcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YgZXJyX21zZyAhPT0gJ3VuZGVmaW5lZCcgJiYgZXJyX21zZykge1xyXG5cdFx0XHRcdFx0XHRcdHRocm93IGVycl9tc2c7IC8vIGJlY2F1c2Ugd2UgY2FuJ3QgdGhyb3cgZnJvbSBlbGVjdHJvbiByZW1vdGUgdy9vIGtpbGxpbmcgZm4gY2FsbFxyXG5cdFx0XHRcdFx0XHRcdC8vIC4uLiBhbmQgYmVjYXVzZSBwYXJzaW5nIG91dCB0aGlzIGVycl9tc2cgZXZlcnl3aGVyZSBpcyBzb3J0YSBpbmVmZmljaWVudFxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gcmV0VmFsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRsb2NhbF9mbnMuTW9kdWxlID0gY29yZUJyaWRnZV9pbnN0YW5jZS5Nb2R1bGU7XHJcblx0XHRcdHJlc29sdmUobG9jYWxfZm5zKTtcclxuXHRcdH1cclxuXHRcdGlmICh3YW50c19lbGVjdHJvblJlbW90ZSkge1xyXG5cdFx0XHQvLyBSZXF1aXJlIGZpbGUgYWdhaW4gZXhjZXB0IG9uIHRoZSBtYWluIHByb2Nlc3MgLi4uXHJcblx0XHRcdC8vIHRoaXMgYXZvaWRzIGEgaG9zdCBvZiBpc3N1ZXMgcnVubmluZyB3YXNtIG9uIHRoZSByZW5kZXJlciBzaWRlLCBcclxuXHRcdFx0Ly8gZm9yIHJpZ2h0IG5vdyB1bnRpbCB3ZSBjYW4gbG9hZCBzdWNoIGZpbGVzIHJhdyB3L28gdW5zYWZlLWV2YWxcclxuXHRcdFx0Ly8gc2NyaXB0LXNyYyBDU1AuIG1ha2VzIGNhbGxzIHN5bmNocm9ub3VzLiBpZiB0aGF0IGlzIGEgcGVyZiBwcm9ibGVtIFxyXG5cdFx0XHQvLyB3ZSBjYW4gbWFrZSBBUEkgYXN5bmMuXHJcblx0XHRcdC8vIFxyXG5cdFx0XHQvLyBSZXNvbHZlcyByZWxhdGl2ZSB0byB0aGUgZW50cnlwb2ludCBvZiB0aGUgbWFpbiBwcm9jZXNzLlxyXG5cdFx0XHRjb25zdCByZW1vdGVNb2R1bGUgPSByZXF1aXJlKCdlbGVjdHJvbicpLnJlbW90ZS5yZXF1aXJlKFxyXG5cdFx0XHRcdFwiLi4vbXltb25lcm9fY29yZV9qcy9tb25lcm9fdXRpbHMvX19JUENTYWZlX3JlbW90ZV9tb25lcm9fdXRpbHNcIlxyXG5cdFx0XHQpO1xyXG5cdFx0XHQvLyBPZnRlbnRpbWVzIHRoaXMgd2lsbCBiZSByZWFkeSByaWdodCBhd2F5Li4gc29tZWhvdy4uIGJ1dCBqdXN0IGluIGNhc2UuLiB0aGUgcmVhZGluZXNzXHJcblx0XHRcdC8vIHN0YXRlIHByb21pc2UgYmVoYXZpb3Igc2hvdWxkIGJlIHByZXNlcnZlZCBieSB0aGUgZm9sbG93aW5nIGNvZGVwYXRoLi4uXHJcblx0XHRcdHZhciBfdHJ5O1xyXG5cdFx0XHRmdW5jdGlvbiBfX3JldHJ5QWZ0ZXIoYXR0ZW1wdE4pXHJcblx0XHRcdHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oXCJDaGVja2luZyByZW1vdGUgbW9kdWxlIHJlYWRpbmVzcyBhZ2FpbiBhZnRlciBhIGZldyBtcy4uLlwiKVxyXG5cdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdF90cnkoYXR0ZW1wdE4gKyAxKVxyXG5cdFx0XHRcdH0sIDMwKVxyXG5cdFx0XHR9XHJcblx0XHRcdF90cnkgPSBmdW5jdGlvbihhdHRlbXB0TilcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGlmIChhdHRlbXB0TiA+IDEwMDAwKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBcIkV4cGVjdGVkIHJlbW90ZSBtb2R1bGUgdG8gYmUgcmVhZHlcIlxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAocmVtb3RlTW9kdWxlLmlzUmVhZHkpIHtcclxuXHRcdFx0XHRcdF9kaWRMb2FkKHJlbW90ZU1vZHVsZSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdF9fcmV0cnlBZnRlcihhdHRlbXB0TilcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0X3RyeSgwKVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3QgY29yZUJyaWRnZUxvYWRpbmdfcHJvbWlzZSA9IHJlcXVpcmUoJy4vTXlNb25lcm9Db3JlQnJpZGdlJykoeyBhc21qczogdXNlX2FzbWpzIH0pO1xyXG5cdFx0XHRjb3JlQnJpZGdlTG9hZGluZ19wcm9taXNlLmNhdGNoKGZ1bmN0aW9uKGUpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKFwiRXJyb3I6IFwiLCBlKTtcclxuXHRcdFx0XHQvLyB0aGlzIG1heSBiZSBpbnN1ZmZpY2llbnTigKYgYmVpbmcgYWJsZSB0byB0aHJvdyB3b3VsZCBiZSBuaWNlXHJcblx0XHRcdFx0aWYgKHJlamVjdCkge1xyXG5cdFx0XHRcdFx0cmVqZWN0KGUpXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRocm93IFwiUHJvbWlzZSBwYXNzZWQgbm8gcmVqZWN0IGZ1bmN0aW9uIHRvIG1vbmVyb191dGlscyBsb2FkIGZuXCJcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRjb3JlQnJpZGdlTG9hZGluZ19wcm9taXNlLnRoZW4oX2RpZExvYWQpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHJcbi8vXHJcbi8vXHJcbi8vIFNpbmNlIHdlIGFjdHVhbGx5IGFyZSBjb25zdHJ1Y3RpbmcgYnJpZGdlIGZ1bmN0aW9ucyB3ZSB0ZWNobmljYWxseSBoYXZlIHRoZSBleHBvcnQgcmVhZHkgXHJcbi8vIHN5bmNocm9ub3VzbHkgYnV0IHRoYXQgd291bGQgbG9zZSB0aGUgYWJpbGl0eSB0byB3YWl0IHVudGlsIHRoZSBjb3JlIGJyaWRnZSBpcyBhY3R1YWxseSByZWFkeS5cclxuLy9cclxuLy8gVE9ETzogaW4gZnV0dXJlLCBwb3NzaWJseSByZXR1cm4gZnVuY3Rpb24gd2hpY2ggdGFrZXMgb3B0aW9ucyBpbnN0ZWFkIHRvIHN1cHBvcnQgYmV0dGVyIGVudi5cclxuLy9cclxubW9kdWxlLmV4cG9ydHMgPSBtb25lcm9VdGlsc19wcm9taXNlX2ZuOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./libs/mymonero-app-js/local_modules/mymonero_core_js/monero_utils/monero_utils.js\n");

/***/ }),

/***/ "./node_modules/async/dist/async.js":
/*!******************************************!*\
  !*** ./node_modules/async/dist/async.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("// empty (null-loader)//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXN5bmMvZGlzdC9hc3luYy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc3luYy9kaXN0L2FzeW5jLmpzPzkzOGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZW1wdHkgKG51bGwtbG9hZGVyKSJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/async/dist/async.js\n");

/***/ }),

/***/ "./node_modules/bignumber.js/bignumber.js":
/*!************************************************!*\
  !*** ./node_modules/bignumber.js/bignumber.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;;(function (globalObject) {\r\n  'use strict';\r\n\r\n/*\r\n *      bignumber.js v8.0.1\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2018 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */\r\n\r\n\r\n  var BigNumber,\r\n    isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i,\r\n\r\n    mathceil = Math.ceil,\r\n    mathfloor = Math.floor,\r\n\r\n    bignumberError = '[BigNumber Error] ',\r\n    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',\r\n\r\n    BASE = 1e14,\r\n    LOG_BASE = 14,\r\n    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1\r\n    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\r\n    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],\r\n    SQRT_BASE = 1e7,\r\n\r\n    // EDITABLE\r\n    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\r\n    // the arguments to toExponential, toFixed, toFormat, and toPrecision.\r\n    MAX = 1E9;                                   // 0 to MAX_INT32\r\n\r\n\r\n  /*\r\n   * Create and return a BigNumber constructor.\r\n   */\r\n  function clone(configObject) {\r\n    var div, convertBase, parseNumeric,\r\n      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },\r\n      ONE = new BigNumber(1),\r\n\r\n\r\n      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\r\n\r\n\r\n      // The default values below must be integers within the inclusive ranges stated.\r\n      // The values can also be changed at run-time using BigNumber.set.\r\n\r\n      // The maximum number of decimal places for operations involving division.\r\n      DECIMAL_PLACES = 20,                     // 0 to MAX\r\n\r\n      // The rounding mode used when rounding to the above decimal places, and when using\r\n      // toExponential, toFixed, toFormat and toPrecision, and round (default value).\r\n      // UP         0 Away from zero.\r\n      // DOWN       1 Towards zero.\r\n      // CEIL       2 Towards +Infinity.\r\n      // FLOOR      3 Towards -Infinity.\r\n      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n      ROUNDING_MODE = 4,                       // 0 to 8\r\n\r\n      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\r\n\r\n      // The exponent value at and beneath which toString returns exponential notation.\r\n      // Number type: -7\r\n      TO_EXP_NEG = -7,                         // 0 to -MAX\r\n\r\n      // The exponent value at and above which toString returns exponential notation.\r\n      // Number type: 21\r\n      TO_EXP_POS = 21,                         // 0 to MAX\r\n\r\n      // RANGE : [MIN_EXP, MAX_EXP]\r\n\r\n      // The minimum exponent value, beneath which underflow to zero occurs.\r\n      // Number type: -324  (5e-324)\r\n      MIN_EXP = -1e7,                          // -1 to -MAX\r\n\r\n      // The maximum exponent value, above which overflow to Infinity occurs.\r\n      // Number type:  308  (1.7976931348623157e+308)\r\n      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\r\n      MAX_EXP = 1e7,                           // 1 to MAX\r\n\r\n      // Whether to use cryptographically-secure random number generation, if available.\r\n      CRYPTO = false,                          // true or false\r\n\r\n      // The modulo mode used when calculating the modulus: a mod n.\r\n      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n      // The remainder (r) is calculated as: r = a - n * q.\r\n      //\r\n      // UP        0 The remainder is positive if the dividend is negative, else is negative.\r\n      // DOWN      1 The remainder has the same sign as the dividend.\r\n      //             This modulo mode is commonly known as 'truncated division' and is\r\n      //             equivalent to (a % n) in JavaScript.\r\n      // FLOOR     3 The remainder has the same sign as the divisor (Python %).\r\n      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\r\n      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\r\n      //             The remainder is always positive.\r\n      //\r\n      // The truncated division, floored division, Euclidian division and IEEE 754 remainder\r\n      // modes are commonly used for the modulus operation.\r\n      // Although the other rounding modes can also be used, they may not give useful results.\r\n      MODULO_MODE = 1,                         // 0 to 9\r\n\r\n      // The maximum number of significant digits of the result of the exponentiatedBy operation.\r\n      // If POW_PRECISION is 0, there will be unlimited significant digits.\r\n      POW_PRECISION = 0,                    // 0 to MAX\r\n\r\n      // The format specification used by the BigNumber.prototype.toFormat method.\r\n      FORMAT = {\r\n        prefix: '',\r\n        groupSize: 3,\r\n        secondaryGroupSize: 0,\r\n        groupSeparator: ',',\r\n        decimalSeparator: '.',\r\n        fractionGroupSize: 0,\r\n        fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n        suffix: ''\r\n      },\r\n\r\n      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\r\n      // '-', '.', whitespace, or repeated character.\r\n      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';\r\n\r\n\r\n    //------------------------------------------------------------------------------------------\r\n\r\n\r\n    // CONSTRUCTOR\r\n\r\n\r\n    /*\r\n     * The BigNumber constructor and exported function.\r\n     * Create and return a new instance of a BigNumber object.\r\n     *\r\n     * n {number|string|BigNumber} A numeric value.\r\n     * [b] {number} The base of n. Integer, 2 to ALPHABET.length inclusive.\r\n     */\r\n    function BigNumber(n, b) {\r\n      var alphabet, c, caseChanged, e, i, isNum, len, str,\r\n        x = this;\r\n\r\n      // Enable constructor usage without new.\r\n      if (!(x instanceof BigNumber)) {\r\n\r\n        // Don't throw on constructor call without new (#81).\r\n        // '[BigNumber Error] Constructor call without new: {n}'\r\n        //throw Error(bignumberError + ' Constructor call without new: ' + n);\r\n        return new BigNumber(n, b);\r\n      }\r\n\r\n      if (b == null) {\r\n\r\n        // Duplicate.\r\n        if (n instanceof BigNumber) {\r\n          x.s = n.s;\r\n          x.e = n.e;\r\n          x.c = (n = n.c) ? n.slice() : n;\r\n          return;\r\n        }\r\n\r\n        isNum = typeof n == 'number';\r\n\r\n        if (isNum && n * 0 == 0) {\r\n\r\n          // Use `1 / n` to handle minus zero also.\r\n          x.s = 1 / n < 0 ? (n = -n, -1) : 1;\r\n\r\n          // Faster path for integers.\r\n          if (n === ~~n) {\r\n            for (e = 0, i = n; i >= 10; i /= 10, e++);\r\n            x.e = e;\r\n            x.c = [n];\r\n            return;\r\n          }\r\n\r\n          str = String(n);\r\n        } else {\r\n          str = String(n);\r\n          if (!isNumeric.test(str)) return parseNumeric(x, str, isNum);\r\n          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n        // Exponential form?\r\n        if ((i = str.search(/e/i)) > 0) {\r\n\r\n          // Determine exponent.\r\n          if (e < 0) e = i;\r\n          e += +str.slice(i + 1);\r\n          str = str.substring(0, i);\r\n        } else if (e < 0) {\r\n\r\n          // Integer.\r\n          e = str.length;\r\n        }\r\n\r\n      } else {\r\n\r\n        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n        intCheck(b, 2, ALPHABET.length, 'Base');\r\n        str = String(n);\r\n\r\n        // Allow exponential notation to be used with base 10 argument, while\r\n        // also rounding to DECIMAL_PLACES as with other bases.\r\n        if (b == 10) {\r\n          x = new BigNumber(n instanceof BigNumber ? n : str);\r\n          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\r\n        }\r\n\r\n        isNum = typeof n == 'number';\r\n\r\n        if (isNum) {\r\n\r\n          // Avoid potential interpretation of Infinity and NaN as base 44+ values.\r\n          if (n * 0 != 0) return parseNumeric(x, str, isNum, b);\r\n\r\n          x.s = 1 / n < 0 ? (str = str.slice(1), -1) : 1;\r\n\r\n          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n          if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, '').length > 15) {\r\n            throw Error\r\n             (tooManyDigits + n);\r\n          }\r\n\r\n          // Prevent later check for length on converted number.\r\n          isNum = false;\r\n        } else {\r\n          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        alphabet = ALPHABET.slice(0, b);\r\n        e = i = 0;\r\n\r\n        // Check that str is a valid base b number.\r\n        // Don't use RegExp so alphabet can contain special characters.\r\n        for (len = str.length; i < len; i++) {\r\n          if (alphabet.indexOf(c = str.charAt(i)) < 0) {\r\n            if (c == '.') {\r\n\r\n              // If '.' is not the first character and it has not be found before.\r\n              if (i > e) {\r\n                e = len;\r\n                continue;\r\n              }\r\n            } else if (!caseChanged) {\r\n\r\n              // Allow e.g. hexadecimal 'FF' as well as 'ff'.\r\n              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||\r\n                  str == str.toLowerCase() && (str = str.toUpperCase())) {\r\n                caseChanged = true;\r\n                i = -1;\r\n                e = 0;\r\n                continue;\r\n              }\r\n            }\r\n\r\n            return parseNumeric(x, String(n), isNum, b);\r\n          }\r\n        }\r\n\r\n        str = convertBase(str, b, 10, x.s);\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n        else e = str.length;\r\n      }\r\n\r\n      // Determine leading zeros.\r\n      for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n      // Determine trailing zeros.\r\n      for (len = str.length; str.charCodeAt(--len) === 48;);\r\n\r\n      str = str.slice(i, ++len);\r\n\r\n      if (str) {\r\n        len -= i;\r\n\r\n        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n        if (isNum && BigNumber.DEBUG &&\r\n          len > 15 && (n > MAX_SAFE_INTEGER || n !== mathfloor(n))) {\r\n            throw Error\r\n             (tooManyDigits + (x.s * n));\r\n        }\r\n\r\n        e = e - i - 1;\r\n\r\n         // Overflow?\r\n        if (e > MAX_EXP) {\r\n\r\n          // Infinity.\r\n          x.c = x.e = null;\r\n\r\n        // Underflow?\r\n        } else if (e < MIN_EXP) {\r\n\r\n          // Zero.\r\n          x.c = [x.e = 0];\r\n        } else {\r\n          x.e = e;\r\n          x.c = [];\r\n\r\n          // Transform base\r\n\r\n          // e is the base 10 exponent.\r\n          // i is where to slice str to get the first element of the coefficient array.\r\n          i = (e + 1) % LOG_BASE;\r\n          if (e < 0) i += LOG_BASE;\r\n\r\n          if (i < len) {\r\n            if (i) x.c.push(+str.slice(0, i));\r\n\r\n            for (len -= LOG_BASE; i < len;) {\r\n              x.c.push(+str.slice(i, i += LOG_BASE));\r\n            }\r\n\r\n            str = str.slice(i);\r\n            i = LOG_BASE - str.length;\r\n          } else {\r\n            i -= len;\r\n          }\r\n\r\n          for (; i--; str += '0');\r\n          x.c.push(+str);\r\n        }\r\n      } else {\r\n\r\n        // Zero.\r\n        x.c = [x.e = 0];\r\n      }\r\n    }\r\n\r\n\r\n    // CONSTRUCTOR PROPERTIES\r\n\r\n\r\n    BigNumber.clone = clone;\r\n\r\n    BigNumber.ROUND_UP = 0;\r\n    BigNumber.ROUND_DOWN = 1;\r\n    BigNumber.ROUND_CEIL = 2;\r\n    BigNumber.ROUND_FLOOR = 3;\r\n    BigNumber.ROUND_HALF_UP = 4;\r\n    BigNumber.ROUND_HALF_DOWN = 5;\r\n    BigNumber.ROUND_HALF_EVEN = 6;\r\n    BigNumber.ROUND_HALF_CEIL = 7;\r\n    BigNumber.ROUND_HALF_FLOOR = 8;\r\n    BigNumber.EUCLID = 9;\r\n\r\n\r\n    /*\r\n     * Configure infrequently-changing library-wide settings.\r\n     *\r\n     * Accept an object with the following optional properties (if the value of a property is\r\n     * a number, it must be an integer within the inclusive range stated):\r\n     *\r\n     *   DECIMAL_PLACES   {number}           0 to MAX\r\n     *   ROUNDING_MODE    {number}           0 to 8\r\n     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n     *   CRYPTO           {boolean}          true or false\r\n     *   MODULO_MODE      {number}           0 to 9\r\n     *   POW_PRECISION       {number}           0 to MAX\r\n     *   ALPHABET         {string}           A string of two or more unique characters which does\r\n     *                                       not contain '.'.\r\n     *   FORMAT           {object}           An object with some of the following properties:\r\n     *     prefix                 {string}\r\n     *     groupSize              {number}\r\n     *     secondaryGroupSize     {number}\r\n     *     groupSeparator         {string}\r\n     *     decimalSeparator       {string}\r\n     *     fractionGroupSize      {number}\r\n     *     fractionGroupSeparator {string}\r\n     *     suffix                 {string}\r\n     *\r\n     * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n     *\r\n     * E.g.\r\n     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n     *\r\n     * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n     *\r\n     * Return an object with the properties current values.\r\n     */\r\n    BigNumber.config = BigNumber.set = function (obj) {\r\n      var p, v;\r\n\r\n      if (obj != null) {\r\n\r\n        if (typeof obj == 'object') {\r\n\r\n          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            DECIMAL_PLACES = v;\r\n          }\r\n\r\n          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\r\n          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 8, p);\r\n            ROUNDING_MODE = v;\r\n          }\r\n\r\n          // EXPONENTIAL_AT {number|number[]}\r\n          // Integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\r\n          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, 0, p);\r\n              intCheck(v[1], 0, MAX, p);\r\n              TO_EXP_NEG = v[0];\r\n              TO_EXP_POS = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\r\n            }\r\n          }\r\n\r\n          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\r\n          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\r\n          if (obj.hasOwnProperty(p = 'RANGE')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, -1, p);\r\n              intCheck(v[1], 1, MAX, p);\r\n              MIN_EXP = v[0];\r\n              MAX_EXP = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              if (v) {\r\n                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\r\n              } else {\r\n                throw Error\r\n                 (bignumberError + p + ' cannot be zero: ' + v);\r\n              }\r\n            }\r\n          }\r\n\r\n          // CRYPTO {boolean} true or false.\r\n          // '[BigNumber Error] CRYPTO not true or false: {v}'\r\n          // '[BigNumber Error] crypto unavailable'\r\n          if (obj.hasOwnProperty(p = 'CRYPTO')) {\r\n            v = obj[p];\r\n            if (v === !!v) {\r\n              if (v) {\r\n                if (typeof crypto != 'undefined' && crypto &&\r\n                 (crypto.getRandomValues || crypto.randomBytes)) {\r\n                  CRYPTO = v;\r\n                } else {\r\n                  CRYPTO = !v;\r\n                  throw Error\r\n                   (bignumberError + 'crypto unavailable');\r\n                }\r\n              } else {\r\n                CRYPTO = v;\r\n              }\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' not true or false: ' + v);\r\n            }\r\n          }\r\n\r\n          // MODULO_MODE {number} Integer, 0 to 9 inclusive.\r\n          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 9, p);\r\n            MODULO_MODE = v;\r\n          }\r\n\r\n          // POW_PRECISION {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            POW_PRECISION = v;\r\n          }\r\n\r\n          // FORMAT {object}\r\n          // '[BigNumber Error] FORMAT not an object: {v}'\r\n          if (obj.hasOwnProperty(p = 'FORMAT')) {\r\n            v = obj[p];\r\n            if (typeof v == 'object') FORMAT = v;\r\n            else throw Error\r\n             (bignumberError + p + ' not an object: ' + v);\r\n          }\r\n\r\n          // ALPHABET {string}\r\n          // '[BigNumber Error] ALPHABET invalid: {v}'\r\n          if (obj.hasOwnProperty(p = 'ALPHABET')) {\r\n            v = obj[p];\r\n\r\n            // Disallow if only one character,\r\n            // or if it contains '+', '-', '.', whitespace, or a repeated character.\r\n            if (typeof v == 'string' && !/^.$|[+-.\\s]|(.).*\\1/.test(v)) {\r\n              ALPHABET = v;\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' invalid: ' + v);\r\n            }\r\n          }\r\n\r\n        } else {\r\n\r\n          // '[BigNumber Error] Object expected: {v}'\r\n          throw Error\r\n           (bignumberError + 'Object expected: ' + obj);\r\n        }\r\n      }\r\n\r\n      return {\r\n        DECIMAL_PLACES: DECIMAL_PLACES,\r\n        ROUNDING_MODE: ROUNDING_MODE,\r\n        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],\r\n        RANGE: [MIN_EXP, MAX_EXP],\r\n        CRYPTO: CRYPTO,\r\n        MODULO_MODE: MODULO_MODE,\r\n        POW_PRECISION: POW_PRECISION,\r\n        FORMAT: FORMAT,\r\n        ALPHABET: ALPHABET\r\n      };\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if v is a BigNumber instance, otherwise return false.\r\n     *\r\n     * v {any}\r\n     */\r\n    BigNumber.isBigNumber = function (v) {\r\n      return v instanceof BigNumber || v && v._isBigNumber === true || false;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the maximum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.maximum = BigNumber.max = function () {\r\n      return maxOrMin(arguments, P.lt);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the minimum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.minimum = BigNumber.min = function () {\r\n      return maxOrMin(arguments, P.gt);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n     * zeros are produced).\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n     * '[BigNumber Error] crypto unavailable'\r\n     */\r\n    BigNumber.random = (function () {\r\n      var pow2_53 = 0x20000000000000;\r\n\r\n      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\r\n      // Check if Math.random() produces more than 32 bits of randomness.\r\n      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\r\n      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\r\n      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff\r\n       ? function () { return mathfloor(Math.random() * pow2_53); }\r\n       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +\r\n         (Math.random() * 0x800000 | 0); };\r\n\r\n      return function (dp) {\r\n        var a, b, e, k, v,\r\n          i = 0,\r\n          c = [],\r\n          rand = new BigNumber(ONE);\r\n\r\n        if (dp == null) dp = DECIMAL_PLACES;\r\n        else intCheck(dp, 0, MAX);\r\n\r\n        k = mathceil(dp / LOG_BASE);\r\n\r\n        if (CRYPTO) {\r\n\r\n          // Browsers supporting crypto.getRandomValues.\r\n          if (crypto.getRandomValues) {\r\n\r\n            a = crypto.getRandomValues(new Uint32Array(k *= 2));\r\n\r\n            for (; i < k;) {\r\n\r\n              // 53 bits:\r\n              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\r\n              // 11111 11111111 11111111 11111111 11100000 00000000 00000000\r\n              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\r\n              //                                     11111 11111111 11111111\r\n              // 0x20000 is 2^21.\r\n              v = a[i] * 0x20000 + (a[i + 1] >>> 11);\r\n\r\n              // Rejection sampling:\r\n              // 0 <= v < 9007199254740992\r\n              // Probability that v >= 9e15, is\r\n              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\r\n              if (v >= 9e15) {\r\n                b = crypto.getRandomValues(new Uint32Array(2));\r\n                a[i] = b[0];\r\n                a[i + 1] = b[1];\r\n              } else {\r\n\r\n                // 0 <= v <= 8999999999999999\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 2;\r\n              }\r\n            }\r\n            i = k / 2;\r\n\r\n          // Node.js supporting crypto.randomBytes.\r\n          } else if (crypto.randomBytes) {\r\n\r\n            // buffer\r\n            a = crypto.randomBytes(k *= 7);\r\n\r\n            for (; i < k;) {\r\n\r\n              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\r\n              // 0x100000000 is 2^32, 0x1000000 is 2^24\r\n              // 11111 11111111 11111111 11111111 11111111 11111111 11111111\r\n              // 0 <= v < 9007199254740992\r\n              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +\r\n                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +\r\n                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\r\n\r\n              if (v >= 9e15) {\r\n                crypto.randomBytes(7).copy(a, i);\r\n              } else {\r\n\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 7;\r\n              }\r\n            }\r\n            i = k / 7;\r\n          } else {\r\n            CRYPTO = false;\r\n            throw Error\r\n             (bignumberError + 'crypto unavailable');\r\n          }\r\n        }\r\n\r\n        // Use Math.random.\r\n        if (!CRYPTO) {\r\n\r\n          for (; i < k;) {\r\n            v = random53bitInt();\r\n            if (v < 9e15) c[i++] = v % 1e14;\r\n          }\r\n        }\r\n\r\n        k = c[--i];\r\n        dp %= LOG_BASE;\r\n\r\n        // Convert trailing digits to zeros according to dp.\r\n        if (k && dp) {\r\n          v = POWS_TEN[LOG_BASE - dp];\r\n          c[i] = mathfloor(k / v) * v;\r\n        }\r\n\r\n        // Remove trailing elements which are zero.\r\n        for (; c[i] === 0; c.pop(), i--);\r\n\r\n        // Zero?\r\n        if (i < 0) {\r\n          c = [e = 0];\r\n        } else {\r\n\r\n          // Remove leading elements which are zero and adjust exponent accordingly.\r\n          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\r\n\r\n          // Count the digits of the first element of c to determine leading zeros, and...\r\n          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);\r\n\r\n          // adjust the exponent accordingly.\r\n          if (i < LOG_BASE) e -= LOG_BASE - i;\r\n        }\r\n\r\n        rand.e = e;\r\n        rand.c = c;\r\n        return rand;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the sum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.sum = function () {\r\n      var i = 1,\r\n        args = arguments,\r\n        sum = new BigNumber(args[0]);\r\n      for (; i < args.length;) sum = sum.plus(args[i++]);\r\n      return sum;\r\n    };\r\n\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n\r\n    // Called by BigNumber and BigNumber.prototype.toString.\r\n    convertBase = (function () {\r\n      var decimal = '0123456789';\r\n\r\n      /*\r\n       * Convert string of baseIn to an array of numbers of baseOut.\r\n       * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n       */\r\n      function toBaseOut(str, baseIn, baseOut, alphabet) {\r\n        var j,\r\n          arr = [0],\r\n          arrL,\r\n          i = 0,\r\n          len = str.length;\r\n\r\n        for (; i < len;) {\r\n          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);\r\n\r\n          arr[0] += alphabet.indexOf(str.charAt(i++));\r\n\r\n          for (j = 0; j < arr.length; j++) {\r\n\r\n            if (arr[j] > baseOut - 1) {\r\n              if (arr[j + 1] == null) arr[j + 1] = 0;\r\n              arr[j + 1] += arr[j] / baseOut | 0;\r\n              arr[j] %= baseOut;\r\n            }\r\n          }\r\n        }\r\n\r\n        return arr.reverse();\r\n      }\r\n\r\n      // Convert a numeric string of baseIn to a numeric string of baseOut.\r\n      // If the caller is toString, we are converting from base 10 to baseOut.\r\n      // If the caller is BigNumber, we are converting from baseIn to base 10.\r\n      return function (str, baseIn, baseOut, sign, callerIsToString) {\r\n        var alphabet, d, e, k, r, x, xc, y,\r\n          i = str.indexOf('.'),\r\n          dp = DECIMAL_PLACES,\r\n          rm = ROUNDING_MODE;\r\n\r\n        // Non-integer.\r\n        if (i >= 0) {\r\n          k = POW_PRECISION;\r\n\r\n          // Unlimited precision.\r\n          POW_PRECISION = 0;\r\n          str = str.replace('.', '');\r\n          y = new BigNumber(baseIn);\r\n          x = y.pow(str.length - i);\r\n          POW_PRECISION = k;\r\n\r\n          // Convert str as if an integer, then restore the fraction part by dividing the\r\n          // result by its base raised to a power.\r\n\r\n          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),\r\n           10, baseOut, decimal);\r\n          y.e = y.c.length;\r\n        }\r\n\r\n        // Convert the number as integer.\r\n\r\n        xc = toBaseOut(str, baseIn, baseOut, callerIsToString\r\n         ? (alphabet = ALPHABET, decimal)\r\n         : (alphabet = decimal, ALPHABET));\r\n\r\n        // xc now represents str as an integer and converted to baseOut. e is the exponent.\r\n        e = k = xc.length;\r\n\r\n        // Remove trailing zeros.\r\n        for (; xc[--k] == 0; xc.pop());\r\n\r\n        // Zero?\r\n        if (!xc[0]) return alphabet.charAt(0);\r\n\r\n        // Does str represent an integer? If so, no need for the division.\r\n        if (i < 0) {\r\n          --e;\r\n        } else {\r\n          x.c = xc;\r\n          x.e = e;\r\n\r\n          // The sign is needed for correct rounding.\r\n          x.s = sign;\r\n          x = div(x, y, dp, rm, baseOut);\r\n          xc = x.c;\r\n          r = x.r;\r\n          e = x.e;\r\n        }\r\n\r\n        // xc now represents str converted to baseOut.\r\n\r\n        // THe index of the rounding digit.\r\n        d = e + dp + 1;\r\n\r\n        // The rounding digit: the digit to the right of the digit that may be rounded up.\r\n        i = xc[d];\r\n\r\n        // Look at the rounding digits and mode to determine whether to round up.\r\n\r\n        k = baseOut / 2;\r\n        r = r || d < 0 || xc[d + 1] != null;\r\n\r\n        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||\r\n               rm == (x.s < 0 ? 8 : 7));\r\n\r\n        // If the index of the rounding digit is not greater than zero, or xc represents\r\n        // zero, then the result of the base conversion is zero or, if rounding up, a value\r\n        // such as 0.00001.\r\n        if (d < 1 || !xc[0]) {\r\n\r\n          // 1^-dp or 0\r\n          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\r\n        } else {\r\n\r\n          // Truncate xc to the required number of decimal places.\r\n          xc.length = d;\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            // Rounding up may mean the previous digit has to be rounded up and so on.\r\n            for (--baseOut; ++xc[--d] > baseOut;) {\r\n              xc[d] = 0;\r\n\r\n              if (!d) {\r\n                ++e;\r\n                xc = [1].concat(xc);\r\n              }\r\n            }\r\n          }\r\n\r\n          // Determine trailing zeros.\r\n          for (k = xc.length; !xc[--k];);\r\n\r\n          // E.g. [4, 11, 15] becomes 4bf.\r\n          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));\r\n\r\n          // Add leading zeros, decimal point and trailing zeros as required.\r\n          str = toFixedPoint(str, e, alphabet.charAt(0));\r\n        }\r\n\r\n        // The caller will add the sign.\r\n        return str;\r\n      };\r\n    })();\r\n\r\n\r\n    // Perform division in the specified base. Called by div and convertBase.\r\n    div = (function () {\r\n\r\n      // Assume non-zero x and k.\r\n      function multiply(x, k, base) {\r\n        var m, temp, xlo, xhi,\r\n          carry = 0,\r\n          i = x.length,\r\n          klo = k % SQRT_BASE,\r\n          khi = k / SQRT_BASE | 0;\r\n\r\n        for (x = x.slice(); i--;) {\r\n          xlo = x[i] % SQRT_BASE;\r\n          xhi = x[i] / SQRT_BASE | 0;\r\n          m = khi * xlo + xhi * klo;\r\n          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;\r\n          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\r\n          x[i] = temp % base;\r\n        }\r\n\r\n        if (carry) x = [carry].concat(x);\r\n\r\n        return x;\r\n      }\r\n\r\n      function compare(a, b, aL, bL) {\r\n        var i, cmp;\r\n\r\n        if (aL != bL) {\r\n          cmp = aL > bL ? 1 : -1;\r\n        } else {\r\n\r\n          for (i = cmp = 0; i < aL; i++) {\r\n\r\n            if (a[i] != b[i]) {\r\n              cmp = a[i] > b[i] ? 1 : -1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        return cmp;\r\n      }\r\n\r\n      function subtract(a, b, aL, base) {\r\n        var i = 0;\r\n\r\n        // Subtract b from a.\r\n        for (; aL--;) {\r\n          a[aL] -= i;\r\n          i = a[aL] < b[aL] ? 1 : 0;\r\n          a[aL] = i * base + a[aL] - b[aL];\r\n        }\r\n\r\n        // Remove leading zeros.\r\n        for (; !a[0] && a.length > 1; a.splice(0, 1));\r\n      }\r\n\r\n      // x: dividend, y: divisor.\r\n      return function (x, y, dp, rm, base) {\r\n        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,\r\n          yL, yz,\r\n          s = x.s == y.s ? 1 : -1,\r\n          xc = x.c,\r\n          yc = y.c;\r\n\r\n        // Either NaN, Infinity or 0?\r\n        if (!xc || !xc[0] || !yc || !yc[0]) {\r\n\r\n          return new BigNumber(\r\n\r\n           // Return NaN if either NaN, or both Infinity or 0.\r\n           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :\r\n\r\n            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.\r\n            xc && xc[0] == 0 || !yc ? s * 0 : s / 0\r\n         );\r\n        }\r\n\r\n        q = new BigNumber(s);\r\n        qc = q.c = [];\r\n        e = x.e - y.e;\r\n        s = dp + e + 1;\r\n\r\n        if (!base) {\r\n          base = BASE;\r\n          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\r\n          s = s / LOG_BASE | 0;\r\n        }\r\n\r\n        // Result exponent may be one less then the current value of e.\r\n        // The coefficients of the BigNumbers from convertBase may have trailing zeros.\r\n        for (i = 0; yc[i] == (xc[i] || 0); i++);\r\n\r\n        if (yc[i] > (xc[i] || 0)) e--;\r\n\r\n        if (s < 0) {\r\n          qc.push(1);\r\n          more = true;\r\n        } else {\r\n          xL = xc.length;\r\n          yL = yc.length;\r\n          i = 0;\r\n          s += 2;\r\n\r\n          // Normalise xc and yc so highest order digit of yc is >= base / 2.\r\n\r\n          n = mathfloor(base / (yc[0] + 1));\r\n\r\n          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\r\n          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\r\n          if (n > 1) {\r\n            yc = multiply(yc, n, base);\r\n            xc = multiply(xc, n, base);\r\n            yL = yc.length;\r\n            xL = xc.length;\r\n          }\r\n\r\n          xi = yL;\r\n          rem = xc.slice(0, yL);\r\n          remL = rem.length;\r\n\r\n          // Add zeros to make remainder as long as divisor.\r\n          for (; remL < yL; rem[remL++] = 0);\r\n          yz = yc.slice();\r\n          yz = [0].concat(yz);\r\n          yc0 = yc[0];\r\n          if (yc[1] >= base / 2) yc0++;\r\n          // Not necessary, but to prevent trial digit n > base, when using base 3.\r\n          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\r\n\r\n          do {\r\n            n = 0;\r\n\r\n            // Compare divisor and remainder.\r\n            cmp = compare(yc, rem, yL, remL);\r\n\r\n            // If divisor < remainder.\r\n            if (cmp < 0) {\r\n\r\n              // Calculate trial digit, n.\r\n\r\n              rem0 = rem[0];\r\n              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n              // n is how many times the divisor goes into the current remainder.\r\n              n = mathfloor(rem0 / yc0);\r\n\r\n              //  Algorithm:\r\n              //  product = divisor multiplied by trial digit (n).\r\n              //  Compare product and remainder.\r\n              //  If product is greater than remainder:\r\n              //    Subtract divisor from product, decrement trial digit.\r\n              //  Subtract product from remainder.\r\n              //  If product was less than remainder at the last compare:\r\n              //    Compare new remainder and divisor.\r\n              //    If remainder is greater than divisor:\r\n              //      Subtract divisor from remainder, increment trial digit.\r\n\r\n              if (n > 1) {\r\n\r\n                // n may be > base only when base is 3.\r\n                if (n >= base) n = base - 1;\r\n\r\n                // product = divisor * trial digit.\r\n                prod = multiply(yc, n, base);\r\n                prodL = prod.length;\r\n                remL = rem.length;\r\n\r\n                // Compare product and remainder.\r\n                // If product > remainder then trial digit n too high.\r\n                // n is 1 too high about 5% of the time, and is not known to have\r\n                // ever been more than 1 too high.\r\n                while (compare(prod, rem, prodL, remL) == 1) {\r\n                  n--;\r\n\r\n                  // Subtract divisor from product.\r\n                  subtract(prod, yL < prodL ? yz : yc, prodL, base);\r\n                  prodL = prod.length;\r\n                  cmp = 1;\r\n                }\r\n              } else {\r\n\r\n                // n is 0 or 1, cmp is -1.\r\n                // If n is 0, there is no need to compare yc and rem again below,\r\n                // so change cmp to 1 to avoid it.\r\n                // If n is 1, leave cmp as -1, so yc and rem are compared again.\r\n                if (n == 0) {\r\n\r\n                  // divisor < remainder, so n must be at least 1.\r\n                  cmp = n = 1;\r\n                }\r\n\r\n                // product = divisor\r\n                prod = yc.slice();\r\n                prodL = prod.length;\r\n              }\r\n\r\n              if (prodL < remL) prod = [0].concat(prod);\r\n\r\n              // Subtract product from remainder.\r\n              subtract(rem, prod, remL, base);\r\n              remL = rem.length;\r\n\r\n               // If product was < remainder.\r\n              if (cmp == -1) {\r\n\r\n                // Compare divisor and new remainder.\r\n                // If divisor < new remainder, subtract divisor from remainder.\r\n                // Trial digit n too low.\r\n                // n is 1 too low about 5% of the time, and very rarely 2 too low.\r\n                while (compare(yc, rem, yL, remL) < 1) {\r\n                  n++;\r\n\r\n                  // Subtract divisor from remainder.\r\n                  subtract(rem, yL < remL ? yz : yc, remL, base);\r\n                  remL = rem.length;\r\n                }\r\n              }\r\n            } else if (cmp === 0) {\r\n              n++;\r\n              rem = [0];\r\n            } // else cmp === 1 and n will be 0\r\n\r\n            // Add the next digit, n, to the result array.\r\n            qc[i++] = n;\r\n\r\n            // Update the remainder.\r\n            if (rem[0]) {\r\n              rem[remL++] = xc[xi] || 0;\r\n            } else {\r\n              rem = [xc[xi]];\r\n              remL = 1;\r\n            }\r\n          } while ((xi++ < xL || rem[0] != null) && s--);\r\n\r\n          more = rem[0] != null;\r\n\r\n          // Leading zero?\r\n          if (!qc[0]) qc.splice(0, 1);\r\n        }\r\n\r\n        if (base == BASE) {\r\n\r\n          // To calculate q.e, first get the number of digits of qc[0].\r\n          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);\r\n\r\n          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\r\n\r\n        // Caller is convertBase.\r\n        } else {\r\n          q.e = e;\r\n          q.r = +more;\r\n        }\r\n\r\n        return q;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n     * notation rounded to the specified decimal places or significant digits.\r\n     *\r\n     * n: a BigNumber.\r\n     * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n     * rm: the rounding mode.\r\n     * id: 1 (toExponential) or 2 (toPrecision).\r\n     */\r\n    function format(n, i, rm, id) {\r\n      var c0, e, ne, len, str;\r\n\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      if (!n.c) return n.toString();\r\n\r\n      c0 = n.c[0];\r\n      ne = n.e;\r\n\r\n      if (i == null) {\r\n        str = coeffToString(n.c);\r\n        str = id == 1 || id == 2 && ne <= TO_EXP_NEG\r\n         ? toExponential(str, ne)\r\n         : toFixedPoint(str, ne, '0');\r\n      } else {\r\n        n = round(new BigNumber(n), i, rm);\r\n\r\n        // n.e may have changed if the value was rounded up.\r\n        e = n.e;\r\n\r\n        str = coeffToString(n.c);\r\n        len = str.length;\r\n\r\n        // toPrecision returns exponential notation if the number of significant digits\r\n        // specified is less than the number of digits necessary to represent the integer\r\n        // part of the value in fixed-point notation.\r\n\r\n        // Exponential notation.\r\n        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\r\n\r\n          // Append zeros?\r\n          for (; len < i; str += '0', len++);\r\n          str = toExponential(str, e);\r\n\r\n        // Fixed-point notation.\r\n        } else {\r\n          i -= ne;\r\n          str = toFixedPoint(str, e, '0');\r\n\r\n          // Append zeros?\r\n          if (e + 1 > len) {\r\n            if (--i > 0) for (str += '.'; i--; str += '0');\r\n          } else {\r\n            i += e - len;\r\n            if (i > 0) {\r\n              if (e + 1 == len) str += '.';\r\n              for (; i--; str += '0');\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return n.s < 0 && c0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // Handle BigNumber.max and BigNumber.min.\r\n    function maxOrMin(args, method) {\r\n      var n,\r\n        i = 1,\r\n        m = new BigNumber(args[0]);\r\n\r\n      for (; i < args.length; i++) {\r\n        n = new BigNumber(args[i]);\r\n\r\n        // If any number is NaN, return NaN.\r\n        if (!n.s) {\r\n          m = n;\r\n          break;\r\n        } else if (method.call(m, n)) {\r\n          m = n;\r\n        }\r\n      }\r\n\r\n      return m;\r\n    }\r\n\r\n\r\n    /*\r\n     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n     * Called by minus, plus and times.\r\n     */\r\n    function normalise(n, c, e) {\r\n      var i = 1,\r\n        j = c.length;\r\n\r\n       // Remove trailing zeros.\r\n      for (; !c[--j]; c.pop());\r\n\r\n      // Calculate the base 10 exponent. First get the number of digits of c[0].\r\n      for (j = c[0]; j >= 10; j /= 10, i++);\r\n\r\n      // Overflow?\r\n      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\r\n\r\n        // Infinity.\r\n        n.c = n.e = null;\r\n\r\n      // Underflow?\r\n      } else if (e < MIN_EXP) {\r\n\r\n        // Zero.\r\n        n.c = [n.e = 0];\r\n      } else {\r\n        n.e = e;\r\n        n.c = c;\r\n      }\r\n\r\n      return n;\r\n    }\r\n\r\n\r\n    // Handle values that fail the validity test in BigNumber.\r\n    parseNumeric = (function () {\r\n      var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i,\r\n        dotAfter = /^([^.]+)\\.$/,\r\n        dotBefore = /^\\.([^.]+)$/,\r\n        isInfinityOrNaN = /^-?(Infinity|NaN)$/,\r\n        whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\r\n\r\n      return function (x, str, isNum, b) {\r\n        var base,\r\n          s = isNum ? str : str.replace(whitespaceOrPlus, '');\r\n\r\n        // No exception on Infinity or NaN.\r\n        if (isInfinityOrNaN.test(s)) {\r\n          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\r\n          x.c = x.e = null;\r\n        } else {\r\n          if (!isNum) {\r\n\r\n            // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\r\n            s = s.replace(basePrefix, function (m, p1, p2) {\r\n              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;\r\n              return !b || b == base ? p1 : m;\r\n            });\r\n\r\n            if (b) {\r\n              base = b;\r\n\r\n              // E.g. '1.' to '1', '.1' to '0.1'\r\n              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');\r\n            }\r\n\r\n            if (str != s) return new BigNumber(s, base);\r\n          }\r\n\r\n          // '[BigNumber Error] Not a number: {n}'\r\n          // '[BigNumber Error] Not a base {b} number: {n}'\r\n          if (BigNumber.DEBUG) {\r\n            throw Error\r\n              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);\r\n          }\r\n\r\n          // NaN\r\n          x.c = x.e = x.s = null;\r\n        }\r\n      }\r\n    })();\r\n\r\n\r\n    /*\r\n     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n     * If r is truthy, it is known that there are more digits after the rounding digit.\r\n     */\r\n    function round(x, sd, rm, r) {\r\n      var d, i, j, k, n, ni, rd,\r\n        xc = x.c,\r\n        pows10 = POWS_TEN;\r\n\r\n      // if x is not Infinity or NaN...\r\n      if (xc) {\r\n\r\n        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n        // n is a base 1e14 number, the value of the element of array x.c containing rd.\r\n        // ni is the index of n within x.c.\r\n        // d is the number of digits of n.\r\n        // i is the index of rd within n including leading zeros.\r\n        // j is the actual index of rd within n (if < 0, rd is a leading zero).\r\n        out: {\r\n\r\n          // Get the number of digits of the first element of xc.\r\n          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);\r\n          i = sd - d;\r\n\r\n          // If the rounding digit is in the first element of xc...\r\n          if (i < 0) {\r\n            i += LOG_BASE;\r\n            j = sd;\r\n            n = xc[ni = 0];\r\n\r\n            // Get the rounding digit at index j of n.\r\n            rd = n / pows10[d - j - 1] % 10 | 0;\r\n          } else {\r\n            ni = mathceil((i + 1) / LOG_BASE);\r\n\r\n            if (ni >= xc.length) {\r\n\r\n              if (r) {\r\n\r\n                // Needed by sqrt.\r\n                for (; xc.length <= ni; xc.push(0));\r\n                n = rd = 0;\r\n                d = 1;\r\n                i %= LOG_BASE;\r\n                j = i - LOG_BASE + 1;\r\n              } else {\r\n                break out;\r\n              }\r\n            } else {\r\n              n = k = xc[ni];\r\n\r\n              // Get the number of digits of n.\r\n              for (d = 1; k >= 10; k /= 10, d++);\r\n\r\n              // Get the index of rd within n.\r\n              i %= LOG_BASE;\r\n\r\n              // Get the index of rd within n, adjusted for leading zeros.\r\n              // The number of leading zeros of n is given by LOG_BASE - d.\r\n              j = i - LOG_BASE + d;\r\n\r\n              // Get the rounding digit at index j of n.\r\n              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;\r\n            }\r\n          }\r\n\r\n          r = r || sd < 0 ||\r\n\r\n          // Are there any non-zero digits after the rounding digit?\r\n          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\r\n          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\r\n           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\r\n\r\n          r = rm < 4\r\n           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&\r\n\r\n            // Check whether the digit to the left of the rounding digit is odd.\r\n            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||\r\n             rm == (x.s < 0 ? 8 : 7));\r\n\r\n          if (sd < 1 || !xc[0]) {\r\n            xc.length = 0;\r\n\r\n            if (r) {\r\n\r\n              // Convert sd to decimal places.\r\n              sd -= x.e + 1;\r\n\r\n              // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\r\n              x.e = -sd || 0;\r\n            } else {\r\n\r\n              // Zero.\r\n              xc[0] = x.e = 0;\r\n            }\r\n\r\n            return x;\r\n          }\r\n\r\n          // Remove excess digits.\r\n          if (i == 0) {\r\n            xc.length = ni;\r\n            k = 1;\r\n            ni--;\r\n          } else {\r\n            xc.length = ni + 1;\r\n            k = pows10[LOG_BASE - i];\r\n\r\n            // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n            // j > 0 means i > number of leading zeros of n.\r\n            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\r\n          }\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            for (; ;) {\r\n\r\n              // If the digit to be rounded up is in the first element of xc...\r\n              if (ni == 0) {\r\n\r\n                // i will be the length of xc[0] before k is added.\r\n                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);\r\n                j = xc[0] += k;\r\n                for (k = 1; j >= 10; j /= 10, k++);\r\n\r\n                // if i != k the length has increased.\r\n                if (i != k) {\r\n                  x.e++;\r\n                  if (xc[0] == BASE) xc[0] = 1;\r\n                }\r\n\r\n                break;\r\n              } else {\r\n                xc[ni] += k;\r\n                if (xc[ni] != BASE) break;\r\n                xc[ni--] = 0;\r\n                k = 1;\r\n              }\r\n            }\r\n          }\r\n\r\n          // Remove trailing zeros.\r\n          for (i = xc.length; xc[--i] === 0; xc.pop());\r\n        }\r\n\r\n        // Overflow? Infinity.\r\n        if (x.e > MAX_EXP) {\r\n          x.c = x.e = null;\r\n\r\n        // Underflow? Zero.\r\n        } else if (x.e < MIN_EXP) {\r\n          x.c = [x.e = 0];\r\n        }\r\n      }\r\n\r\n      return x;\r\n    }\r\n\r\n\r\n    function valueOf(n) {\r\n      var str,\r\n        e = n.e;\r\n\r\n      if (e === null) return n.toString();\r\n\r\n      str = coeffToString(n.c);\r\n\r\n      str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n        ? toExponential(str, e)\r\n        : toFixedPoint(str, e, '0');\r\n\r\n      return n.s < 0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // PROTOTYPE/INSTANCE METHODS\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n     */\r\n    P.absoluteValue = P.abs = function () {\r\n      var x = new BigNumber(this);\r\n      if (x.s < 0) x.s = 1;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return\r\n     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     *   0 if they have the same value,\r\n     *   or null if the value of either is NaN.\r\n     */\r\n    P.comparedTo = function (y, b) {\r\n      return compare(this, new BigNumber(y, b));\r\n    };\r\n\r\n\r\n    /*\r\n     * If dp is undefined or null or true or false, return the number of decimal places of the\r\n     * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n     *\r\n     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.decimalPlaces = P.dp = function (dp, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), dp + x.e + 1, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n      // Subtract the number of trailing zeros of the last number.\r\n      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);\r\n      if (n < 0) n = 0;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n / 0 = I\r\n     *  n / N = N\r\n     *  n / I = 0\r\n     *  0 / n = 0\r\n     *  0 / 0 = N\r\n     *  0 / N = N\r\n     *  0 / I = 0\r\n     *  N / n = N\r\n     *  N / 0 = N\r\n     *  N / N = N\r\n     *  N / I = N\r\n     *  I / n = I\r\n     *  I / 0 = I\r\n     *  I / N = N\r\n     *  I / I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.dividedBy = P.div = function (y, b) {\r\n      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n     * BigNumber by the value of BigNumber(y, b).\r\n     */\r\n    P.dividedToIntegerBy = P.idiv = function (y, b) {\r\n      return div(this, new BigNumber(y, b), 0, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n     *\r\n     * If m is present, return the result modulo m.\r\n     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n     *\r\n     * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n     *\r\n     * n {number|string|BigNumber} The exponent. An integer.\r\n     * [m] {number|string|BigNumber} The modulus.\r\n     *\r\n     * '[BigNumber Error] Exponent not an integer: {n}'\r\n     */\r\n    P.exponentiatedBy = P.pow = function (n, m) {\r\n      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,\r\n        x = this;\r\n\r\n      n = new BigNumber(n);\r\n\r\n      // Allow NaN and Infinity, but not other non-integers.\r\n      if (n.c && !n.isInteger()) {\r\n        throw Error\r\n          (bignumberError + 'Exponent not an integer: ' + valueOf(n));\r\n      }\r\n\r\n      if (m != null) m = new BigNumber(m);\r\n\r\n      // Exponent of MAX_SAFE_INTEGER is 15.\r\n      nIsBig = n.e > 14;\r\n\r\n      // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.\r\n      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\r\n\r\n        // The sign of the result of pow when x is negative depends on the evenness of n.\r\n        // If +n overflows to Infinity, the evenness of n would be not be known.\r\n        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));\r\n        return m ? y.mod(m) : y;\r\n      }\r\n\r\n      nIsNeg = n.s < 0;\r\n\r\n      if (m) {\r\n\r\n        // x % m returns NaN if abs(m) is zero, or m is NaN.\r\n        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\r\n\r\n        isModExp = !nIsNeg && x.isInteger() && m.isInteger();\r\n\r\n        if (isModExp) x = x.mod(m);\r\n\r\n      // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.\r\n      // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.\r\n      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0\r\n        // [1, 240000000]\r\n        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7\r\n        // [80000000000000]  [99999750000000]\r\n        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\r\n\r\n        // If x is negative and n is odd, k = -0, else k = 0.\r\n        k = x.s < 0 && isOdd(n) ? -0 : 0;\r\n\r\n        // If x >= 1, k = Infinity.\r\n        if (x.e > -1) k = 1 / k;\r\n\r\n        // If n is negative return 0, else return Infinity.\r\n        return new BigNumber(nIsNeg ? 1 / k : k);\r\n\r\n      } else if (POW_PRECISION) {\r\n\r\n        // Truncating each coefficient array to a length of k after each multiplication\r\n        // equates to truncating significant digits to POW_PRECISION + [28, 41],\r\n        // i.e. there will be a minimum of 28 guard digits retained.\r\n        k = mathceil(POW_PRECISION / LOG_BASE + 2);\r\n      }\r\n\r\n      if (nIsBig) {\r\n        half = new BigNumber(0.5);\r\n        if (nIsNeg) n.s = 1;\r\n        nIsOdd = isOdd(n);\r\n      } else {\r\n        i = Math.abs(+valueOf(n));\r\n        nIsOdd = i % 2;\r\n      }\r\n\r\n      y = new BigNumber(ONE);\r\n\r\n      // Performs 54 loop iterations for n of 9007199254740991.\r\n      for (; ;) {\r\n\r\n        if (nIsOdd) {\r\n          y = y.times(x);\r\n          if (!y.c) break;\r\n\r\n          if (k) {\r\n            if (y.c.length > k) y.c.length = k;\r\n          } else if (isModExp) {\r\n            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\r\n          }\r\n        }\r\n\r\n        if (i) {\r\n          i = mathfloor(i / 2);\r\n          if (i === 0) break;\r\n          nIsOdd = i % 2;\r\n        } else {\r\n          n = n.times(half);\r\n          round(n, n.e + 1, 1);\r\n\r\n          if (n.e > 14) {\r\n            nIsOdd = isOdd(n);\r\n          } else {\r\n            i = +valueOf(n);\r\n            if (i === 0) break;\r\n            nIsOdd = i % 2;\r\n          }\r\n        }\r\n\r\n        x = x.times(x);\r\n\r\n        if (k) {\r\n          if (x.c && x.c.length > k) x.c.length = k;\r\n        } else if (isModExp) {\r\n          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\r\n        }\r\n      }\r\n\r\n      if (isModExp) return y;\r\n      if (nIsNeg) y = ONE.div(y);\r\n\r\n      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n     */\r\n    P.integerValue = function (rm) {\r\n      var n = new BigNumber(this);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n      return round(n, n.e + 1, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isEqualTo = P.eq = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n     */\r\n    P.isFinite = function () {\r\n      return !!this.c;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isGreaterThan = P.gt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\r\n\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n     */\r\n    P.isInteger = function () {\r\n      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isLessThan = P.lt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isLessThanOrEqualTo = P.lte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n     */\r\n    P.isNaN = function () {\r\n      return !this.s;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is negative, otherwise return false.\r\n     */\r\n    P.isNegative = function () {\r\n      return this.s < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is positive, otherwise return false.\r\n     */\r\n    P.isPositive = function () {\r\n      return this.s > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n     */\r\n    P.isZero = function () {\r\n      return !!this.c && this.c[0] == 0;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n - 0 = n\r\n     *  n - N = N\r\n     *  n - I = -I\r\n     *  0 - n = -n\r\n     *  0 - 0 = 0\r\n     *  0 - N = N\r\n     *  0 - I = -I\r\n     *  N - n = N\r\n     *  N - 0 = N\r\n     *  N - N = N\r\n     *  N - I = N\r\n     *  I - n = I\r\n     *  I - 0 = I\r\n     *  I - N = N\r\n     *  I - I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.minus = function (y, b) {\r\n      var i, j, t, xLTy,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n      if (a != b) {\r\n        y.s = -b;\r\n        return x.plus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Either Infinity?\r\n        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\r\n\r\n        // Either zero?\r\n        if (!xc[0] || !yc[0]) {\r\n\r\n          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :\r\n\r\n           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\r\n           ROUNDING_MODE == 3 ? -0 : 0);\r\n        }\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Determine which is the bigger number.\r\n      if (a = xe - ye) {\r\n\r\n        if (xLTy = a < 0) {\r\n          a = -a;\r\n          t = xc;\r\n        } else {\r\n          ye = xe;\r\n          t = yc;\r\n        }\r\n\r\n        t.reverse();\r\n\r\n        // Prepend zeros to equalise exponents.\r\n        for (b = a; b--; t.push(0));\r\n        t.reverse();\r\n      } else {\r\n\r\n        // Exponents equal. Check digit by digit.\r\n        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\r\n\r\n        for (a = b = 0; b < j; b++) {\r\n\r\n          if (xc[b] != yc[b]) {\r\n            xLTy = xc[b] < yc[b];\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // x < y? Point xc to the array of the bigger number.\r\n      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;\r\n\r\n      b = (j = yc.length) - (i = xc.length);\r\n\r\n      // Append zeros to xc if shorter.\r\n      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\r\n      if (b > 0) for (; b--; xc[i++] = 0);\r\n      b = BASE - 1;\r\n\r\n      // Subtract yc from xc.\r\n      for (; j > a;) {\r\n\r\n        if (xc[--j] < yc[j]) {\r\n          for (i = j; i && !xc[--i]; xc[i] = b);\r\n          --xc[i];\r\n          xc[j] += BASE;\r\n        }\r\n\r\n        xc[j] -= yc[j];\r\n      }\r\n\r\n      // Remove leading zeros and adjust exponent accordingly.\r\n      for (; xc[0] == 0; xc.splice(0, 1), --ye);\r\n\r\n      // Zero?\r\n      if (!xc[0]) {\r\n\r\n        // Following IEEE 754 (2008) 6.3,\r\n        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\r\n        y.s = ROUNDING_MODE == 3 ? -1 : 1;\r\n        y.c = [y.e = 0];\r\n        return y;\r\n      }\r\n\r\n      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\r\n      // for finite x and y.\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     *   n % 0 =  N\r\n     *   n % N =  N\r\n     *   n % I =  n\r\n     *   0 % n =  0\r\n     *  -0 % n = -0\r\n     *   0 % 0 =  N\r\n     *   0 % N =  N\r\n     *   0 % I =  0\r\n     *   N % n =  N\r\n     *   N % 0 =  N\r\n     *   N % N =  N\r\n     *   N % I =  N\r\n     *   I % n =  N\r\n     *   I % 0 =  N\r\n     *   I % N =  N\r\n     *   I % I =  N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n     * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n     */\r\n    P.modulo = P.mod = function (y, b) {\r\n      var q, s,\r\n        x = this;\r\n\r\n      y = new BigNumber(y, b);\r\n\r\n      // Return NaN if x is Infinity or NaN, or y is NaN or zero.\r\n      if (!x.c || !y.s || y.c && !y.c[0]) {\r\n        return new BigNumber(NaN);\r\n\r\n      // Return x if y is Infinity or x is zero.\r\n      } else if (!y.c || x.c && !x.c[0]) {\r\n        return new BigNumber(x);\r\n      }\r\n\r\n      if (MODULO_MODE == 9) {\r\n\r\n        // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n        // r = x - qy    where  0 <= r < abs(y)\r\n        s = y.s;\r\n        y.s = 1;\r\n        q = div(x, y, 0, 3);\r\n        y.s = s;\r\n        q.s *= s;\r\n      } else {\r\n        q = div(x, y, 0, MODULO_MODE);\r\n      }\r\n\r\n      y = x.minus(q.times(y));\r\n\r\n      // To match JavaScript %, ensure sign of zero is sign of dividend.\r\n      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\r\n\r\n      return y;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n * 0 = 0\r\n     *  n * N = N\r\n     *  n * I = I\r\n     *  0 * n = 0\r\n     *  0 * 0 = 0\r\n     *  0 * N = N\r\n     *  0 * I = N\r\n     *  N * n = N\r\n     *  N * 0 = N\r\n     *  N * N = N\r\n     *  N * I = N\r\n     *  I * n = I\r\n     *  I * 0 = N\r\n     *  I * N = N\r\n     *  I * I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n     * of BigNumber(y, b).\r\n     */\r\n    P.multipliedBy = P.times = function (y, b) {\r\n      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,\r\n        base, sqrtBase,\r\n        x = this,\r\n        xc = x.c,\r\n        yc = (y = new BigNumber(y, b)).c;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xc || !yc || !xc[0] || !yc[0]) {\r\n\r\n        // Return NaN if either is NaN, or one is 0 and the other is Infinity.\r\n        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\r\n          y.c = y.e = y.s = null;\r\n        } else {\r\n          y.s *= x.s;\r\n\r\n          // Return Infinity if either is Infinity.\r\n          if (!xc || !yc) {\r\n            y.c = y.e = null;\r\n\r\n          // Return 0 if either is 0.\r\n          } else {\r\n            y.c = [0];\r\n            y.e = 0;\r\n          }\r\n        }\r\n\r\n        return y;\r\n      }\r\n\r\n      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\r\n      y.s *= x.s;\r\n      xcL = xc.length;\r\n      ycL = yc.length;\r\n\r\n      // Ensure xc points to longer array and xcL to its length.\r\n      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;\r\n\r\n      // Initialise the result array with zeros.\r\n      for (i = xcL + ycL, zc = []; i--; zc.push(0));\r\n\r\n      base = BASE;\r\n      sqrtBase = SQRT_BASE;\r\n\r\n      for (i = ycL; --i >= 0;) {\r\n        c = 0;\r\n        ylo = yc[i] % sqrtBase;\r\n        yhi = yc[i] / sqrtBase | 0;\r\n\r\n        for (k = xcL, j = i + k; j > i;) {\r\n          xlo = xc[--k] % sqrtBase;\r\n          xhi = xc[k] / sqrtBase | 0;\r\n          m = yhi * xlo + xhi * ylo;\r\n          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;\r\n          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\r\n          zc[j--] = xlo % base;\r\n        }\r\n\r\n        zc[j] = c;\r\n      }\r\n\r\n      if (c) {\r\n        ++e;\r\n      } else {\r\n        zc.splice(0, 1);\r\n      }\r\n\r\n      return normalise(y, zc, e);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n     * i.e. multiplied by -1.\r\n     */\r\n    P.negated = function () {\r\n      var x = new BigNumber(this);\r\n      x.s = -x.s || null;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n + 0 = n\r\n     *  n + N = N\r\n     *  n + I = I\r\n     *  0 + n = n\r\n     *  0 + 0 = 0\r\n     *  0 + N = N\r\n     *  0 + I = I\r\n     *  N + n = N\r\n     *  N + 0 = N\r\n     *  N + N = N\r\n     *  N + I = N\r\n     *  I + n = I\r\n     *  I + 0 = I\r\n     *  I + N = N\r\n     *  I + I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.plus = function (y, b) {\r\n      var t,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n       if (a != b) {\r\n        y.s = -b;\r\n        return x.minus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Return Infinity if either Infinity.\r\n        if (!xc || !yc) return new BigNumber(a / 0);\r\n\r\n        // Either zero?\r\n        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\r\n      if (a = xe - ye) {\r\n        if (a > 0) {\r\n          ye = xe;\r\n          t = yc;\r\n        } else {\r\n          a = -a;\r\n          t = xc;\r\n        }\r\n\r\n        t.reverse();\r\n        for (; a--; t.push(0));\r\n        t.reverse();\r\n      }\r\n\r\n      a = xc.length;\r\n      b = yc.length;\r\n\r\n      // Point xc to the longer array, and b to the shorter length.\r\n      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;\r\n\r\n      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\r\n      for (a = 0; b;) {\r\n        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\r\n        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\r\n      }\r\n\r\n      if (a) {\r\n        xc = [a].concat(xc);\r\n        ++ye;\r\n      }\r\n\r\n      // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n      // ye = MAX_EXP + 1 possible\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     * If sd is undefined or null or true or false, return the number of significant digits of\r\n     * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n     * If sd is true include integer-part trailing zeros in the count.\r\n     *\r\n     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n     *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.precision = P.sd = function (sd, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (sd != null && sd !== !!sd) {\r\n        intCheck(sd, 1, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), sd, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      v = c.length - 1;\r\n      n = v * LOG_BASE + 1;\r\n\r\n      if (v = c[v]) {\r\n\r\n        // Subtract the number of trailing zeros of the last element.\r\n        for (; v % 10 == 0; v /= 10, n--);\r\n\r\n        // Add the number of digits of the first element.\r\n        for (v = c[0]; v >= 10; v /= 10, n++);\r\n      }\r\n\r\n      if (sd && x.e + 1 > n) n = x.e + 1;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n     *\r\n     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n     */\r\n    P.shiftedBy = function (k) {\r\n      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\r\n      return this.times('1e' + k);\r\n    };\r\n\r\n\r\n    /*\r\n     *  sqrt(-n) =  N\r\n     *  sqrt(N) =  N\r\n     *  sqrt(-I) =  N\r\n     *  sqrt(I) =  I\r\n     *  sqrt(0) =  0\r\n     *  sqrt(-0) = -0\r\n     *\r\n     * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.squareRoot = P.sqrt = function () {\r\n      var m, n, r, rep, t,\r\n        x = this,\r\n        c = x.c,\r\n        s = x.s,\r\n        e = x.e,\r\n        dp = DECIMAL_PLACES + 4,\r\n        half = new BigNumber('0.5');\r\n\r\n      // Negative/NaN/Infinity/zero?\r\n      if (s !== 1 || !c || !c[0]) {\r\n        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\r\n      }\r\n\r\n      // Initial estimate.\r\n      s = Math.sqrt(+valueOf(x));\r\n\r\n      // Math.sqrt underflow/overflow?\r\n      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n      if (s == 0 || s == 1 / 0) {\r\n        n = coeffToString(c);\r\n        if ((n.length + e) % 2 == 0) n += '0';\r\n        s = Math.sqrt(+n);\r\n        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n        if (s == 1 / 0) {\r\n          n = '1e' + e;\r\n        } else {\r\n          n = s.toExponential();\r\n          n = n.slice(0, n.indexOf('e') + 1) + e;\r\n        }\r\n\r\n        r = new BigNumber(n);\r\n      } else {\r\n        r = new BigNumber(s + '');\r\n      }\r\n\r\n      // Check for zero.\r\n      // r could be zero if MIN_EXP is changed after the this value was created.\r\n      // This would cause a division by zero (x/t) and hence Infinity below, which would cause\r\n      // coeffToString to throw.\r\n      if (r.c[0]) {\r\n        e = r.e;\r\n        s = e + dp;\r\n        if (s < 3) s = 0;\r\n\r\n        // Newton-Raphson iteration.\r\n        for (; ;) {\r\n          t = r;\r\n          r = half.times(t.plus(div(x, t, dp, 1)));\r\n\r\n          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\r\n\r\n            // The exponent of r may here be one less than the final result exponent,\r\n            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\r\n            // are indexed correctly.\r\n            if (r.e < e) --s;\r\n            n = n.slice(s - 3, s + 1);\r\n\r\n            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\r\n            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\r\n            // iteration.\r\n            if (n == '9999' || !rep && n == '4999') {\r\n\r\n              // On the first iteration only, check to see if rounding up gives the\r\n              // exact result as the nines may infinitely repeat.\r\n              if (!rep) {\r\n                round(t, t.e + DECIMAL_PLACES + 2, 0);\r\n\r\n                if (t.times(t).eq(x)) {\r\n                  r = t;\r\n                  break;\r\n                }\r\n              }\r\n\r\n              dp += 4;\r\n              s += 4;\r\n              rep = 1;\r\n            } else {\r\n\r\n              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\r\n              // result. If not, then there are further digits and m will be truthy.\r\n              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n                // Truncate to the first rounding digit.\r\n                round(r, r.e + DECIMAL_PLACES + 2, 1);\r\n                m = !r.times(r).eq(x);\r\n              }\r\n\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in exponential notation and\r\n     * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toExponential = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp++;\r\n      }\r\n      return format(this, dp, rm, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n     * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toFixed = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp = dp + this.e + 1;\r\n      }\r\n      return format(this, dp, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n     * of the format or FORMAT object (see BigNumber.set).\r\n     *\r\n     * The formatting object may contain some or all of the properties shown below.\r\n     *\r\n     * FORMAT = {\r\n     *   prefix: '',\r\n     *   groupSize: 3,\r\n     *   secondaryGroupSize: 0,\r\n     *   groupSeparator: ',',\r\n     *   decimalSeparator: '.',\r\n     *   fractionGroupSize: 0,\r\n     *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n     *   suffix: ''\r\n     * };\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     * [format] {object} Formatting options. See FORMAT pbject above.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     * '[BigNumber Error] Argument not an object: {format}'\r\n     */\r\n    P.toFormat = function (dp, rm, format) {\r\n      var str,\r\n        x = this;\r\n\r\n      if (format == null) {\r\n        if (dp != null && rm && typeof rm == 'object') {\r\n          format = rm;\r\n          rm = null;\r\n        } else if (dp && typeof dp == 'object') {\r\n          format = dp;\r\n          dp = rm = null;\r\n        } else {\r\n          format = FORMAT;\r\n        }\r\n      } else if (typeof format != 'object') {\r\n        throw Error\r\n          (bignumberError + 'Argument not an object: ' + format);\r\n      }\r\n\r\n      str = x.toFixed(dp, rm);\r\n\r\n      if (x.c) {\r\n        var i,\r\n          arr = str.split('.'),\r\n          g1 = +format.groupSize,\r\n          g2 = +format.secondaryGroupSize,\r\n          groupSeparator = format.groupSeparator || '',\r\n          intPart = arr[0],\r\n          fractionPart = arr[1],\r\n          isNeg = x.s < 0,\r\n          intDigits = isNeg ? intPart.slice(1) : intPart,\r\n          len = intDigits.length;\r\n\r\n        if (g2) i = g1, g1 = g2, g2 = i, len -= i;\r\n\r\n        if (g1 > 0 && len > 0) {\r\n          i = len % g1 || g1;\r\n          intPart = intDigits.substr(0, i);\r\n          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);\r\n          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\r\n          if (isNeg) intPart = '-' + intPart;\r\n        }\r\n\r\n        str = fractionPart\r\n         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)\r\n          ? fractionPart.replace(new RegExp('\\\\d{' + g2 + '}\\\\B', 'g'),\r\n           '$&' + (format.fractionGroupSeparator || ''))\r\n          : fractionPart)\r\n         : intPart;\r\n      }\r\n\r\n      return (format.prefix || '') + str + (format.suffix || '');\r\n    };\r\n\r\n\r\n    /*\r\n     * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n     * fraction with an integer numerator and an integer denominator.\r\n     * The denominator will be a positive non-zero value less than or equal to the specified\r\n     * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n     * the lowest value necessary to represent the number exactly.\r\n     *\r\n     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n     *\r\n     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n     */\r\n    P.toFraction = function (md) {\r\n      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,\r\n        x = this,\r\n        xc = x.c;\r\n\r\n      if (md != null) {\r\n        n = new BigNumber(md);\r\n\r\n        // Throw if md is less than one or is not an integer, unless it is Infinity.\r\n        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\r\n          throw Error\r\n            (bignumberError + 'Argument ' +\r\n              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));\r\n        }\r\n      }\r\n\r\n      if (!xc) return new BigNumber(x);\r\n\r\n      d = new BigNumber(ONE);\r\n      n1 = d0 = new BigNumber(ONE);\r\n      d1 = n0 = new BigNumber(ONE);\r\n      s = coeffToString(xc);\r\n\r\n      // Determine initial denominator.\r\n      // d is a power of 10 and the minimum max denominator that specifies the value exactly.\r\n      e = d.e = s.length - x.e - 1;\r\n      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\r\n      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;\r\n\r\n      exp = MAX_EXP;\r\n      MAX_EXP = 1 / 0;\r\n      n = new BigNumber(s);\r\n\r\n      // n0 = d1 = 0\r\n      n0.c[0] = 0;\r\n\r\n      for (; ;)  {\r\n        q = div(n, d, 0, 1);\r\n        d2 = d0.plus(q.times(d1));\r\n        if (d2.comparedTo(md) == 1) break;\r\n        d0 = d1;\r\n        d1 = d2;\r\n        n1 = n0.plus(q.times(d2 = n1));\r\n        n0 = d2;\r\n        d = n.minus(q.times(d2 = d));\r\n        n = d2;\r\n      }\r\n\r\n      d2 = div(md.minus(d0), d1, 0, 1);\r\n      n0 = n0.plus(d2.times(n1));\r\n      d0 = d0.plus(d2.times(d1));\r\n      n0.s = n1.s = x.s;\r\n      e = e * 2;\r\n\r\n      // Determine which fraction is closer to x, n0/d0 or n1/d1\r\n      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(\r\n          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\r\n\r\n      MAX_EXP = exp;\r\n\r\n      return r;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return the value of this BigNumber converted to a number primitive.\r\n     */\r\n    P.toNumber = function () {\r\n      return +valueOf(this);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n     * necessary to represent the integer part of the value in fixed-point notation, then use\r\n     * exponential notation.\r\n     *\r\n     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.toPrecision = function (sd, rm) {\r\n      if (sd != null) intCheck(sd, 1, MAX);\r\n      return format(this, sd, rm, 2);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n     * TO_EXP_NEG, return exponential notation.\r\n     *\r\n     * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n     *\r\n     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n     */\r\n    P.toString = function (b) {\r\n      var str,\r\n        n = this,\r\n        s = n.s,\r\n        e = n.e;\r\n\r\n      // Infinity or NaN?\r\n      if (e === null) {\r\n        if (s) {\r\n          str = 'Infinity';\r\n          if (s < 0) str = '-' + str;\r\n        } else {\r\n          str = 'NaN';\r\n        }\r\n      } else {\r\n        str = coeffToString(n.c);\r\n\r\n        if (b == null) {\r\n          str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n           ? toExponential(str, e)\r\n           : toFixedPoint(str, e, '0');\r\n        } else {\r\n          intCheck(b, 2, ALPHABET.length, 'Base');\r\n          str = convertBase(toFixedPoint(str, e, '0'), 10, b, s, true);\r\n        }\r\n\r\n        if (s < 0 && n.c[0]) str = '-' + str;\r\n      }\r\n\r\n      return str;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return as toString, but do not accept a base argument, and include the minus sign for\r\n     * negative zero.\r\n     */\r\n    P.valueOf = P.toJSON = function () {\r\n      return valueOf(this);\r\n    };\r\n\r\n\r\n    P._isBigNumber = true;\r\n\r\n    if (typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol') {\r\n      P[Symbol.toStringTag] = 'BigNumber';\r\n      // Node.js v10.12.0+\r\n      P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;\r\n    }\r\n\r\n    if (configObject != null) BigNumber.set(configObject);\r\n\r\n    return BigNumber;\r\n  }\r\n\r\n\r\n  // PRIVATE HELPER FUNCTIONS\r\n\r\n\r\n  function bitFloor(n) {\r\n    var i = n | 0;\r\n    return n > 0 || n === i ? i : i - 1;\r\n  }\r\n\r\n\r\n  // Return a coefficient array as a string of base 10 digits.\r\n  function coeffToString(a) {\r\n    var s, z,\r\n      i = 1,\r\n      j = a.length,\r\n      r = a[0] + '';\r\n\r\n    for (; i < j;) {\r\n      s = a[i++] + '';\r\n      z = LOG_BASE - s.length;\r\n      for (; z--; s = '0' + s);\r\n      r += s;\r\n    }\r\n\r\n    // Determine trailing zeros.\r\n    for (j = r.length; r.charCodeAt(--j) === 48;);\r\n\r\n    return r.slice(0, j + 1 || 1);\r\n  }\r\n\r\n\r\n  // Compare the value of BigNumbers x and y.\r\n  function compare(x, y) {\r\n    var a, b,\r\n      xc = x.c,\r\n      yc = y.c,\r\n      i = x.s,\r\n      j = y.s,\r\n      k = x.e,\r\n      l = y.e;\r\n\r\n    // Either NaN?\r\n    if (!i || !j) return null;\r\n\r\n    a = xc && !xc[0];\r\n    b = yc && !yc[0];\r\n\r\n    // Either zero?\r\n    if (a || b) return a ? b ? 0 : -j : i;\r\n\r\n    // Signs differ?\r\n    if (i != j) return i;\r\n\r\n    a = i < 0;\r\n    b = k == l;\r\n\r\n    // Either Infinity?\r\n    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\r\n\r\n    // Compare exponents.\r\n    if (!b) return k > l ^ a ? 1 : -1;\r\n\r\n    j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n    // Compare digit by digit.\r\n    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\r\n\r\n    // Compare lengths.\r\n    return k == l ? 0 : k > l ^ a ? 1 : -1;\r\n  }\r\n\r\n\r\n  /*\r\n   * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n   */\r\n  function intCheck(n, min, max, name) {\r\n    if (n < min || n > max || n !== (n < 0 ? mathceil(n) : mathfloor(n))) {\r\n      throw Error\r\n       (bignumberError + (name || 'Argument') + (typeof n == 'number'\r\n         ? n < min || n > max ? ' out of range: ' : ' not an integer: '\r\n         : ' not a primitive number: ') + String(n));\r\n    }\r\n  }\r\n\r\n\r\n  // Assumes finite n.\r\n  function isOdd(n) {\r\n    var k = n.c.length - 1;\r\n    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\r\n  }\r\n\r\n\r\n  function toExponential(str, e) {\r\n    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +\r\n     (e < 0 ? 'e' : 'e+') + e;\r\n  }\r\n\r\n\r\n  function toFixedPoint(str, e, z) {\r\n    var len, zs;\r\n\r\n    // Negative exponent?\r\n    if (e < 0) {\r\n\r\n      // Prepend zeros.\r\n      for (zs = z + '.'; ++e; zs += z);\r\n      str = zs + str;\r\n\r\n    // Positive exponent\r\n    } else {\r\n      len = str.length;\r\n\r\n      // Append zeros.\r\n      if (++e > len) {\r\n        for (zs = z, e -= len; --e; zs += z);\r\n        str += zs;\r\n      } else if (e < len) {\r\n        str = str.slice(0, e) + '.' + str.slice(e);\r\n      }\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n\r\n  // EXPORT\r\n\r\n\r\n  BigNumber = clone();\r\n  BigNumber['default'] = BigNumber.BigNumber = BigNumber;\r\n\r\n  // AMD.\r\n  if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return BigNumber; }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\r\n  // Node.js and other environments that support module.exports.\r\n  } else {}\r\n})(this);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlnbnVtYmVyLmpzL2JpZ251bWJlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iaWdudW1iZXIuanMvYmlnbnVtYmVyLmpzPzkwMWUiXSwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbiAoZ2xvYmFsT2JqZWN0KSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuLypcclxuICogICAgICBiaWdudW1iZXIuanMgdjguMC4xXHJcbiAqICAgICAgQSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGFyYml0cmFyeS1wcmVjaXNpb24gYXJpdGhtZXRpYy5cclxuICogICAgICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWdudW1iZXIuanNcclxuICogICAgICBDb3B5cmlnaHQgKGMpIDIwMTggTWljaGFlbCBNY2xhdWdobGluIDxNOGNoODhsQGdtYWlsLmNvbT5cclxuICogICAgICBNSVQgTGljZW5zZWQuXHJcbiAqXHJcbiAqICAgICAgQmlnTnVtYmVyLnByb3RvdHlwZSBtZXRob2RzICAgICB8ICBCaWdOdW1iZXIgbWV0aG9kc1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIGFic29sdXRlVmFsdWUgICAgICAgICAgICBhYnMgICAgfCAgY2xvbmVcclxuICogICAgICBjb21wYXJlZFRvICAgICAgICAgICAgICAgICAgICAgIHwgIGNvbmZpZyAgICAgICAgICAgICAgIHNldFxyXG4gKiAgICAgIGRlY2ltYWxQbGFjZXMgICAgICAgICAgICBkcCAgICAgfCAgICAgIERFQ0lNQUxfUExBQ0VTXHJcbiAqICAgICAgZGl2aWRlZEJ5ICAgICAgICAgICAgICAgIGRpdiAgICB8ICAgICAgUk9VTkRJTkdfTU9ERVxyXG4gKiAgICAgIGRpdmlkZWRUb0ludGVnZXJCeSAgICAgICBpZGl2ICAgfCAgICAgIEVYUE9ORU5USUFMX0FUXHJcbiAqICAgICAgZXhwb25lbnRpYXRlZEJ5ICAgICAgICAgIHBvdyAgICB8ICAgICAgUkFOR0VcclxuICogICAgICBpbnRlZ2VyVmFsdWUgICAgICAgICAgICAgICAgICAgIHwgICAgICBDUllQVE9cclxuICogICAgICBpc0VxdWFsVG8gICAgICAgICAgICAgICAgZXEgICAgIHwgICAgICBNT0RVTE9fTU9ERVxyXG4gKiAgICAgIGlzRmluaXRlICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgIFBPV19QUkVDSVNJT05cclxuICogICAgICBpc0dyZWF0ZXJUaGFuICAgICAgICAgICAgZ3QgICAgIHwgICAgICBGT1JNQVRcclxuICogICAgICBpc0dyZWF0ZXJUaGFuT3JFcXVhbFRvICAgZ3RlICAgIHwgICAgICBBTFBIQUJFVFxyXG4gKiAgICAgIGlzSW50ZWdlciAgICAgICAgICAgICAgICAgICAgICAgfCAgaXNCaWdOdW1iZXJcclxuICogICAgICBpc0xlc3NUaGFuICAgICAgICAgICAgICAgbHQgICAgIHwgIG1heGltdW0gICAgICAgICAgICAgIG1heFxyXG4gKiAgICAgIGlzTGVzc1RoYW5PckVxdWFsVG8gICAgICBsdGUgICAgfCAgbWluaW11bSAgICAgICAgICAgICAgbWluXHJcbiAqICAgICAgaXNOYU4gICAgICAgICAgICAgICAgICAgICAgICAgICB8ICByYW5kb21cclxuICogICAgICBpc05lZ2F0aXZlICAgICAgICAgICAgICAgICAgICAgIHwgIHN1bVxyXG4gKiAgICAgIGlzUG9zaXRpdmUgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIGlzWmVybyAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIG1pbnVzICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIG1vZHVsbyAgICAgICAgICAgICAgICAgICBtb2QgICAgfFxyXG4gKiAgICAgIG11bHRpcGxpZWRCeSAgICAgICAgICAgICB0aW1lcyAgfFxyXG4gKiAgICAgIG5lZ2F0ZWQgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHBsdXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHByZWNpc2lvbiAgICAgICAgICAgICAgICBzZCAgICAgfFxyXG4gKiAgICAgIHNoaWZ0ZWRCeSAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHNxdWFyZVJvb3QgICAgICAgICAgICAgICBzcXJ0ICAgfFxyXG4gKiAgICAgIHRvRXhwb25lbnRpYWwgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRml4ZWQgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRm9ybWF0ICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRnJhY3Rpb24gICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvSlNPTiAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvTnVtYmVyICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvUHJlY2lzaW9uICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvU3RyaW5nICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHZhbHVlT2YgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKlxyXG4gKi9cclxuXHJcblxyXG4gIHZhciBCaWdOdW1iZXIsXHJcbiAgICBpc051bWVyaWMgPSAvXi0/KD86XFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSg/OmVbKy1dP1xcZCspPyQvaSxcclxuXHJcbiAgICBtYXRoY2VpbCA9IE1hdGguY2VpbCxcclxuICAgIG1hdGhmbG9vciA9IE1hdGguZmxvb3IsXHJcblxyXG4gICAgYmlnbnVtYmVyRXJyb3IgPSAnW0JpZ051bWJlciBFcnJvcl0gJyxcclxuICAgIHRvb01hbnlEaWdpdHMgPSBiaWdudW1iZXJFcnJvciArICdOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiAnLFxyXG5cclxuICAgIEJBU0UgPSAxZTE0LFxyXG4gICAgTE9HX0JBU0UgPSAxNCxcclxuICAgIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmLCAgICAgICAgIC8vIDJeNTMgLSAxXHJcbiAgICAvLyBNQVhfSU5UMzIgPSAweDdmZmZmZmZmLCAgICAgICAgICAgICAgICAgICAvLyAyXjMxIC0gMVxyXG4gICAgUE9XU19URU4gPSBbMSwgMTAsIDEwMCwgMWUzLCAxZTQsIDFlNSwgMWU2LCAxZTcsIDFlOCwgMWU5LCAxZTEwLCAxZTExLCAxZTEyLCAxZTEzXSxcclxuICAgIFNRUlRfQkFTRSA9IDFlNyxcclxuXHJcbiAgICAvLyBFRElUQUJMRVxyXG4gICAgLy8gVGhlIGxpbWl0IG9uIHRoZSB2YWx1ZSBvZiBERUNJTUFMX1BMQUNFUywgVE9fRVhQX05FRywgVE9fRVhQX1BPUywgTUlOX0VYUCwgTUFYX0VYUCwgYW5kXHJcbiAgICAvLyB0aGUgYXJndW1lbnRzIHRvIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0LCBhbmQgdG9QcmVjaXNpb24uXHJcbiAgICBNQVggPSAxRTk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWF9JTlQzMlxyXG5cclxuXHJcbiAgLypcclxuICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIEJpZ051bWJlciBjb25zdHJ1Y3Rvci5cclxuICAgKi9cclxuICBmdW5jdGlvbiBjbG9uZShjb25maWdPYmplY3QpIHtcclxuICAgIHZhciBkaXYsIGNvbnZlcnRCYXNlLCBwYXJzZU51bWVyaWMsXHJcbiAgICAgIFAgPSBCaWdOdW1iZXIucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQmlnTnVtYmVyLCB0b1N0cmluZzogbnVsbCwgdmFsdWVPZjogbnVsbCB9LFxyXG4gICAgICBPTkUgPSBuZXcgQmlnTnVtYmVyKDEpLFxyXG5cclxuXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRURJVEFCTEUgQ09ORklHIERFRkFVTFRTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZXMgYmVsb3cgbXVzdCBiZSBpbnRlZ2VycyB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZXMgc3RhdGVkLlxyXG4gICAgICAvLyBUaGUgdmFsdWVzIGNhbiBhbHNvIGJlIGNoYW5nZWQgYXQgcnVuLXRpbWUgdXNpbmcgQmlnTnVtYmVyLnNldC5cclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3Igb3BlcmF0aW9ucyBpbnZvbHZpbmcgZGl2aXNpb24uXHJcbiAgICAgIERFQ0lNQUxfUExBQ0VTID0gMjAsICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFRoZSByb3VuZGluZyBtb2RlIHVzZWQgd2hlbiByb3VuZGluZyB0byB0aGUgYWJvdmUgZGVjaW1hbCBwbGFjZXMsIGFuZCB3aGVuIHVzaW5nXHJcbiAgICAgIC8vIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0IGFuZCB0b1ByZWNpc2lvbiwgYW5kIHJvdW5kIChkZWZhdWx0IHZhbHVlKS5cclxuICAgICAgLy8gVVAgICAgICAgICAwIEF3YXkgZnJvbSB6ZXJvLlxyXG4gICAgICAvLyBET1dOICAgICAgIDEgVG93YXJkcyB6ZXJvLlxyXG4gICAgICAvLyBDRUlMICAgICAgIDIgVG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgIC8vIEZMT09SICAgICAgMyBUb3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgLy8gSEFMRl9VUCAgICA0IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB1cC5cclxuICAgICAgLy8gSEFMRl9ET1dOICA1IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCBkb3duLlxyXG4gICAgICAvLyBIQUxGX0VWRU4gIDYgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgZXZlbiBuZWlnaGJvdXIuXHJcbiAgICAgIC8vIEhBTEZfQ0VJTCAgNyBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgIC8vIEhBTEZfRkxPT1IgOCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIFJPVU5ESU5HX01PREUgPSA0LCAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA4XHJcblxyXG4gICAgICAvLyBFWFBPTkVOVElBTF9BVCA6IFtUT19FWFBfTkVHICwgVE9fRVhQX1BPU11cclxuXHJcbiAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYmVuZWF0aCB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogLTdcclxuICAgICAgVE9fRVhQX05FRyA9IC03LCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIC1NQVhcclxuXHJcbiAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYWJvdmUgd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IDIxXHJcbiAgICAgIFRPX0VYUF9QT1MgPSAyMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFJBTkdFIDogW01JTl9FWFAsIE1BWF9FWFBdXHJcblxyXG4gICAgICAvLyBUaGUgbWluaW11bSBleHBvbmVudCB2YWx1ZSwgYmVuZWF0aCB3aGljaCB1bmRlcmZsb3cgdG8gemVybyBvY2N1cnMuXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAtMzI0ICAoNWUtMzI0KVxyXG4gICAgICBNSU5fRVhQID0gLTFlNywgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0xIHRvIC1NQVhcclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIGV4cG9uZW50IHZhbHVlLCBhYm92ZSB3aGljaCBvdmVyZmxvdyB0byBJbmZpbml0eSBvY2N1cnMuXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAgMzA4ICAoMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpXHJcbiAgICAgIC8vIEZvciBNQVhfRVhQID4gMWU3LCBlLmcuIG5ldyBCaWdOdW1iZXIoJzFlMTAwMDAwMDAwJykucGx1cygxKSBtYXkgYmUgc2xvdy5cclxuICAgICAgTUFYX0VYUCA9IDFlNywgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxIHRvIE1BWFxyXG5cclxuICAgICAgLy8gV2hldGhlciB0byB1c2UgY3J5cHRvZ3JhcGhpY2FsbHktc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiwgaWYgYXZhaWxhYmxlLlxyXG4gICAgICBDUllQVE8gPSBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgb3IgZmFsc2VcclxuXHJcbiAgICAgIC8vIFRoZSBtb2R1bG8gbW9kZSB1c2VkIHdoZW4gY2FsY3VsYXRpbmcgdGhlIG1vZHVsdXM6IGEgbW9kIG4uXHJcbiAgICAgIC8vIFRoZSBxdW90aWVudCAocSA9IGEgLyBuKSBpcyBjYWxjdWxhdGVkIGFjY29yZGluZyB0byB0aGUgY29ycmVzcG9uZGluZyByb3VuZGluZyBtb2RlLlxyXG4gICAgICAvLyBUaGUgcmVtYWluZGVyIChyKSBpcyBjYWxjdWxhdGVkIGFzOiByID0gYSAtIG4gKiBxLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBVUCAgICAgICAgMCBUaGUgcmVtYWluZGVyIGlzIHBvc2l0aXZlIGlmIHRoZSBkaXZpZGVuZCBpcyBuZWdhdGl2ZSwgZWxzZSBpcyBuZWdhdGl2ZS5cclxuICAgICAgLy8gRE9XTiAgICAgIDEgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aWRlbmQuXHJcbiAgICAgIC8vICAgICAgICAgICAgIFRoaXMgbW9kdWxvIG1vZGUgaXMgY29tbW9ubHkga25vd24gYXMgJ3RydW5jYXRlZCBkaXZpc2lvbicgYW5kIGlzXHJcbiAgICAgIC8vICAgICAgICAgICAgIGVxdWl2YWxlbnQgdG8gKGEgJSBuKSBpbiBKYXZhU2NyaXB0LlxyXG4gICAgICAvLyBGTE9PUiAgICAgMyBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpc29yIChQeXRob24gJSkuXHJcbiAgICAgIC8vIEhBTEZfRVZFTiA2IFRoaXMgbW9kdWxvIG1vZGUgaW1wbGVtZW50cyB0aGUgSUVFRSA3NTQgcmVtYWluZGVyIGZ1bmN0aW9uLlxyXG4gICAgICAvLyBFVUNMSUQgICAgOSBFdWNsaWRpYW4gZGl2aXNpb24uIHEgPSBzaWduKG4pICogZmxvb3IoYSAvIGFicyhuKSkuXHJcbiAgICAgIC8vICAgICAgICAgICAgIFRoZSByZW1haW5kZXIgaXMgYWx3YXlzIHBvc2l0aXZlLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBUaGUgdHJ1bmNhdGVkIGRpdmlzaW9uLCBmbG9vcmVkIGRpdmlzaW9uLCBFdWNsaWRpYW4gZGl2aXNpb24gYW5kIElFRUUgNzU0IHJlbWFpbmRlclxyXG4gICAgICAvLyBtb2RlcyBhcmUgY29tbW9ubHkgdXNlZCBmb3IgdGhlIG1vZHVsdXMgb3BlcmF0aW9uLlxyXG4gICAgICAvLyBBbHRob3VnaCB0aGUgb3RoZXIgcm91bmRpbmcgbW9kZXMgY2FuIGFsc28gYmUgdXNlZCwgdGhleSBtYXkgbm90IGdpdmUgdXNlZnVsIHJlc3VsdHMuXHJcbiAgICAgIE1PRFVMT19NT0RFID0gMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA5XHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHRoZSByZXN1bHQgb2YgdGhlIGV4cG9uZW50aWF0ZWRCeSBvcGVyYXRpb24uXHJcbiAgICAgIC8vIElmIFBPV19QUkVDSVNJT04gaXMgMCwgdGhlcmUgd2lsbCBiZSB1bmxpbWl0ZWQgc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgICBQT1dfUFJFQ0lTSU9OID0gMCwgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBUaGUgZm9ybWF0IHNwZWNpZmljYXRpb24gdXNlZCBieSB0aGUgQmlnTnVtYmVyLnByb3RvdHlwZS50b0Zvcm1hdCBtZXRob2QuXHJcbiAgICAgIEZPUk1BVCA9IHtcclxuICAgICAgICBwcmVmaXg6ICcnLFxyXG4gICAgICAgIGdyb3VwU2l6ZTogMyxcclxuICAgICAgICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAgICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICAgICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAgICBzdWZmaXg6ICcnXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBUaGUgYWxwaGFiZXQgdXNlZCBmb3IgYmFzZSBjb252ZXJzaW9uLiBJdCBtdXN0IGJlIGF0IGxlYXN0IDIgY2hhcmFjdGVycyBsb25nLCB3aXRoIG5vICcrJyxcclxuICAgICAgLy8gJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgLy8gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJF8nXHJcbiAgICAgIEFMUEhBQkVUID0gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eic7XHJcblxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgIC8vIENPTlNUUlVDVE9SXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgQmlnTnVtYmVyIGNvbnN0cnVjdG9yIGFuZCBleHBvcnRlZCBmdW5jdGlvbi5cclxuICAgICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgQmlnTnVtYmVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBuIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gQSBudW1lcmljIHZhbHVlLlxyXG4gICAgICogW2JdIHtudW1iZXJ9IFRoZSBiYXNlIG9mIG4uIEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQmlnTnVtYmVyKG4sIGIpIHtcclxuICAgICAgdmFyIGFscGhhYmV0LCBjLCBjYXNlQ2hhbmdlZCwgZSwgaSwgaXNOdW0sIGxlbiwgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgLy8gRW5hYmxlIGNvbnN0cnVjdG9yIHVzYWdlIHdpdGhvdXQgbmV3LlxyXG4gICAgICBpZiAoISh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSkge1xyXG5cclxuICAgICAgICAvLyBEb24ndCB0aHJvdyBvbiBjb25zdHJ1Y3RvciBjYWxsIHdpdGhvdXQgbmV3ICgjODEpLlxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBDb25zdHJ1Y3RvciBjYWxsIHdpdGhvdXQgbmV3OiB7bn0nXHJcbiAgICAgICAgLy90aHJvdyBFcnJvcihiaWdudW1iZXJFcnJvciArICcgQ29uc3RydWN0b3IgY2FsbCB3aXRob3V0IG5ldzogJyArIG4pO1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKG4sIGIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYiA9PSBudWxsKSB7XHJcblxyXG4gICAgICAgIC8vIER1cGxpY2F0ZS5cclxuICAgICAgICBpZiAobiBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xyXG4gICAgICAgICAgeC5zID0gbi5zO1xyXG4gICAgICAgICAgeC5lID0gbi5lO1xyXG4gICAgICAgICAgeC5jID0gKG4gPSBuLmMpID8gbi5zbGljZSgpIDogbjtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlzTnVtID0gdHlwZW9mIG4gPT0gJ251bWJlcic7XHJcblxyXG4gICAgICAgIGlmIChpc051bSAmJiBuICogMCA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gVXNlIGAxIC8gbmAgdG8gaGFuZGxlIG1pbnVzIHplcm8gYWxzby5cclxuICAgICAgICAgIHgucyA9IDEgLyBuIDwgMCA/IChuID0gLW4sIC0xKSA6IDE7XHJcblxyXG4gICAgICAgICAgLy8gRmFzdGVyIHBhdGggZm9yIGludGVnZXJzLlxyXG4gICAgICAgICAgaWYgKG4gPT09IH5+bikge1xyXG4gICAgICAgICAgICBmb3IgKGUgPSAwLCBpID0gbjsgaSA+PSAxMDsgaSAvPSAxMCwgZSsrKTtcclxuICAgICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgICAgeC5jID0gW25dO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc3RyID0gU3RyaW5nKG4pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzdHIgPSBTdHJpbmcobik7XHJcbiAgICAgICAgICBpZiAoIWlzTnVtZXJpYy50ZXN0KHN0cikpIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSk7XHJcbiAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBmb3JtP1xyXG4gICAgICAgIGlmICgoaSA9IHN0ci5zZWFyY2goL2UvaSkpID4gMCkge1xyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSBleHBvbmVudC5cclxuICAgICAgICAgIGlmIChlIDwgMCkgZSA9IGk7XHJcbiAgICAgICAgICBlICs9ICtzdHIuc2xpY2UoaSArIDEpO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW50ZWdlci5cclxuICAgICAgICAgIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcbiAgICAgICAgc3RyID0gU3RyaW5nKG4pO1xyXG5cclxuICAgICAgICAvLyBBbGxvdyBleHBvbmVudGlhbCBub3RhdGlvbiB0byBiZSB1c2VkIHdpdGggYmFzZSAxMCBhcmd1bWVudCwgd2hpbGVcclxuICAgICAgICAvLyBhbHNvIHJvdW5kaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFzIHdpdGggb3RoZXIgYmFzZXMuXHJcbiAgICAgICAgaWYgKGIgPT0gMTApIHtcclxuICAgICAgICAgIHggPSBuZXcgQmlnTnVtYmVyKG4gaW5zdGFuY2VvZiBCaWdOdW1iZXIgPyBuIDogc3RyKTtcclxuICAgICAgICAgIHJldHVybiByb3VuZCh4LCBERUNJTUFMX1BMQUNFUyArIHguZSArIDEsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaXNOdW0gPSB0eXBlb2YgbiA9PSAnbnVtYmVyJztcclxuXHJcbiAgICAgICAgaWYgKGlzTnVtKSB7XHJcblxyXG4gICAgICAgICAgLy8gQXZvaWQgcG90ZW50aWFsIGludGVycHJldGF0aW9uIG9mIEluZmluaXR5IGFuZCBOYU4gYXMgYmFzZSA0NCsgdmFsdWVzLlxyXG4gICAgICAgICAgaWYgKG4gKiAwICE9IDApIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSwgYik7XHJcblxyXG4gICAgICAgICAgeC5zID0gMSAvIG4gPCAwID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRyAmJiBzdHIucmVwbGFjZSgvXjBcXC4wKnxcXC4vLCAnJykubGVuZ3RoID4gMTUpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgbik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUHJldmVudCBsYXRlciBjaGVjayBmb3IgbGVuZ3RoIG9uIGNvbnZlcnRlZCBudW1iZXIuXHJcbiAgICAgICAgICBpc051bSA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PT0gNDUgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYWxwaGFiZXQgPSBBTFBIQUJFVC5zbGljZSgwLCBiKTtcclxuICAgICAgICBlID0gaSA9IDA7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRoYXQgc3RyIGlzIGEgdmFsaWQgYmFzZSBiIG51bWJlci5cclxuICAgICAgICAvLyBEb24ndCB1c2UgUmVnRXhwIHNvIGFscGhhYmV0IGNhbiBjb250YWluIHNwZWNpYWwgY2hhcmFjdGVycy5cclxuICAgICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgaWYgKGFscGhhYmV0LmluZGV4T2YoYyA9IHN0ci5jaGFyQXQoaSkpIDwgMCkge1xyXG4gICAgICAgICAgICBpZiAoYyA9PSAnLicpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgJy4nIGlzIG5vdCB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBpdCBoYXMgbm90IGJlIGZvdW5kIGJlZm9yZS5cclxuICAgICAgICAgICAgICBpZiAoaSA+IGUpIHtcclxuICAgICAgICAgICAgICAgIGUgPSBsZW47XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNhc2VDaGFuZ2VkKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEFsbG93IGUuZy4gaGV4YWRlY2ltYWwgJ0ZGJyBhcyB3ZWxsIGFzICdmZicuXHJcbiAgICAgICAgICAgICAgaWYgKHN0ciA9PSBzdHIudG9VcHBlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvTG93ZXJDYXNlKCkpIHx8XHJcbiAgICAgICAgICAgICAgICAgIHN0ciA9PSBzdHIudG9Mb3dlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvVXBwZXJDYXNlKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpID0gLTE7XHJcbiAgICAgICAgICAgICAgICBlID0gMDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBTdHJpbmcobiksIGlzTnVtLCBiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHN0ciwgYiwgMTAsIHgucyk7XHJcblxyXG4gICAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgICAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgZWxzZSBlID0gc3RyLmxlbmd0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoaSA9IDA7IHN0ci5jaGFyQ29kZUF0KGkpID09PSA0ODsgaSsrKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBzdHIuY2hhckNvZGVBdCgtLWxlbikgPT09IDQ4Oyk7XHJcblxyXG4gICAgICBzdHIgPSBzdHIuc2xpY2UoaSwgKytsZW4pO1xyXG5cclxuICAgICAgaWYgKHN0cikge1xyXG4gICAgICAgIGxlbiAtPSBpO1xyXG5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgIGlmIChpc051bSAmJiBCaWdOdW1iZXIuREVCVUcgJiZcclxuICAgICAgICAgIGxlbiA+IDE1ICYmIChuID4gTUFYX1NBRkVfSU5URUdFUiB8fCBuICE9PSBtYXRoZmxvb3IobikpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAodG9vTWFueURpZ2l0cyArICh4LnMgKiBuKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlID0gZSAtIGkgLSAxO1xyXG5cclxuICAgICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgICAgaWYgKGUgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgICAgfSBlbHNlIGlmIChlIDwgTUlOX0VYUCkge1xyXG5cclxuICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICB4LmMgPSBbXTtcclxuXHJcbiAgICAgICAgICAvLyBUcmFuc2Zvcm0gYmFzZVxyXG5cclxuICAgICAgICAgIC8vIGUgaXMgdGhlIGJhc2UgMTAgZXhwb25lbnQuXHJcbiAgICAgICAgICAvLyBpIGlzIHdoZXJlIHRvIHNsaWNlIHN0ciB0byBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGNvZWZmaWNpZW50IGFycmF5LlxyXG4gICAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICAgIGlmIChlIDwgMCkgaSArPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICBpZiAoaSA8IGxlbikge1xyXG4gICAgICAgICAgICBpZiAoaSkgeC5jLnB1c2goK3N0ci5zbGljZSgwLCBpKSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxlbiAtPSBMT0dfQkFTRTsgaSA8IGxlbjspIHtcclxuICAgICAgICAgICAgICB4LmMucHVzaCgrc3RyLnNsaWNlKGksIGkgKz0gTE9HX0JBU0UpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3RyID0gc3RyLnNsaWNlKGkpO1xyXG4gICAgICAgICAgICBpID0gTE9HX0JBU0UgLSBzdHIubGVuZ3RoO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSAtPSBsZW47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB4LmMucHVzaCgrc3RyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIENPTlNUUlVDVE9SIFBST1BFUlRJRVNcclxuXHJcblxyXG4gICAgQmlnTnVtYmVyLmNsb25lID0gY2xvbmU7XHJcblxyXG4gICAgQmlnTnVtYmVyLlJPVU5EX1VQID0gMDtcclxuICAgIEJpZ051bWJlci5ST1VORF9ET1dOID0gMTtcclxuICAgIEJpZ051bWJlci5ST1VORF9DRUlMID0gMjtcclxuICAgIEJpZ051bWJlci5ST1VORF9GTE9PUiA9IDM7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9VUCA9IDQ7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9ET1dOID0gNTtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0VWRU4gPSA2O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfQ0VJTCA9IDc7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9GTE9PUiA9IDg7XHJcbiAgICBCaWdOdW1iZXIuRVVDTElEID0gOTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIENvbmZpZ3VyZSBpbmZyZXF1ZW50bHktY2hhbmdpbmcgbGlicmFyeS13aWRlIHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEFjY2VwdCBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIG9wdGlvbmFsIHByb3BlcnRpZXMgKGlmIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGlzXHJcbiAgICAgKiBhIG51bWJlciwgaXQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlIHN0YXRlZCk6XHJcbiAgICAgKlxyXG4gICAgICogICBERUNJTUFMX1BMQUNFUyAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAgICogICBST1VORElOR19NT0RFICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDhcclxuICAgICAqICAgRVhQT05FTlRJQUxfQVQgICB7bnVtYmVyfG51bWJlcltdfSAgLU1BWCB0byBNQVggIG9yICBbLU1BWCB0byAwLCAwIHRvIE1BWF1cclxuICAgICAqICAgUkFOR0UgICAgICAgICAgICB7bnVtYmVyfG51bWJlcltdfSAgLU1BWCB0byBNQVggKG5vdCB6ZXJvKSAgb3IgIFstTUFYIHRvIC0xLCAxIHRvIE1BWF1cclxuICAgICAqICAgQ1JZUFRPICAgICAgICAgICB7Ym9vbGVhbn0gICAgICAgICAgdHJ1ZSBvciBmYWxzZVxyXG4gICAgICogICBNT0RVTE9fTU9ERSAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDlcclxuICAgICAqICAgUE9XX1BSRUNJU0lPTiAgICAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVhcclxuICAgICAqICAgQUxQSEFCRVQgICAgICAgICB7c3RyaW5nfSAgICAgICAgICAgQSBzdHJpbmcgb2YgdHdvIG9yIG1vcmUgdW5pcXVlIGNoYXJhY3RlcnMgd2hpY2ggZG9lc1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3QgY29udGFpbiAnLicuXHJcbiAgICAgKiAgIEZPUk1BVCAgICAgICAgICAge29iamVjdH0gICAgICAgICAgIEFuIG9iamVjdCB3aXRoIHNvbWUgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gICAgICogICAgIHByZWZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBncm91cFNpemUgICAgICAgICAgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgc2Vjb25kYXJ5R3JvdXBTaXplICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIGdyb3VwU2VwYXJhdG9yICAgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBkZWNpbWFsU2VwYXJhdG9yICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZnJhY3Rpb25Hcm91cFNpemUgICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3Ige3N0cmluZ31cclxuICAgICAqICAgICBzdWZmaXggICAgICAgICAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKlxyXG4gICAgICogKFRoZSB2YWx1ZXMgYXNzaWduZWQgdG8gdGhlIGFib3ZlIEZPUk1BVCBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90IGNoZWNrZWQgZm9yIHZhbGlkaXR5LilcclxuICAgICAqXHJcbiAgICAgKiBFLmcuXHJcbiAgICAgKiBCaWdOdW1iZXIuY29uZmlnKHsgREVDSU1BTF9QTEFDRVMgOiAyMCwgUk9VTkRJTkdfTU9ERSA6IDQgfSlcclxuICAgICAqXHJcbiAgICAgKiBJZ25vcmUgcHJvcGVydGllcy9wYXJhbWV0ZXJzIHNldCB0byBudWxsIG9yIHVuZGVmaW5lZCwgZXhjZXB0IGZvciBBTFBIQUJFVC5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgY3VycmVudCB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5jb25maWcgPSBCaWdOdW1iZXIuc2V0ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICB2YXIgcCwgdjtcclxuXHJcbiAgICAgIGlmIChvYmogIT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PSAnb2JqZWN0Jykge1xyXG5cclxuICAgICAgICAgIC8vIERFQ0lNQUxfUExBQ0VTIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBERUNJTUFMX1BMQUNFUyB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnREVDSU1BTF9QTEFDRVMnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBERUNJTUFMX1BMQUNFUyA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUk9VTkRJTkdfTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFJPVU5ESU5HX01PREUge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JPVU5ESU5HX01PREUnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCA4LCBwKTtcclxuICAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRVhQT05FTlRJQUxfQVQge251bWJlcnxudW1iZXJbXX1cclxuICAgICAgICAgIC8vIEludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAwIGluY2x1c2l2ZSwgMCB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBFWFBPTkVOVElBTF9BVCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnRVhQT05FTlRJQUxfQVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiAmJiB2LnBvcCkge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMF0sIC1NQVgsIDAsIHApO1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMV0sIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgVE9fRVhQX05FRyA9IHZbMF07XHJcbiAgICAgICAgICAgICAgVE9fRVhQX1BPUyA9IHZbMV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodiwgLU1BWCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBUT19FWFBfTkVHID0gLShUT19FWFBfUE9TID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUkFOR0Uge251bWJlcnxudW1iZXJbXX0gTm9uLXplcm8gaW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIC0xIGluY2x1c2l2ZSwgaW50ZWdlciAxIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFJBTkdFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZXxjYW5ub3QgYmUgemVyb306IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdSQU5HRScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgLTEsIHApO1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMV0sIDEsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgTUlOX0VYUCA9IHZbMF07XHJcbiAgICAgICAgICAgICAgTUFYX0VYUCA9IHZbMV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodiwgLU1BWCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgICAgTUlOX0VYUCA9IC0oTUFYX0VYUCA9IHYgPCAwID8gLXYgOiB2KTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBjYW5ub3QgYmUgemVybzogJyArIHYpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENSWVBUTyB7Ym9vbGVhbn0gdHJ1ZSBvciBmYWxzZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBDUllQVE8gbm90IHRydWUgb3IgZmFsc2U6IHt2fSdcclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBjcnlwdG8gdW5hdmFpbGFibGUnXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnQ1JZUFRPJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgPT09ICEhdikge1xyXG4gICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8gJiZcclxuICAgICAgICAgICAgICAgICAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyB8fCBjcnlwdG8ucmFuZG9tQnl0ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgIENSWVBUTyA9IHY7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBDUllQVE8gPSAhdjtcclxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IHRydWUgb3IgZmFsc2U6ICcgKyB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIE1PRFVMT19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOSBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTU9EVUxPX01PREUge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ01PRFVMT19NT0RFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgOSwgcCk7XHJcbiAgICAgICAgICAgIE1PRFVMT19NT0RFID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBQT1dfUFJFQ0lTSU9OIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBQT1dfUFJFQ0lTSU9OIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdQT1dfUFJFQ0lTSU9OJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRk9STUFUIHtvYmplY3R9XHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gRk9STUFUIG5vdCBhbiBvYmplY3Q6IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdGT1JNQVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ29iamVjdCcpIEZPUk1BVCA9IHY7XHJcbiAgICAgICAgICAgIGVsc2UgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCBhbiBvYmplY3Q6ICcgKyB2KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBBTFBIQUJFVCB7c3RyaW5nfVxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEFMUEhBQkVUIGludmFsaWQ6IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdBTFBIQUJFVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcblxyXG4gICAgICAgICAgICAvLyBEaXNhbGxvdyBpZiBvbmx5IG9uZSBjaGFyYWN0ZXIsXHJcbiAgICAgICAgICAgIC8vIG9yIGlmIGl0IGNvbnRhaW5zICcrJywgJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIGEgcmVwZWF0ZWQgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ3N0cmluZycgJiYgIS9eLiR8WystLlxcc118KC4pLipcXDEvLnRlc3QodikpIHtcclxuICAgICAgICAgICAgICBBTFBIQUJFVCA9IHY7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgaW52YWxpZDogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE9iamVjdCBleHBlY3RlZDoge3Z9J1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnT2JqZWN0IGV4cGVjdGVkOiAnICsgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgREVDSU1BTF9QTEFDRVM6IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgIFJPVU5ESU5HX01PREU6IFJPVU5ESU5HX01PREUsXHJcbiAgICAgICAgRVhQT05FTlRJQUxfQVQ6IFtUT19FWFBfTkVHLCBUT19FWFBfUE9TXSxcclxuICAgICAgICBSQU5HRTogW01JTl9FWFAsIE1BWF9FWFBdLFxyXG4gICAgICAgIENSWVBUTzogQ1JZUFRPLFxyXG4gICAgICAgIE1PRFVMT19NT0RFOiBNT0RVTE9fTU9ERSxcclxuICAgICAgICBQT1dfUFJFQ0lTSU9OOiBQT1dfUFJFQ0lTSU9OLFxyXG4gICAgICAgIEZPUk1BVDogRk9STUFULFxyXG4gICAgICAgIEFMUEhBQkVUOiBBTFBIQUJFVFxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHYgaXMgYSBCaWdOdW1iZXIgaW5zdGFuY2UsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKlxyXG4gICAgICogdiB7YW55fVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuaXNCaWdOdW1iZXIgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICByZXR1cm4gdiBpbnN0YW5jZW9mIEJpZ051bWJlciB8fCB2ICYmIHYuX2lzQmlnTnVtYmVyID09PSB0cnVlIHx8IGZhbHNlO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1heGltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIubWF4aW11bSA9IEJpZ051bWJlci5tYXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIFAubHQpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1pbmltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIubWluaW11bSA9IEJpZ051bWJlci5taW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIFAuZ3QpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2l0aCBhIHJhbmRvbSB2YWx1ZSBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gMCBhbmQgbGVzcyB0aGFuIDEsXHJcbiAgICAgKiBhbmQgd2l0aCBkcCwgb3IgREVDSU1BTF9QTEFDRVMgaWYgZHAgaXMgb21pdHRlZCwgZGVjaW1hbCBwbGFjZXMgKG9yIGxlc3MgaWYgdHJhaWxpbmdcclxuICAgICAqIHplcm9zIGFyZSBwcm9kdWNlZCkuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB9J1xyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLnJhbmRvbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBwb3cyXzUzID0gMHgyMDAwMDAwMDAwMDAwMDtcclxuXHJcbiAgICAgIC8vIFJldHVybiBhIDUzIGJpdCBpbnRlZ2VyIG4sIHdoZXJlIDAgPD0gbiA8IDkwMDcxOTkyNTQ3NDA5OTIuXHJcbiAgICAgIC8vIENoZWNrIGlmIE1hdGgucmFuZG9tKCkgcHJvZHVjZXMgbW9yZSB0aGFuIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cclxuICAgICAgLy8gSWYgaXQgZG9lcywgYXNzdW1lIGF0IGxlYXN0IDUzIGJpdHMgYXJlIHByb2R1Y2VkLCBvdGhlcndpc2UgYXNzdW1lIGF0IGxlYXN0IDMwIGJpdHMuXHJcbiAgICAgIC8vIDB4NDAwMDAwMDAgaXMgMl4zMCwgMHg4MDAwMDAgaXMgMl4yMywgMHgxZmZmZmYgaXMgMl4yMSAtIDEuXHJcbiAgICAgIHZhciByYW5kb201M2JpdEludCA9IChNYXRoLnJhbmRvbSgpICogcG93Ml81MykgJiAweDFmZmZmZlxyXG4gICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpOyB9XHJcbiAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICgoTWF0aC5yYW5kb20oKSAqIDB4NDAwMDAwMDAgfCAwKSAqIDB4ODAwMDAwKSArXHJcbiAgICAgICAgIChNYXRoLnJhbmRvbSgpICogMHg4MDAwMDAgfCAwKTsgfTtcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZHApIHtcclxuICAgICAgICB2YXIgYSwgYiwgZSwgaywgdixcclxuICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgYyA9IFtdLFxyXG4gICAgICAgICAgcmFuZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgICAgaWYgKGRwID09IG51bGwpIGRwID0gREVDSU1BTF9QTEFDRVM7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuXHJcbiAgICAgICAgayA9IG1hdGhjZWlsKGRwIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICBpZiAoQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgICAgLy8gQnJvd3NlcnMgc3VwcG9ydGluZyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLlxyXG4gICAgICAgICAgaWYgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcclxuXHJcbiAgICAgICAgICAgIGEgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShrICo9IDIpKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gNTMgYml0czpcclxuICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpICogTWF0aC5wb3coMiwgMjEpKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwXHJcbiAgICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSA+Pj4gMTEpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAvLyAweDIwMDAwIGlzIDJeMjEuXHJcbiAgICAgICAgICAgICAgdiA9IGFbaV0gKiAweDIwMDAwICsgKGFbaSArIDFdID4+PiAxMSk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFJlamVjdGlvbiBzYW1wbGluZzpcclxuICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgLy8gUHJvYmFiaWxpdHkgdGhhdCB2ID49IDllMTUsIGlzXHJcbiAgICAgICAgICAgICAgLy8gNzE5OTI1NDc0MDk5MiAvIDkwMDcxOTkyNTQ3NDA5OTIgfj0gMC4wMDA4LCBpLmUuIDEgaW4gMTI1MVxyXG4gICAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICAgIGIgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgyKSk7XHJcbiAgICAgICAgICAgICAgICBhW2ldID0gYlswXTtcclxuICAgICAgICAgICAgICAgIGFbaSArIDFdID0gYlsxXTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gdiA8PSA4OTk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIGMucHVzaCh2ICUgMWUxNCk7XHJcbiAgICAgICAgICAgICAgICBpICs9IDI7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSBrIC8gMjtcclxuXHJcbiAgICAgICAgICAvLyBOb2RlLmpzIHN1cHBvcnRpbmcgY3J5cHRvLnJhbmRvbUJ5dGVzLlxyXG4gICAgICAgICAgfSBlbHNlIGlmIChjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGJ1ZmZlclxyXG4gICAgICAgICAgICBhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGsgKj0gNyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwMDAwMCBpcyAyXjQ4LCAweDEwMDAwMDAwMDAwIGlzIDJeNDBcclxuICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMCBpcyAyXjMyLCAweDEwMDAwMDAgaXMgMl4yNFxyXG4gICAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAgIHYgPSAoKGFbaV0gJiAzMSkgKiAweDEwMDAwMDAwMDAwMDApICsgKGFbaSArIDFdICogMHgxMDAwMDAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAgIChhW2kgKyAyXSAqIDB4MTAwMDAwMDAwKSArIChhW2kgKyAzXSAqIDB4MTAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAgIChhW2kgKyA0XSA8PCAxNikgKyAoYVtpICsgNV0gPDwgOCkgKyBhW2kgKyA2XTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgICAgY3J5cHRvLnJhbmRvbUJ5dGVzKDcpLmNvcHkoYSwgaSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIGMucHVzaCh2ICUgMWUxNCk7XHJcbiAgICAgICAgICAgICAgICBpICs9IDc7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSBrIC8gNztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIENSWVBUTyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXNlIE1hdGgucmFuZG9tLlxyXG4gICAgICAgIGlmICghQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG4gICAgICAgICAgICB2ID0gcmFuZG9tNTNiaXRJbnQoKTtcclxuICAgICAgICAgICAgaWYgKHYgPCA5ZTE1KSBjW2krK10gPSB2ICUgMWUxNDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGsgPSBjWy0taV07XHJcbiAgICAgICAgZHAgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgdHJhaWxpbmcgZGlnaXRzIHRvIHplcm9zIGFjY29yZGluZyB0byBkcC5cclxuICAgICAgICBpZiAoayAmJiBkcCkge1xyXG4gICAgICAgICAgdiA9IFBPV1NfVEVOW0xPR19CQVNFIC0gZHBdO1xyXG4gICAgICAgICAgY1tpXSA9IG1hdGhmbG9vcihrIC8gdikgKiB2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvLlxyXG4gICAgICAgIGZvciAoOyBjW2ldID09PSAwOyBjLnBvcCgpLCBpLS0pO1xyXG5cclxuICAgICAgICAvLyBaZXJvP1xyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgYyA9IFtlID0gMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVybyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgZm9yIChlID0gLTEgOyBjWzBdID09PSAwOyBjLnNwbGljZSgwLCAxKSwgZSAtPSBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgLy8gQ291bnQgdGhlIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiBjIHRvIGRldGVybWluZSBsZWFkaW5nIHplcm9zLCBhbmQuLi5cclxuICAgICAgICAgIGZvciAoaSA9IDEsIHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAgIC8vIGFkanVzdCB0aGUgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICBpZiAoaSA8IExPR19CQVNFKSBlIC09IExPR19CQVNFIC0gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJhbmQuZSA9IGU7XHJcbiAgICAgICAgcmFuZC5jID0gYztcclxuICAgICAgICByZXR1cm4gcmFuZDtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHN1bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5zdW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBpID0gMSxcclxuICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxyXG4gICAgICAgIHN1bSA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcbiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7KSBzdW0gPSBzdW0ucGx1cyhhcmdzW2krK10pO1xyXG4gICAgICByZXR1cm4gc3VtO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLy8gUFJJVkFURSBGVU5DVElPTlNcclxuXHJcblxyXG4gICAgLy8gQ2FsbGVkIGJ5IEJpZ051bWJlciBhbmQgQmlnTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZy5cclxuICAgIGNvbnZlcnRCYXNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGRlY2ltYWwgPSAnMDEyMzQ1Njc4OSc7XHJcblxyXG4gICAgICAvKlxyXG4gICAgICAgKiBDb252ZXJ0IHN0cmluZyBvZiBiYXNlSW4gdG8gYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBiYXNlT3V0LlxyXG4gICAgICAgKiBFZy4gdG9CYXNlT3V0KCcyNTUnLCAxMCwgMTYpIHJldHVybnMgWzE1LCAxNV0uXHJcbiAgICAgICAqIEVnLiB0b0Jhc2VPdXQoJ2ZmJywgMTYsIDEwKSByZXR1cm5zIFsyLCA1LCA1XS5cclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgYWxwaGFiZXQpIHtcclxuICAgICAgICB2YXIgaixcclxuICAgICAgICAgIGFyciA9IFswXSxcclxuICAgICAgICAgIGFyckwsXHJcbiAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgZm9yIChhcnJMID0gYXJyLmxlbmd0aDsgYXJyTC0tOyBhcnJbYXJyTF0gKj0gYmFzZUluKTtcclxuXHJcbiAgICAgICAgICBhcnJbMF0gKz0gYWxwaGFiZXQuaW5kZXhPZihzdHIuY2hhckF0KGkrKykpO1xyXG5cclxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBhcnIubGVuZ3RoOyBqKyspIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChhcnJbal0gPiBiYXNlT3V0IC0gMSkge1xyXG4gICAgICAgICAgICAgIGlmIChhcnJbaiArIDFdID09IG51bGwpIGFycltqICsgMV0gPSAwO1xyXG4gICAgICAgICAgICAgIGFycltqICsgMV0gKz0gYXJyW2pdIC8gYmFzZU91dCB8IDA7XHJcbiAgICAgICAgICAgICAgYXJyW2pdICU9IGJhc2VPdXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhcnIucmV2ZXJzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb252ZXJ0IGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZUluIHRvIGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZU91dC5cclxuICAgICAgLy8gSWYgdGhlIGNhbGxlciBpcyB0b1N0cmluZywgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlIDEwIHRvIGJhc2VPdXQuXHJcbiAgICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgQmlnTnVtYmVyLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2VJbiB0byBiYXNlIDEwLlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHN0ciwgYmFzZUluLCBiYXNlT3V0LCBzaWduLCBjYWxsZXJJc1RvU3RyaW5nKSB7XHJcbiAgICAgICAgdmFyIGFscGhhYmV0LCBkLCBlLCBrLCByLCB4LCB4YywgeSxcclxuICAgICAgICAgIGkgPSBzdHIuaW5kZXhPZignLicpLFxyXG4gICAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyxcclxuICAgICAgICAgIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuXHJcbiAgICAgICAgLy8gTm9uLWludGVnZXIuXHJcbiAgICAgICAgaWYgKGkgPj0gMCkge1xyXG4gICAgICAgICAgayA9IFBPV19QUkVDSVNJT047XHJcblxyXG4gICAgICAgICAgLy8gVW5saW1pdGVkIHByZWNpc2lvbi5cclxuICAgICAgICAgIFBPV19QUkVDSVNJT04gPSAwO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihiYXNlSW4pO1xyXG4gICAgICAgICAgeCA9IHkucG93KHN0ci5sZW5ndGggLSBpKTtcclxuICAgICAgICAgIFBPV19QUkVDSVNJT04gPSBrO1xyXG5cclxuICAgICAgICAgIC8vIENvbnZlcnQgc3RyIGFzIGlmIGFuIGludGVnZXIsIHRoZW4gcmVzdG9yZSB0aGUgZnJhY3Rpb24gcGFydCBieSBkaXZpZGluZyB0aGVcclxuICAgICAgICAgIC8vIHJlc3VsdCBieSBpdHMgYmFzZSByYWlzZWQgdG8gYSBwb3dlci5cclxuXHJcbiAgICAgICAgICB5LmMgPSB0b0Jhc2VPdXQodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcoeC5jKSwgeC5lLCAnMCcpLFxyXG4gICAgICAgICAgIDEwLCBiYXNlT3V0LCBkZWNpbWFsKTtcclxuICAgICAgICAgIHkuZSA9IHkuYy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBudW1iZXIgYXMgaW50ZWdlci5cclxuXHJcbiAgICAgICAgeGMgPSB0b0Jhc2VPdXQoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIGNhbGxlcklzVG9TdHJpbmdcclxuICAgICAgICAgPyAoYWxwaGFiZXQgPSBBTFBIQUJFVCwgZGVjaW1hbClcclxuICAgICAgICAgOiAoYWxwaGFiZXQgPSBkZWNpbWFsLCBBTFBIQUJFVCkpO1xyXG5cclxuICAgICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgYXMgYW4gaW50ZWdlciBhbmQgY29udmVydGVkIHRvIGJhc2VPdXQuIGUgaXMgdGhlIGV4cG9uZW50LlxyXG4gICAgICAgIGUgPSBrID0geGMubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yICg7IHhjWy0ta10gPT0gMDsgeGMucG9wKCkpO1xyXG5cclxuICAgICAgICAvLyBaZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0pIHJldHVybiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcblxyXG4gICAgICAgIC8vIERvZXMgc3RyIHJlcHJlc2VudCBhbiBpbnRlZ2VyPyBJZiBzbywgbm8gbmVlZCBmb3IgdGhlIGRpdmlzaW9uLlxyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgLS1lO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmMgPSB4YztcclxuICAgICAgICAgIHguZSA9IGU7XHJcblxyXG4gICAgICAgICAgLy8gVGhlIHNpZ24gaXMgbmVlZGVkIGZvciBjb3JyZWN0IHJvdW5kaW5nLlxyXG4gICAgICAgICAgeC5zID0gc2lnbjtcclxuICAgICAgICAgIHggPSBkaXYoeCwgeSwgZHAsIHJtLCBiYXNlT3V0KTtcclxuICAgICAgICAgIHhjID0geC5jO1xyXG4gICAgICAgICAgciA9IHgucjtcclxuICAgICAgICAgIGUgPSB4LmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgY29udmVydGVkIHRvIGJhc2VPdXQuXHJcblxyXG4gICAgICAgIC8vIFRIZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgZCA9IGUgKyBkcCArIDE7XHJcblxyXG4gICAgICAgIC8vIFRoZSByb3VuZGluZyBkaWdpdDogdGhlIGRpZ2l0IHRvIHRoZSByaWdodCBvZiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICBpID0geGNbZF07XHJcblxyXG4gICAgICAgIC8vIExvb2sgYXQgdGhlIHJvdW5kaW5nIGRpZ2l0cyBhbmQgbW9kZSB0byBkZXRlcm1pbmUgd2hldGhlciB0byByb3VuZCB1cC5cclxuXHJcbiAgICAgICAgayA9IGJhc2VPdXQgLyAyO1xyXG4gICAgICAgIHIgPSByIHx8IGQgPCAwIHx8IHhjW2QgKyAxXSAhPSBudWxsO1xyXG5cclxuICAgICAgICByID0gcm0gPCA0ID8gKGkgIT0gbnVsbCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgICAgICA6IGkgPiBrIHx8IGkgPT0gayAmJihybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJiB4Y1tkIC0gMV0gJiAxIHx8XHJcbiAgICAgICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIGluZGV4IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBub3QgZ3JlYXRlciB0aGFuIHplcm8sIG9yIHhjIHJlcHJlc2VudHNcclxuICAgICAgICAvLyB6ZXJvLCB0aGVuIHRoZSByZXN1bHQgb2YgdGhlIGJhc2UgY29udmVyc2lvbiBpcyB6ZXJvIG9yLCBpZiByb3VuZGluZyB1cCwgYSB2YWx1ZVxyXG4gICAgICAgIC8vIHN1Y2ggYXMgMC4wMDAwMS5cclxuICAgICAgICBpZiAoZCA8IDEgfHwgIXhjWzBdKSB7XHJcblxyXG4gICAgICAgICAgLy8gMV4tZHAgb3IgMFxyXG4gICAgICAgICAgc3RyID0gciA/IHRvRml4ZWRQb2ludChhbHBoYWJldC5jaGFyQXQoMSksIC1kcCwgYWxwaGFiZXQuY2hhckF0KDApKSA6IGFscGhhYmV0LmNoYXJBdCgwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIFRydW5jYXRlIHhjIHRvIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICB4Yy5sZW5ndGggPSBkO1xyXG5cclxuICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFJvdW5kaW5nIHVwIG1heSBtZWFuIHRoZSBwcmV2aW91cyBkaWdpdCBoYXMgdG8gYmUgcm91bmRlZCB1cCBhbmQgc28gb24uXHJcbiAgICAgICAgICAgIGZvciAoLS1iYXNlT3V0OyArK3hjWy0tZF0gPiBiYXNlT3V0Oykge1xyXG4gICAgICAgICAgICAgIHhjW2RdID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKCFkKSB7XHJcbiAgICAgICAgICAgICAgICArK2U7XHJcbiAgICAgICAgICAgICAgICB4YyA9IFsxXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgIGZvciAoayA9IHhjLmxlbmd0aDsgIXhjWy0ta107KTtcclxuXHJcbiAgICAgICAgICAvLyBFLmcuIFs0LCAxMSwgMTVdIGJlY29tZXMgNGJmLlxyXG4gICAgICAgICAgZm9yIChpID0gMCwgc3RyID0gJyc7IGkgPD0gazsgc3RyICs9IGFscGhhYmV0LmNoYXJBdCh4Y1tpKytdKSk7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVyb3MsIGRlY2ltYWwgcG9pbnQgYW5kIHRyYWlsaW5nIHplcm9zIGFzIHJlcXVpcmVkLlxyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgYWxwaGFiZXQuY2hhckF0KDApKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZSBjYWxsZXIgd2lsbCBhZGQgdGhlIHNpZ24uXHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8vIFBlcmZvcm0gZGl2aXNpb24gaW4gdGhlIHNwZWNpZmllZCBiYXNlLiBDYWxsZWQgYnkgZGl2IGFuZCBjb252ZXJ0QmFzZS5cclxuICAgIGRpdiA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAvLyBBc3N1bWUgbm9uLXplcm8geCBhbmQgay5cclxuICAgICAgZnVuY3Rpb24gbXVsdGlwbHkoeCwgaywgYmFzZSkge1xyXG4gICAgICAgIHZhciBtLCB0ZW1wLCB4bG8sIHhoaSxcclxuICAgICAgICAgIGNhcnJ5ID0gMCxcclxuICAgICAgICAgIGkgPSB4Lmxlbmd0aCxcclxuICAgICAgICAgIGtsbyA9IGsgJSBTUVJUX0JBU0UsXHJcbiAgICAgICAgICBraGkgPSBrIC8gU1FSVF9CQVNFIHwgMDtcclxuXHJcbiAgICAgICAgZm9yICh4ID0geC5zbGljZSgpOyBpLS07KSB7XHJcbiAgICAgICAgICB4bG8gPSB4W2ldICUgU1FSVF9CQVNFO1xyXG4gICAgICAgICAgeGhpID0geFtpXSAvIFNRUlRfQkFTRSB8IDA7XHJcbiAgICAgICAgICBtID0ga2hpICogeGxvICsgeGhpICoga2xvO1xyXG4gICAgICAgICAgdGVtcCA9IGtsbyAqIHhsbyArICgobSAlIFNRUlRfQkFTRSkgKiBTUVJUX0JBU0UpICsgY2Fycnk7XHJcbiAgICAgICAgICBjYXJyeSA9ICh0ZW1wIC8gYmFzZSB8IDApICsgKG0gLyBTUVJUX0JBU0UgfCAwKSArIGtoaSAqIHhoaTtcclxuICAgICAgICAgIHhbaV0gPSB0ZW1wICUgYmFzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjYXJyeSkgeCA9IFtjYXJyeV0uY29uY2F0KHgpO1xyXG5cclxuICAgICAgICByZXR1cm4geDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gY29tcGFyZShhLCBiLCBhTCwgYkwpIHtcclxuICAgICAgICB2YXIgaSwgY21wO1xyXG5cclxuICAgICAgICBpZiAoYUwgIT0gYkwpIHtcclxuICAgICAgICAgIGNtcCA9IGFMID4gYkwgPyAxIDogLTE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICBmb3IgKGkgPSBjbXAgPSAwOyBpIDwgYUw7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKGFbaV0gIT0gYltpXSkge1xyXG4gICAgICAgICAgICAgIGNtcCA9IGFbaV0gPiBiW2ldID8gMSA6IC0xO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiLCBhTCwgYmFzZSkge1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAgICAgLy8gU3VidHJhY3QgYiBmcm9tIGEuXHJcbiAgICAgICAgZm9yICg7IGFMLS07KSB7XHJcbiAgICAgICAgICBhW2FMXSAtPSBpO1xyXG4gICAgICAgICAgaSA9IGFbYUxdIDwgYlthTF0gPyAxIDogMDtcclxuICAgICAgICAgIGFbYUxdID0gaSAqIGJhc2UgKyBhW2FMXSAtIGJbYUxdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yICg7ICFhWzBdICYmIGEubGVuZ3RoID4gMTsgYS5zcGxpY2UoMCwgMSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB4OiBkaXZpZGVuZCwgeTogZGl2aXNvci5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5LCBkcCwgcm0sIGJhc2UpIHtcclxuICAgICAgICB2YXIgY21wLCBlLCBpLCBtb3JlLCBuLCBwcm9kLCBwcm9kTCwgcSwgcWMsIHJlbSwgcmVtTCwgcmVtMCwgeGksIHhMLCB5YzAsXHJcbiAgICAgICAgICB5TCwgeXosXHJcbiAgICAgICAgICBzID0geC5zID09IHkucyA/IDEgOiAtMSxcclxuICAgICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBOYU4sIEluZmluaXR5IG9yIDA/XHJcbiAgICAgICAgaWYgKCF4YyB8fCAheGNbMF0gfHwgIXljIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKFxyXG5cclxuICAgICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBOYU4sIG9yIGJvdGggSW5maW5pdHkgb3IgMC5cclxuICAgICAgICAgICAheC5zIHx8ICF5LnMgfHwgKHhjID8geWMgJiYgeGNbMF0gPT0geWNbMF0gOiAheWMpID8gTmFOIDpcclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgeCBpcyDCsTAgb3IgeSBpcyDCsUluZmluaXR5LCBvciByZXR1cm4gwrFJbmZpbml0eSBhcyB5IGlzIMKxMC5cclxuICAgICAgICAgICAgeGMgJiYgeGNbMF0gPT0gMCB8fCAheWMgPyBzICogMCA6IHMgLyAwXHJcbiAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBxID0gbmV3IEJpZ051bWJlcihzKTtcclxuICAgICAgICBxYyA9IHEuYyA9IFtdO1xyXG4gICAgICAgIGUgPSB4LmUgLSB5LmU7XHJcbiAgICAgICAgcyA9IGRwICsgZSArIDE7XHJcblxyXG4gICAgICAgIGlmICghYmFzZSkge1xyXG4gICAgICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgICAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpIC0gYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgICAgICAgcyA9IHMgLyBMT0dfQkFTRSB8IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXN1bHQgZXhwb25lbnQgbWF5IGJlIG9uZSBsZXNzIHRoZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgZS5cclxuICAgICAgICAvLyBUaGUgY29lZmZpY2llbnRzIG9mIHRoZSBCaWdOdW1iZXJzIGZyb20gY29udmVydEJhc2UgbWF5IGhhdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yIChpID0gMDsgeWNbaV0gPT0gKHhjW2ldIHx8IDApOyBpKyspO1xyXG5cclxuICAgICAgICBpZiAoeWNbaV0gPiAoeGNbaV0gfHwgMCkpIGUtLTtcclxuXHJcbiAgICAgICAgaWYgKHMgPCAwKSB7XHJcbiAgICAgICAgICBxYy5wdXNoKDEpO1xyXG4gICAgICAgICAgbW9yZSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgIHMgKz0gMjtcclxuXHJcbiAgICAgICAgICAvLyBOb3JtYWxpc2UgeGMgYW5kIHljIHNvIGhpZ2hlc3Qgb3JkZXIgZGlnaXQgb2YgeWMgaXMgPj0gYmFzZSAvIDIuXHJcblxyXG4gICAgICAgICAgbiA9IG1hdGhmbG9vcihiYXNlIC8gKHljWzBdICsgMSkpO1xyXG5cclxuICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBoYW5kbGUgb2RkIGJhc2VzIHdoZXJlIHljWzBdID09IChiYXNlIC8gMikgLSAxLlxyXG4gICAgICAgICAgLy8gaWYgKG4gPiAxIHx8IG4rKyA9PSAxICYmIHljWzBdIDwgYmFzZSAvIDIpIHtcclxuICAgICAgICAgIGlmIChuID4gMSkge1xyXG4gICAgICAgICAgICB5YyA9IG11bHRpcGx5KHljLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgeGMgPSBtdWx0aXBseSh4YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgIHlMID0geWMubGVuZ3RoO1xyXG4gICAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB4aSA9IHlMO1xyXG4gICAgICAgICAgcmVtID0geGMuc2xpY2UoMCwgeUwpO1xyXG4gICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIHplcm9zIHRvIG1ha2UgcmVtYWluZGVyIGFzIGxvbmcgYXMgZGl2aXNvci5cclxuICAgICAgICAgIGZvciAoOyByZW1MIDwgeUw7IHJlbVtyZW1MKytdID0gMCk7XHJcbiAgICAgICAgICB5eiA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgICB5eiA9IFswXS5jb25jYXQoeXopO1xyXG4gICAgICAgICAgeWMwID0geWNbMF07XHJcbiAgICAgICAgICBpZiAoeWNbMV0gPj0gYmFzZSAvIDIpIHljMCsrO1xyXG4gICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIHByZXZlbnQgdHJpYWwgZGlnaXQgbiA+IGJhc2UsIHdoZW4gdXNpbmcgYmFzZSAzLlxyXG4gICAgICAgICAgLy8gZWxzZSBpZiAoYmFzZSA9PSAzICYmIHljMCA9PSAxKSB5YzAgPSAxICsgMWUtMTU7XHJcblxyXG4gICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBuID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBjbXAgPSBjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChjbXAgPCAwKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0cmlhbCBkaWdpdCwgbi5cclxuXHJcbiAgICAgICAgICAgICAgcmVtMCA9IHJlbVswXTtcclxuICAgICAgICAgICAgICBpZiAoeUwgIT0gcmVtTCkgcmVtMCA9IHJlbTAgKiBiYXNlICsgKHJlbVsxXSB8fCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gbiBpcyBob3cgbWFueSB0aW1lcyB0aGUgZGl2aXNvciBnb2VzIGludG8gdGhlIGN1cnJlbnQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIG4gPSBtYXRoZmxvb3IocmVtMCAvIHljMCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vICBBbGdvcml0aG06XHJcbiAgICAgICAgICAgICAgLy8gIHByb2R1Y3QgPSBkaXZpc29yIG11bHRpcGxpZWQgYnkgdHJpYWwgZGlnaXQgKG4pLlxyXG4gICAgICAgICAgICAgIC8vICBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCBpcyBncmVhdGVyIHRoYW4gcmVtYWluZGVyOlxyXG4gICAgICAgICAgICAgIC8vICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LCBkZWNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgLy8gIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gIElmIHByb2R1Y3Qgd2FzIGxlc3MgdGhhbiByZW1haW5kZXIgYXQgdGhlIGxhc3QgY29tcGFyZTpcclxuICAgICAgICAgICAgICAvLyAgICBDb21wYXJlIG5ldyByZW1haW5kZXIgYW5kIGRpdmlzb3IuXHJcbiAgICAgICAgICAgICAgLy8gICAgSWYgcmVtYWluZGVyIGlzIGdyZWF0ZXIgdGhhbiBkaXZpc29yOlxyXG4gICAgICAgICAgICAgIC8vICAgICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlciwgaW5jcmVtZW50IHRyaWFsIGRpZ2l0LlxyXG5cclxuICAgICAgICAgICAgICBpZiAobiA+IDEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBuIG1heSBiZSA+IGJhc2Ugb25seSB3aGVuIGJhc2UgaXMgMy5cclxuICAgICAgICAgICAgICAgIGlmIChuID49IGJhc2UpIG4gPSBiYXNlIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvciAqIHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgcHJvZCA9IG11bHRpcGx5KHljLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIElmIHByb2R1Y3QgPiByZW1haW5kZXIgdGhlbiB0cmlhbCBkaWdpdCBuIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBoaWdoIGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgaXMgbm90IGtub3duIHRvIGhhdmVcclxuICAgICAgICAgICAgICAgIC8vIGV2ZXIgYmVlbiBtb3JlIHRoYW4gMSB0b28gaGlnaC5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKHByb2QsIHJlbSwgcHJvZEwsIHJlbUwpID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgbi0tO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KHByb2QsIHlMIDwgcHJvZEwgPyB5eiA6IHljLCBwcm9kTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgIGNtcCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDAgb3IgMSwgY21wIGlzIC0xLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAwLCB0aGVyZSBpcyBubyBuZWVkIHRvIGNvbXBhcmUgeWMgYW5kIHJlbSBhZ2FpbiBiZWxvdyxcclxuICAgICAgICAgICAgICAgIC8vIHNvIGNoYW5nZSBjbXAgdG8gMSB0byBhdm9pZCBpdC5cclxuICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgMSwgbGVhdmUgY21wIGFzIC0xLCBzbyB5YyBhbmQgcmVtIGFyZSBjb21wYXJlZCBhZ2Fpbi5cclxuICAgICAgICAgICAgICAgIGlmIChuID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIGRpdmlzb3IgPCByZW1haW5kZXIsIHNvIG4gbXVzdCBiZSBhdCBsZWFzdCAxLlxyXG4gICAgICAgICAgICAgICAgICBjbXAgPSBuID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvclxyXG4gICAgICAgICAgICAgICAgcHJvZCA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaWYgKHByb2RMIDwgcmVtTCkgcHJvZCA9IFswXS5jb25jYXQocHJvZCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCBwcm9kLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgIC8vIElmIHByb2R1Y3Qgd2FzIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIG5ldyByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgbmV3IHJlbWFpbmRlciwgc3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIFRyaWFsIGRpZ2l0IG4gdG9vIGxvdy5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gbG93IGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgdmVyeSByYXJlbHkgMiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICBuKys7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHlMIDwgcmVtTCA/IHl6IDogeWMsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgbisrO1xyXG4gICAgICAgICAgICAgIHJlbSA9IFswXTtcclxuICAgICAgICAgICAgfSAvLyBlbHNlIGNtcCA9PT0gMSBhbmQgbiB3aWxsIGJlIDBcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbmV4dCBkaWdpdCwgbiwgdG8gdGhlIHJlc3VsdCBhcnJheS5cclxuICAgICAgICAgICAgcWNbaSsrXSA9IG47XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKHJlbVswXSkge1xyXG4gICAgICAgICAgICAgIHJlbVtyZW1MKytdID0geGNbeGldIHx8IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmVtID0gW3hjW3hpXV07XHJcbiAgICAgICAgICAgICAgcmVtTCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gd2hpbGUgKCh4aSsrIDwgeEwgfHwgcmVtWzBdICE9IG51bGwpICYmIHMtLSk7XHJcblxyXG4gICAgICAgICAgbW9yZSA9IHJlbVswXSAhPSBudWxsO1xyXG5cclxuICAgICAgICAgIC8vIExlYWRpbmcgemVybz9cclxuICAgICAgICAgIGlmICghcWNbMF0pIHFjLnNwbGljZSgwLCAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChiYXNlID09IEJBU0UpIHtcclxuXHJcbiAgICAgICAgICAvLyBUbyBjYWxjdWxhdGUgcS5lLCBmaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgcWNbMF0uXHJcbiAgICAgICAgICBmb3IgKGkgPSAxLCBzID0gcWNbMF07IHMgPj0gMTA7IHMgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgICAgcm91bmQocSwgZHAgKyAocS5lID0gaSArIGUgKiBMT0dfQkFTRSAtIDEpICsgMSwgcm0sIG1vcmUpO1xyXG5cclxuICAgICAgICAvLyBDYWxsZXIgaXMgY29udmVydEJhc2UuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHEuZSA9IGU7XHJcbiAgICAgICAgICBxLnIgPSArbW9yZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBxO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIEJpZ051bWJlciBuIGluIGZpeGVkLXBvaW50IG9yIGV4cG9uZW50aWFsXHJcbiAgICAgKiBub3RhdGlvbiByb3VuZGVkIHRvIHRoZSBzcGVjaWZpZWQgZGVjaW1hbCBwbGFjZXMgb3Igc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgICpcclxuICAgICAqIG46IGEgQmlnTnVtYmVyLlxyXG4gICAgICogaTogdGhlIGluZGV4IG9mIHRoZSBsYXN0IGRpZ2l0IHJlcXVpcmVkIChpLmUuIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwKS5cclxuICAgICAqIHJtOiB0aGUgcm91bmRpbmcgbW9kZS5cclxuICAgICAqIGlkOiAxICh0b0V4cG9uZW50aWFsKSBvciAyICh0b1ByZWNpc2lvbikuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZvcm1hdChuLCBpLCBybSwgaWQpIHtcclxuICAgICAgdmFyIGMwLCBlLCBuZSwgbGVuLCBzdHI7XHJcblxyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgIGlmICghbi5jKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG5cclxuICAgICAgYzAgPSBuLmNbMF07XHJcbiAgICAgIG5lID0gbi5lO1xyXG5cclxuICAgICAgaWYgKGkgPT0gbnVsbCkge1xyXG4gICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuICAgICAgICBzdHIgPSBpZCA9PSAxIHx8IGlkID09IDIgJiYgbmUgPD0gVE9fRVhQX05FR1xyXG4gICAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBuZSlcclxuICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBuZSwgJzAnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgaSwgcm0pO1xyXG5cclxuICAgICAgICAvLyBuLmUgbWF5IGhhdmUgY2hhbmdlZCBpZiB0aGUgdmFsdWUgd2FzIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIHRvUHJlY2lzaW9uIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24gaWYgdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgICAgICAvLyBzcGVjaWZpZWQgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXJcclxuICAgICAgICAvLyBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbi5cclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgICAgaWYgKGlkID09IDEgfHwgaWQgPT0gMiAmJiAoaSA8PSBlIHx8IGUgPD0gVE9fRVhQX05FRykpIHtcclxuXHJcbiAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICBmb3IgKDsgbGVuIDwgaTsgc3RyICs9ICcwJywgbGVuKyspO1xyXG4gICAgICAgICAgc3RyID0gdG9FeHBvbmVudGlhbChzdHIsIGUpO1xyXG5cclxuICAgICAgICAvLyBGaXhlZC1wb2ludCBub3RhdGlvbi5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaSAtPSBuZTtcclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgaWYgKGUgKyAxID4gbGVuKSB7XHJcbiAgICAgICAgICAgIGlmICgtLWkgPiAwKSBmb3IgKHN0ciArPSAnLic7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpICs9IGUgLSBsZW47XHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgIGlmIChlICsgMSA9PSBsZW4pIHN0ciArPSAnLic7XHJcbiAgICAgICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuLnMgPCAwICYmIGMwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBIYW5kbGUgQmlnTnVtYmVyLm1heCBhbmQgQmlnTnVtYmVyLm1pbi5cclxuICAgIGZ1bmN0aW9uIG1heE9yTWluKGFyZ3MsIG1ldGhvZCkge1xyXG4gICAgICB2YXIgbixcclxuICAgICAgICBpID0gMSxcclxuICAgICAgICBtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuXHJcbiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbaV0pO1xyXG5cclxuICAgICAgICAvLyBJZiBhbnkgbnVtYmVyIGlzIE5hTiwgcmV0dXJuIE5hTi5cclxuICAgICAgICBpZiAoIW4ucykge1xyXG4gICAgICAgICAgbSA9IG47XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZC5jYWxsKG0sIG4pKSB7XHJcbiAgICAgICAgICBtID0gbjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogU3RyaXAgdHJhaWxpbmcgemVyb3MsIGNhbGN1bGF0ZSBiYXNlIDEwIGV4cG9uZW50IGFuZCBjaGVjayBhZ2FpbnN0IE1JTl9FWFAgYW5kIE1BWF9FWFAuXHJcbiAgICAgKiBDYWxsZWQgYnkgbWludXMsIHBsdXMgYW5kIHRpbWVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBub3JtYWxpc2UobiwgYywgZSkge1xyXG4gICAgICB2YXIgaSA9IDEsXHJcbiAgICAgICAgaiA9IGMubGVuZ3RoO1xyXG5cclxuICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yICg7ICFjWy0tal07IGMucG9wKCkpO1xyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50LiBGaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgZm9yIChqID0gY1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICBpZiAoKGUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgIG4uYyA9IG4uZSA9IG51bGw7XHJcblxyXG4gICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICBuLmMgPSBbbi5lID0gMF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbi5lID0gZTtcclxuICAgICAgICBuLmMgPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gSGFuZGxlIHZhbHVlcyB0aGF0IGZhaWwgdGhlIHZhbGlkaXR5IHRlc3QgaW4gQmlnTnVtYmVyLlxyXG4gICAgcGFyc2VOdW1lcmljID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pLFxyXG4gICAgICAgIGRvdEFmdGVyID0gL14oW14uXSspXFwuJC8sXHJcbiAgICAgICAgZG90QmVmb3JlID0gL15cXC4oW14uXSspJC8sXHJcbiAgICAgICAgaXNJbmZpbml0eU9yTmFOID0gL14tPyhJbmZpbml0eXxOYU4pJC8sXHJcbiAgICAgICAgd2hpdGVzcGFjZU9yUGx1cyA9IC9eXFxzKlxcKyg/PVtcXHcuXSl8Xlxccyt8XFxzKyQvZztcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgc3RyLCBpc051bSwgYikge1xyXG4gICAgICAgIHZhciBiYXNlLFxyXG4gICAgICAgICAgcyA9IGlzTnVtID8gc3RyIDogc3RyLnJlcGxhY2Uod2hpdGVzcGFjZU9yUGx1cywgJycpO1xyXG5cclxuICAgICAgICAvLyBObyBleGNlcHRpb24gb24gwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgICAgaWYgKGlzSW5maW5pdHlPck5hTi50ZXN0KHMpKSB7XHJcbiAgICAgICAgICB4LnMgPSBpc05hTihzKSA/IG51bGwgOiBzIDwgMCA/IC0xIDogMTtcclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmICghaXNOdW0pIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pXHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoYmFzZVByZWZpeCwgZnVuY3Rpb24gKG0sIHAxLCBwMikge1xyXG4gICAgICAgICAgICAgIGJhc2UgPSAocDIgPSBwMi50b0xvd2VyQ2FzZSgpKSA9PSAneCcgPyAxNiA6IHAyID09ICdiJyA/IDIgOiA4O1xyXG4gICAgICAgICAgICAgIHJldHVybiAhYiB8fCBiID09IGJhc2UgPyBwMSA6IG07XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGIpIHtcclxuICAgICAgICAgICAgICBiYXNlID0gYjtcclxuXHJcbiAgICAgICAgICAgICAgLy8gRS5nLiAnMS4nIHRvICcxJywgJy4xJyB0byAnMC4xJ1xyXG4gICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoZG90QWZ0ZXIsICckMScpLnJlcGxhY2UoZG90QmVmb3JlLCAnMC4kMScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RyICE9IHMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHMsIGJhc2UpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBudW1iZXI6IHtufSdcclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBiYXNlIHtifSBudW1iZXI6IHtufSdcclxuICAgICAgICAgIGlmIChCaWdOdW1iZXIuREVCVUcpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnTm90IGEnICsgKGIgPyAnIGJhc2UgJyArIGIgOiAnJykgKyAnIG51bWJlcjogJyArIHN0cik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTmFOXHJcbiAgICAgICAgICB4LmMgPSB4LmUgPSB4LnMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJvdW5kIHggdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0uIENoZWNrIGZvciBvdmVyL3VuZGVyLWZsb3cuXHJcbiAgICAgKiBJZiByIGlzIHRydXRoeSwgaXQgaXMga25vd24gdGhhdCB0aGVyZSBhcmUgbW9yZSBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByb3VuZCh4LCBzZCwgcm0sIHIpIHtcclxuICAgICAgdmFyIGQsIGksIGosIGssIG4sIG5pLCByZCxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICBwb3dzMTAgPSBQT1dTX1RFTjtcclxuXHJcbiAgICAgIC8vIGlmIHggaXMgbm90IEluZmluaXR5IG9yIE5hTi4uLlxyXG4gICAgICBpZiAoeGMpIHtcclxuXHJcbiAgICAgICAgLy8gcmQgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCBhZnRlciB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICAvLyBuIGlzIGEgYmFzZSAxZTE0IG51bWJlciwgdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IG9mIGFycmF5IHguYyBjb250YWluaW5nIHJkLlxyXG4gICAgICAgIC8vIG5pIGlzIHRoZSBpbmRleCBvZiBuIHdpdGhpbiB4LmMuXHJcbiAgICAgICAgLy8gZCBpcyB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgIC8vIGkgaXMgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuIGluY2x1ZGluZyBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgIC8vIGogaXMgdGhlIGFjdHVhbCBpbmRleCBvZiByZCB3aXRoaW4gbiAoaWYgPCAwLCByZCBpcyBhIGxlYWRpbmcgemVybykuXHJcbiAgICAgICAgb3V0OiB7XHJcblxyXG4gICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLlxyXG4gICAgICAgICAgZm9yIChkID0gMSwgayA9IHhjWzBdOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG4gICAgICAgICAgaSA9IHNkIC0gZDtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgICBpICs9IExPR19CQVNFO1xyXG4gICAgICAgICAgICBqID0gc2Q7XHJcbiAgICAgICAgICAgIG4gPSB4Y1tuaSA9IDBdO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgIHJkID0gbiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTAgfCAwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmkgPSBtYXRoY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5pID49IHhjLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5lZWRlZCBieSBzcXJ0LlxyXG4gICAgICAgICAgICAgICAgZm9yICg7IHhjLmxlbmd0aCA8PSBuaTsgeGMucHVzaCgwKSk7XHJcbiAgICAgICAgICAgICAgICBuID0gcmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZCA9IDE7XHJcbiAgICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG4gICAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIDE7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbiA9IGsgPSB4Y1tuaV07XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgICAgICAgIGZvciAoZCA9IDE7IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4uXHJcbiAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiwgYWRqdXN0ZWQgZm9yIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgICAgICAgLy8gVGhlIG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4gaXMgZ2l2ZW4gYnkgTE9HX0JBU0UgLSBkLlxyXG4gICAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyBkO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgICByZCA9IGogPCAwID8gMCA6IG4gLyBwb3dzMTBbZCAtIGogLSAxXSAlIDEwIHwgMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHIgPSByIHx8IHNkIDwgMCB8fFxyXG5cclxuICAgICAgICAgIC8vIEFyZSB0aGVyZSBhbnkgbm9uLXplcm8gZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdD9cclxuICAgICAgICAgIC8vIFRoZSBleHByZXNzaW9uICBuICUgcG93czEwW2QgLSBqIC0gMV0gIHJldHVybnMgYWxsIGRpZ2l0cyBvZiBuIHRvIHRoZSByaWdodFxyXG4gICAgICAgICAgLy8gb2YgdGhlIGRpZ2l0IGF0IGosIGUuZy4gaWYgbiBpcyA5MDg3MTQgYW5kIGogaXMgMiwgdGhlIGV4cHJlc3Npb24gZ2l2ZXMgNzE0LlxyXG4gICAgICAgICAgIHhjW25pICsgMV0gIT0gbnVsbCB8fCAoaiA8IDAgPyBuIDogbiAlIHBvd3MxMFtkIC0gaiAtIDFdKTtcclxuXHJcbiAgICAgICAgICByID0gcm0gPCA0XHJcbiAgICAgICAgICAgPyAocmQgfHwgcikgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgICAgOiByZCA+IDUgfHwgcmQgPT0gNSAmJiAocm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiZcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRpZ2l0IHRvIHRoZSBsZWZ0IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBvZGQuXHJcbiAgICAgICAgICAgICgoaSA+IDAgPyBqID4gMCA/IG4gLyBwb3dzMTBbZCAtIGpdIDogMCA6IHhjW25pIC0gMV0pICUgMTApICYgMSB8fFxyXG4gICAgICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgICAgICAgIGlmIChzZCA8IDEgfHwgIXhjWzBdKSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHNkIHRvIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgICAgIHNkIC09IHguZSArIDE7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDEsIDAuMSwgMC4wMSwgMC4wMDEsIDAuMDAwMSBldGMuXHJcbiAgICAgICAgICAgICAgeGNbMF0gPSBwb3dzMTBbKExPR19CQVNFIC0gc2QgJSBMT0dfQkFTRSkgJSBMT0dfQkFTRV07XHJcbiAgICAgICAgICAgICAgeC5lID0gLXNkIHx8IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICAgICAgeGNbMF0gPSB4LmUgPSAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgZXhjZXNzIGRpZ2l0cy5cclxuICAgICAgICAgIGlmIChpID09IDApIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gbmk7XHJcbiAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICBuaS0tO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gbmkgKyAxO1xyXG4gICAgICAgICAgICBrID0gcG93czEwW0xPR19CQVNFIC0gaV07XHJcblxyXG4gICAgICAgICAgICAvLyBFLmcuIDU2NzAwIGJlY29tZXMgNTYwMDAgaWYgNyBpcyB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAgIC8vIGogPiAwIG1lYW5zIGkgPiBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuLlxyXG4gICAgICAgICAgICB4Y1tuaV0gPSBqID4gMCA/IG1hdGhmbG9vcihuIC8gcG93czEwW2QgLSBqXSAlIHBvd3MxMFtqXSkgKiBrIDogMDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiB0aGUgZGlnaXQgdG8gYmUgcm91bmRlZCB1cCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgICAgIGlmIChuaSA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaSB3aWxsIGJlIHRoZSBsZW5ndGggb2YgeGNbMF0gYmVmb3JlIGsgaXMgYWRkZWQuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxLCBqID0geGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcbiAgICAgICAgICAgICAgICBqID0geGNbMF0gKz0gaztcclxuICAgICAgICAgICAgICAgIGZvciAoayA9IDE7IGogPj0gMTA7IGogLz0gMTAsIGsrKyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaWYgaSAhPSBrIHRoZSBsZW5ndGggaGFzIGluY3JlYXNlZC5cclxuICAgICAgICAgICAgICAgIGlmIChpICE9IGspIHtcclxuICAgICAgICAgICAgICAgICAgeC5lKys7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh4Y1swXSA9PSBCQVNFKSB4Y1swXSA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHhjW25pXSArPSBrO1xyXG4gICAgICAgICAgICAgICAgaWYgKHhjW25pXSAhPSBCQVNFKSBicmVhaztcclxuICAgICAgICAgICAgICAgIHhjW25pLS1dID0gMDtcclxuICAgICAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgIGZvciAoaSA9IHhjLmxlbmd0aDsgeGNbLS1pXSA9PT0gMDsgeGMucG9wKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT3ZlcmZsb3c/IEluZmluaXR5LlxyXG4gICAgICAgIGlmICh4LmUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBVbmRlcmZsb3c/IFplcm8uXHJcbiAgICAgICAgfSBlbHNlIGlmICh4LmUgPCBNSU5fRVhQKSB7XHJcbiAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdmFsdWVPZihuKSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgIGlmIChlID09PSBudWxsKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG5cclxuICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG5cclxuICAgICAgc3RyID0gZSA8PSBUT19FWFBfTkVHIHx8IGUgPj0gVE9fRVhQX1BPU1xyXG4gICAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIGUpXHJcbiAgICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgICAgcmV0dXJuIG4ucyA8IDAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIFBST1RPVFlQRS9JTlNUQU5DRSBNRVRIT0RTXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlci5cclxuICAgICAqL1xyXG4gICAgUC5hYnNvbHV0ZVZhbHVlID0gUC5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgaWYgKHgucyA8IDApIHgucyA9IDE7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVyblxyXG4gICAgICogICAxIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqICAgLTEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogICAwIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSB2YWx1ZSxcclxuICAgICAqICAgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgZWl0aGVyIGlzIE5hTi5cclxuICAgICAqL1xyXG4gICAgUC5jb21wYXJlZFRvID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogSWYgZHAgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdHJ1ZSBvciBmYWxzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb2YgdGhlXHJcbiAgICAgKiB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgKlxyXG4gICAgICogT3RoZXJ3aXNlLCBpZiBkcCBpcyBhIG51bWJlciwgcmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIGRwIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlczogaW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLmRlY2ltYWxQbGFjZXMgPSBQLmRwID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICB2YXIgYywgbiwgdixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIGRwICsgeC5lICsgMSwgcm0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIShjID0geC5jKSkgcmV0dXJuIG51bGw7XHJcbiAgICAgIG4gPSAoKHYgPSBjLmxlbmd0aCAtIDEpIC0gYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpKSAqIExPR19CQVNFO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBudW1iZXIuXHJcbiAgICAgIGlmICh2ID0gY1t2XSkgZm9yICg7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0pO1xyXG4gICAgICBpZiAobiA8IDApIG4gPSAwO1xyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gLyAwID0gSVxyXG4gICAgICogIG4gLyBOID0gTlxyXG4gICAgICogIG4gLyBJID0gMFxyXG4gICAgICogIDAgLyBuID0gMFxyXG4gICAgICogIDAgLyAwID0gTlxyXG4gICAgICogIDAgLyBOID0gTlxyXG4gICAgICogIDAgLyBJID0gMFxyXG4gICAgICogIE4gLyBuID0gTlxyXG4gICAgICogIE4gLyAwID0gTlxyXG4gICAgICogIE4gLyBOID0gTlxyXG4gICAgICogIE4gLyBJID0gTlxyXG4gICAgICogIEkgLyBuID0gSVxyXG4gICAgICogIEkgLyAwID0gSVxyXG4gICAgICogIEkgLyBOID0gTlxyXG4gICAgICogIEkgLyBJID0gTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGRpdmlkZWQgYnkgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLmRpdmlkZWRCeSA9IFAuZGl2ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCBERUNJTUFMX1BMQUNFUywgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgaW50ZWdlciBwYXJ0IG9mIGRpdmlkaW5nIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgYnkgdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5kaXZpZGVkVG9JbnRlZ2VyQnkgPSBQLmlkaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIDAsIDEpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZXhwb25lbnRpYXRlZCBieSBuLlxyXG4gICAgICpcclxuICAgICAqIElmIG0gaXMgcHJlc2VudCwgcmV0dXJuIHRoZSByZXN1bHQgbW9kdWxvIG0uXHJcbiAgICAgKiBJZiBuIGlzIG5lZ2F0aXZlIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqIElmIFBPV19QUkVDSVNJT04gaXMgbm9uLXplcm8gYW5kIG0gaXMgbm90IHByZXNlbnQsIHJvdW5kIHRvIFBPV19QUkVDSVNJT04gdXNpbmcgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgbW9kdWxhciBwb3dlciBvcGVyYXRpb24gd29ya3MgZWZmaWNpZW50bHkgd2hlbiB4LCBuLCBhbmQgbSBhcmUgaW50ZWdlcnMsIG90aGVyd2lzZSBpdFxyXG4gICAgICogaXMgZXF1aXZhbGVudCB0byBjYWxjdWxhdGluZyB4LmV4cG9uZW50aWF0ZWRCeShuKS5tb2R1bG8obSkgd2l0aCBhIFBPV19QUkVDSVNJT04gb2YgMC5cclxuICAgICAqXHJcbiAgICAgKiBuIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gVGhlIGV4cG9uZW50LiBBbiBpbnRlZ2VyLlxyXG4gICAgICogW21dIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gVGhlIG1vZHVsdXMuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEV4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiB7bn0nXHJcbiAgICAgKi9cclxuICAgIFAuZXhwb25lbnRpYXRlZEJ5ID0gUC5wb3cgPSBmdW5jdGlvbiAobiwgbSkge1xyXG4gICAgICB2YXIgaGFsZiwgaXNNb2RFeHAsIGksIGssIG1vcmUsIG5Jc0JpZywgbklzTmVnLCBuSXNPZGQsIHksXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBuID0gbmV3IEJpZ051bWJlcihuKTtcclxuXHJcbiAgICAgIC8vIEFsbG93IE5hTiBhbmQgwrFJbmZpbml0eSwgYnV0IG5vdCBvdGhlciBub24taW50ZWdlcnMuXHJcbiAgICAgIGlmIChuLmMgJiYgIW4uaXNJbnRlZ2VyKCkpIHtcclxuICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0V4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiAnICsgdmFsdWVPZihuKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChtICE9IG51bGwpIG0gPSBuZXcgQmlnTnVtYmVyKG0pO1xyXG5cclxuICAgICAgLy8gRXhwb25lbnQgb2YgTUFYX1NBRkVfSU5URUdFUiBpcyAxNS5cclxuICAgICAgbklzQmlnID0gbi5lID4gMTQ7XHJcblxyXG4gICAgICAvLyBJZiB4IGlzIE5hTiwgwrFJbmZpbml0eSwgwrEwIG9yIMKxMSwgb3IgbiBpcyDCsUluZmluaXR5LCBOYU4gb3IgwrEwLlxyXG4gICAgICBpZiAoIXguYyB8fCAheC5jWzBdIHx8IHguY1swXSA9PSAxICYmICF4LmUgJiYgeC5jLmxlbmd0aCA9PSAxIHx8ICFuLmMgfHwgIW4uY1swXSkge1xyXG5cclxuICAgICAgICAvLyBUaGUgc2lnbiBvZiB0aGUgcmVzdWx0IG9mIHBvdyB3aGVuIHggaXMgbmVnYXRpdmUgZGVwZW5kcyBvbiB0aGUgZXZlbm5lc3Mgb2Ygbi5cclxuICAgICAgICAvLyBJZiArbiBvdmVyZmxvd3MgdG8gwrFJbmZpbml0eSwgdGhlIGV2ZW5uZXNzIG9mIG4gd291bGQgYmUgbm90IGJlIGtub3duLlxyXG4gICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE1hdGgucG93KCt2YWx1ZU9mKHgpLCBuSXNCaWcgPyAyIC0gaXNPZGQobikgOiArdmFsdWVPZihuKSkpO1xyXG4gICAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBuSXNOZWcgPSBuLnMgPCAwO1xyXG5cclxuICAgICAgaWYgKG0pIHtcclxuXHJcbiAgICAgICAgLy8geCAlIG0gcmV0dXJucyBOYU4gaWYgYWJzKG0pIGlzIHplcm8sIG9yIG0gaXMgTmFOLlxyXG4gICAgICAgIGlmIChtLmMgPyAhbS5jWzBdIDogIW0ucykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgICAgaXNNb2RFeHAgPSAhbklzTmVnICYmIHguaXNJbnRlZ2VyKCkgJiYgbS5pc0ludGVnZXIoKTtcclxuXHJcbiAgICAgICAgaWYgKGlzTW9kRXhwKSB4ID0geC5tb2QobSk7XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdyB0byDCsUluZmluaXR5OiA+PTIqKjFlMTAgb3IgPj0xLjAwMDAwMjQqKjFlMTUuXHJcbiAgICAgIC8vIFVuZGVyZmxvdyB0byDCsTA6IDw9MC43OSoqMWUxMCBvciA8PTAuOTk5OTk3NSoqMWUxNS5cclxuICAgICAgfSBlbHNlIGlmIChuLmUgPiA5ICYmICh4LmUgPiAwIHx8IHguZSA8IC0xIHx8ICh4LmUgPT0gMFxyXG4gICAgICAgIC8vIFsxLCAyNDAwMDAwMDBdXHJcbiAgICAgICAgPyB4LmNbMF0gPiAxIHx8IG5Jc0JpZyAmJiB4LmNbMV0gPj0gMjRlN1xyXG4gICAgICAgIC8vIFs4MDAwMDAwMDAwMDAwMF0gIFs5OTk5OTc1MDAwMDAwMF1cclxuICAgICAgICA6IHguY1swXSA8IDhlMTMgfHwgbklzQmlnICYmIHguY1swXSA8PSA5OTk5OTc1ZTcpKSkge1xyXG5cclxuICAgICAgICAvLyBJZiB4IGlzIG5lZ2F0aXZlIGFuZCBuIGlzIG9kZCwgayA9IC0wLCBlbHNlIGsgPSAwLlxyXG4gICAgICAgIGsgPSB4LnMgPCAwICYmIGlzT2RkKG4pID8gLTAgOiAwO1xyXG5cclxuICAgICAgICAvLyBJZiB4ID49IDEsIGsgPSDCsUluZmluaXR5LlxyXG4gICAgICAgIGlmICh4LmUgPiAtMSkgayA9IDEgLyBrO1xyXG5cclxuICAgICAgICAvLyBJZiBuIGlzIG5lZ2F0aXZlIHJldHVybiDCsTAsIGVsc2UgcmV0dXJuIMKxSW5maW5pdHkuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIobklzTmVnID8gMSAvIGsgOiBrKTtcclxuXHJcbiAgICAgIH0gZWxzZSBpZiAoUE9XX1BSRUNJU0lPTikge1xyXG5cclxuICAgICAgICAvLyBUcnVuY2F0aW5nIGVhY2ggY29lZmZpY2llbnQgYXJyYXkgdG8gYSBsZW5ndGggb2YgayBhZnRlciBlYWNoIG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgLy8gZXF1YXRlcyB0byB0cnVuY2F0aW5nIHNpZ25pZmljYW50IGRpZ2l0cyB0byBQT1dfUFJFQ0lTSU9OICsgWzI4LCA0MV0sXHJcbiAgICAgICAgLy8gaS5lLiB0aGVyZSB3aWxsIGJlIGEgbWluaW11bSBvZiAyOCBndWFyZCBkaWdpdHMgcmV0YWluZWQuXHJcbiAgICAgICAgayA9IG1hdGhjZWlsKFBPV19QUkVDSVNJT04gLyBMT0dfQkFTRSArIDIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobklzQmlnKSB7XHJcbiAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoMC41KTtcclxuICAgICAgICBpZiAobklzTmVnKSBuLnMgPSAxO1xyXG4gICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGkgPSBNYXRoLmFicygrdmFsdWVPZihuKSk7XHJcbiAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICAvLyBQZXJmb3JtcyA1NCBsb29wIGl0ZXJhdGlvbnMgZm9yIG4gb2YgOTAwNzE5OTI1NDc0MDk5MS5cclxuICAgICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgICAgaWYgKG5Jc09kZCkge1xyXG4gICAgICAgICAgeSA9IHkudGltZXMoeCk7XHJcbiAgICAgICAgICBpZiAoIXkuYykgYnJlYWs7XHJcblxyXG4gICAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgICAgaWYgKHkuYy5sZW5ndGggPiBrKSB5LmMubGVuZ3RoID0gaztcclxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICAgICAgeSA9IHkubW9kKG0pOyAgICAvL3kgPSB5Lm1pbnVzKGRpdih5LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGkpIHtcclxuICAgICAgICAgIGkgPSBtYXRoZmxvb3IoaSAvIDIpO1xyXG4gICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG4gPSBuLnRpbWVzKGhhbGYpO1xyXG4gICAgICAgICAgcm91bmQobiwgbi5lICsgMSwgMSk7XHJcblxyXG4gICAgICAgICAgaWYgKG4uZSA+IDE0KSB7XHJcbiAgICAgICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSA9ICt2YWx1ZU9mKG4pO1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeCA9IHgudGltZXMoeCk7XHJcblxyXG4gICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICBpZiAoeC5jICYmIHguYy5sZW5ndGggPiBrKSB4LmMubGVuZ3RoID0gaztcclxuICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICB4ID0geC5tb2QobSk7ICAgIC8veCA9IHgubWludXMoZGl2KHgsIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNNb2RFeHApIHJldHVybiB5O1xyXG4gICAgICBpZiAobklzTmVnKSB5ID0gT05FLmRpdih5KTtcclxuXHJcbiAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiBrID8gcm91bmQoeSwgUE9XX1BSRUNJU0lPTiwgUk9VTkRJTkdfTU9ERSwgbW9yZSkgOiB5O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gYW4gaW50ZWdlclxyXG4gICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3JtfSdcclxuICAgICAqL1xyXG4gICAgUC5pbnRlZ2VyVmFsdWUgPSBmdW5jdGlvbiAocm0pIHtcclxuICAgICAgdmFyIG4gPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuICAgICAgcmV0dXJuIHJvdW5kKG4sIG4uZSArIDEsIHJtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNFcXVhbFRvID0gUC5lcSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID09PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhIGZpbml0ZSBudW1iZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNGaW5pdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYztcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzR3JlYXRlclRoYW4gPSBQLmd0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPiAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyA9IFAuZ3RlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IDEgfHwgYiA9PT0gMDtcclxuXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGFuIGludGVnZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNJbnRlZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmMgJiYgYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpID4gdGhpcy5jLmxlbmd0aCAtIDI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0xlc3NUaGFuID0gUC5sdCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpIDwgMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTGVzc1RoYW5PckVxdWFsVG8gPSBQLmx0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAtMSB8fCBiID09PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBOYU4sIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNOYU4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhdGhpcy5zO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBuZWdhdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc05lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zIDwgMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgcG9zaXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucyA+IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIDAgb3IgLTAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmMgJiYgdGhpcy5jWzBdID09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gLSAwID0gblxyXG4gICAgICogIG4gLSBOID0gTlxyXG4gICAgICogIG4gLSBJID0gLUlcclxuICAgICAqICAwIC0gbiA9IC1uXHJcbiAgICAgKiAgMCAtIDAgPSAwXHJcbiAgICAgKiAgMCAtIE4gPSBOXHJcbiAgICAgKiAgMCAtIEkgPSAtSVxyXG4gICAgICogIE4gLSBuID0gTlxyXG4gICAgICogIE4gLSAwID0gTlxyXG4gICAgICogIE4gLSBOID0gTlxyXG4gICAgICogIE4gLSBJID0gTlxyXG4gICAgICogIEkgLSBuID0gSVxyXG4gICAgICogIEkgLSAwID0gSVxyXG4gICAgICogIEkgLSBOID0gTlxyXG4gICAgICogIEkgLSBJID0gTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1pbnVzIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLm1pbnVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIGksIGosIHQsIHhMVHksXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgICBiID0geS5zO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTj9cclxuICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgcmV0dXJuIHgucGx1cyh5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIHhjID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeWMgPyB4IDogTmFOKTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICAgIHJldHVybiB5Y1swXSA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6XHJcblxyXG4gICAgICAgICAgIC8vIElFRUUgNzU0ICgyMDA4KSA2LjM6IG4gLSBuID0gLTAgd2hlbiByb3VuZGluZyB0byAtSW5maW5pdHlcclxuICAgICAgICAgICBST1VORElOR19NT0RFID09IDMgPyAtMCA6IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggaXMgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG5cclxuICAgICAgICBpZiAoeExUeSA9IGEgPCAwKSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXHJcbiAgICAgICAgZm9yIChiID0gYTsgYi0tOyB0LnB1c2goMCkpO1xyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudHMgZXF1YWwuIENoZWNrIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgICAgIGogPSAoeExUeSA9IChhID0geGMubGVuZ3RoKSA8IChiID0geWMubGVuZ3RoKSkgPyBhIDogYjtcclxuXHJcbiAgICAgICAgZm9yIChhID0gYiA9IDA7IGIgPCBqOyBiKyspIHtcclxuXHJcbiAgICAgICAgICBpZiAoeGNbYl0gIT0geWNbYl0pIHtcclxuICAgICAgICAgICAgeExUeSA9IHhjW2JdIDwgeWNbYl07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8geCA8IHk/IFBvaW50IHhjIHRvIHRoZSBhcnJheSBvZiB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgaWYgKHhMVHkpIHQgPSB4YywgeGMgPSB5YywgeWMgPSB0LCB5LnMgPSAteS5zO1xyXG5cclxuICAgICAgYiA9IChqID0geWMubGVuZ3RoKSAtIChpID0geGMubGVuZ3RoKTtcclxuXHJcbiAgICAgIC8vIEFwcGVuZCB6ZXJvcyB0byB4YyBpZiBzaG9ydGVyLlxyXG4gICAgICAvLyBObyBuZWVkIHRvIGFkZCB6ZXJvcyB0byB5YyBpZiBzaG9ydGVyIGFzIHN1YnRyYWN0IG9ubHkgbmVlZHMgdG8gc3RhcnQgYXQgeWMubGVuZ3RoLlxyXG4gICAgICBpZiAoYiA+IDApIGZvciAoOyBiLS07IHhjW2krK10gPSAwKTtcclxuICAgICAgYiA9IEJBU0UgLSAxO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgeWMgZnJvbSB4Yy5cclxuICAgICAgZm9yICg7IGogPiBhOykge1xyXG5cclxuICAgICAgICBpZiAoeGNbLS1qXSA8IHljW2pdKSB7XHJcbiAgICAgICAgICBmb3IgKGkgPSBqOyBpICYmICF4Y1stLWldOyB4Y1tpXSA9IGIpO1xyXG4gICAgICAgICAgLS14Y1tpXTtcclxuICAgICAgICAgIHhjW2pdICs9IEJBU0U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4Y1tqXSAtPSB5Y1tqXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MgYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgZm9yICg7IHhjWzBdID09IDA7IHhjLnNwbGljZSgwLCAxKSwgLS15ZSk7XHJcblxyXG4gICAgICAvLyBaZXJvP1xyXG4gICAgICBpZiAoIXhjWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIEZvbGxvd2luZyBJRUVFIDc1NCAoMjAwOCkgNi4zLFxyXG4gICAgICAgIC8vIG4gLSBuID0gKzAgIGJ1dCAgbiAtIG4gPSAtMCAgd2hlbiByb3VuZGluZyB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgICB5LnMgPSBST1VORElOR19NT0RFID09IDMgPyAtMSA6IDE7XHJcbiAgICAgICAgeS5jID0gW3kuZSA9IDBdO1xyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciBJbmZpbml0eSBhcyAreCAtICt5ICE9IEluZmluaXR5ICYmIC14IC0gLXkgIT0gSW5maW5pdHlcclxuICAgICAgLy8gZm9yIGZpbml0ZSB4IGFuZCB5LlxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHhjLCB5ZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogICBuICUgMCA9ICBOXHJcbiAgICAgKiAgIG4gJSBOID0gIE5cclxuICAgICAqICAgbiAlIEkgPSAgblxyXG4gICAgICogICAwICUgbiA9ICAwXHJcbiAgICAgKiAgLTAgJSBuID0gLTBcclxuICAgICAqICAgMCAlIDAgPSAgTlxyXG4gICAgICogICAwICUgTiA9ICBOXHJcbiAgICAgKiAgIDAgJSBJID0gIDBcclxuICAgICAqICAgTiAlIG4gPSAgTlxyXG4gICAgICogICBOICUgMCA9ICBOXHJcbiAgICAgKiAgIE4gJSBOID0gIE5cclxuICAgICAqICAgTiAlIEkgPSAgTlxyXG4gICAgICogICBJICUgbiA9ICBOXHJcbiAgICAgKiAgIEkgJSAwID0gIE5cclxuICAgICAqICAgSSAlIE4gPSAgTlxyXG4gICAgICogICBJICUgSSA9ICBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbW9kdWxvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLiBUaGUgcmVzdWx0IGRlcGVuZHMgb24gdGhlIHZhbHVlIG9mIE1PRFVMT19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLm1vZHVsbyA9IFAubW9kID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIHEsIHMsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgeCBpcyBJbmZpbml0eSBvciBOYU4sIG9yIHkgaXMgTmFOIG9yIHplcm8uXHJcbiAgICAgIGlmICgheC5jIHx8ICF5LnMgfHwgeS5jICYmICF5LmNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIHggaWYgeSBpcyBJbmZpbml0eSBvciB4IGlzIHplcm8uXHJcbiAgICAgIH0gZWxzZSBpZiAoIXkuYyB8fCB4LmMgJiYgIXguY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoTU9EVUxPX01PREUgPT0gOSkge1xyXG5cclxuICAgICAgICAvLyBFdWNsaWRpYW4gZGl2aXNpb246IHEgPSBzaWduKHkpICogZmxvb3IoeCAvIGFicyh5KSlcclxuICAgICAgICAvLyByID0geCAtIHF5ICAgIHdoZXJlICAwIDw9IHIgPCBhYnMoeSlcclxuICAgICAgICBzID0geS5zO1xyXG4gICAgICAgIHkucyA9IDE7XHJcbiAgICAgICAgcSA9IGRpdih4LCB5LCAwLCAzKTtcclxuICAgICAgICB5LnMgPSBzO1xyXG4gICAgICAgIHEucyAqPSBzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHEgPSBkaXYoeCwgeSwgMCwgTU9EVUxPX01PREUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB5ID0geC5taW51cyhxLnRpbWVzKHkpKTtcclxuXHJcbiAgICAgIC8vIFRvIG1hdGNoIEphdmFTY3JpcHQgJSwgZW5zdXJlIHNpZ24gb2YgemVybyBpcyBzaWduIG9mIGRpdmlkZW5kLlxyXG4gICAgICBpZiAoIXkuY1swXSAmJiBNT0RVTE9fTU9ERSA9PSAxKSB5LnMgPSB4LnM7XHJcblxyXG4gICAgICByZXR1cm4geTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAqIDAgPSAwXHJcbiAgICAgKiAgbiAqIE4gPSBOXHJcbiAgICAgKiAgbiAqIEkgPSBJXHJcbiAgICAgKiAgMCAqIG4gPSAwXHJcbiAgICAgKiAgMCAqIDAgPSAwXHJcbiAgICAgKiAgMCAqIE4gPSBOXHJcbiAgICAgKiAgMCAqIEkgPSBOXHJcbiAgICAgKiAgTiAqIG4gPSBOXHJcbiAgICAgKiAgTiAqIDAgPSBOXHJcbiAgICAgKiAgTiAqIE4gPSBOXHJcbiAgICAgKiAgTiAqIEkgPSBOXHJcbiAgICAgKiAgSSAqIG4gPSBJXHJcbiAgICAgKiAgSSAqIDAgPSBOXHJcbiAgICAgKiAgSSAqIE4gPSBOXHJcbiAgICAgKiAgSSAqIEkgPSBJXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbXVsdGlwbGllZCBieSB0aGUgdmFsdWVcclxuICAgICAqIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5tdWx0aXBsaWVkQnkgPSBQLnRpbWVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIGMsIGUsIGksIGosIGssIG0sIHhjTCwgeGxvLCB4aGksIHljTCwgeWxvLCB5aGksIHpjLFxyXG4gICAgICAgIGJhc2UsIHNxcnRCYXNlLFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0gKHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpKS5jO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTiwgwrFJbmZpbml0eSBvciDCsTA/XHJcbiAgICAgIGlmICgheGMgfHwgIXljIHx8ICF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgaXMgTmFOLCBvciBvbmUgaXMgMCBhbmQgdGhlIG90aGVyIGlzIEluZmluaXR5LlxyXG4gICAgICAgIGlmICgheC5zIHx8ICF5LnMgfHwgeGMgJiYgIXhjWzBdICYmICF5YyB8fCB5YyAmJiAheWNbMF0gJiYgIXhjKSB7XHJcbiAgICAgICAgICB5LmMgPSB5LmUgPSB5LnMgPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5LnMgKj0geC5zO1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciBpcyDCsUluZmluaXR5LlxyXG4gICAgICAgICAgaWYgKCF4YyB8fCAheWMpIHtcclxuICAgICAgICAgICAgeS5jID0geS5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIGVpdGhlciBpcyDCsTAuXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB5LmMgPSBbMF07XHJcbiAgICAgICAgICAgIHkuZSA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZSA9IGJpdEZsb29yKHguZSAvIExPR19CQVNFKSArIGJpdEZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgICAgeS5zICo9IHgucztcclxuICAgICAgeGNMID0geGMubGVuZ3RoO1xyXG4gICAgICB5Y0wgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBFbnN1cmUgeGMgcG9pbnRzIHRvIGxvbmdlciBhcnJheSBhbmQgeGNMIHRvIGl0cyBsZW5ndGguXHJcbiAgICAgIGlmICh4Y0wgPCB5Y0wpIHpjID0geGMsIHhjID0geWMsIHljID0gemMsIGkgPSB4Y0wsIHhjTCA9IHljTCwgeWNMID0gaTtcclxuXHJcbiAgICAgIC8vIEluaXRpYWxpc2UgdGhlIHJlc3VsdCBhcnJheSB3aXRoIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSB4Y0wgKyB5Y0wsIHpjID0gW107IGktLTsgemMucHVzaCgwKSk7XHJcblxyXG4gICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgc3FydEJhc2UgPSBTUVJUX0JBU0U7XHJcblxyXG4gICAgICBmb3IgKGkgPSB5Y0w7IC0taSA+PSAwOykge1xyXG4gICAgICAgIGMgPSAwO1xyXG4gICAgICAgIHlsbyA9IHljW2ldICUgc3FydEJhc2U7XHJcbiAgICAgICAgeWhpID0geWNbaV0gLyBzcXJ0QmFzZSB8IDA7XHJcblxyXG4gICAgICAgIGZvciAoayA9IHhjTCwgaiA9IGkgKyBrOyBqID4gaTspIHtcclxuICAgICAgICAgIHhsbyA9IHhjWy0ta10gJSBzcXJ0QmFzZTtcclxuICAgICAgICAgIHhoaSA9IHhjW2tdIC8gc3FydEJhc2UgfCAwO1xyXG4gICAgICAgICAgbSA9IHloaSAqIHhsbyArIHhoaSAqIHlsbztcclxuICAgICAgICAgIHhsbyA9IHlsbyAqIHhsbyArICgobSAlIHNxcnRCYXNlKSAqIHNxcnRCYXNlKSArIHpjW2pdICsgYztcclxuICAgICAgICAgIGMgPSAoeGxvIC8gYmFzZSB8IDApICsgKG0gLyBzcXJ0QmFzZSB8IDApICsgeWhpICogeGhpO1xyXG4gICAgICAgICAgemNbai0tXSA9IHhsbyAlIGJhc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB6Y1tqXSA9IGM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjKSB7XHJcbiAgICAgICAgKytlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHpjLnNwbGljZSgwLCAxKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB6YywgZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbmVnYXRlZCxcclxuICAgICAqIGkuZS4gbXVsdGlwbGllZCBieSAtMS5cclxuICAgICAqL1xyXG4gICAgUC5uZWdhdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgeCA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIHgucyA9IC14LnMgfHwgbnVsbDtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gKyAwID0gblxyXG4gICAgICogIG4gKyBOID0gTlxyXG4gICAgICogIG4gKyBJID0gSVxyXG4gICAgICogIDAgKyBuID0gblxyXG4gICAgICogIDAgKyAwID0gMFxyXG4gICAgICogIDAgKyBOID0gTlxyXG4gICAgICogIDAgKyBJID0gSVxyXG4gICAgICogIE4gKyBuID0gTlxyXG4gICAgICogIE4gKyAwID0gTlxyXG4gICAgICogIE4gKyBOID0gTlxyXG4gICAgICogIE4gKyBJID0gTlxyXG4gICAgICogIEkgKyBuID0gSVxyXG4gICAgICogIEkgKyAwID0gSVxyXG4gICAgICogIEkgKyBOID0gTlxyXG4gICAgICogIEkgKyBJID0gSVxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHBsdXMgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAucGx1cyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciB0LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGEgPSB4LnM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgICAgYiA9IHkucztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgIGlmIChhICE9IGIpIHtcclxuICAgICAgICB5LnMgPSAtYjtcclxuICAgICAgICByZXR1cm4geC5taW51cyh5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciDCsUluZmluaXR5LlxyXG4gICAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4gbmV3IEJpZ051bWJlcihhIC8gMCk7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSByZXR1cm4geWNbMF0gPyB5IDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOiBhICogMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHhlID0gYml0Rmxvb3IoeGUpO1xyXG4gICAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuIEZhc3RlciB0byB1c2UgcmV2ZXJzZSB0aGVuIGRvIHVuc2hpZnRzLlxyXG4gICAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuICAgICAgICBpZiAoYSA+IDApIHtcclxuICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgIHQgPSB4YztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICAgIGZvciAoOyBhLS07IHQucHVzaCgwKSk7XHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGEgPSB4Yy5sZW5ndGg7XHJcbiAgICAgIGIgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBQb2ludCB4YyB0byB0aGUgbG9uZ2VyIGFycmF5LCBhbmQgYiB0byB0aGUgc2hvcnRlciBsZW5ndGguXHJcbiAgICAgIGlmIChhIC0gYiA8IDApIHQgPSB5YywgeWMgPSB4YywgeGMgPSB0LCBiID0gYTtcclxuXHJcbiAgICAgIC8vIE9ubHkgc3RhcnQgYWRkaW5nIGF0IHljLmxlbmd0aCAtIDEgYXMgdGhlIGZ1cnRoZXIgZGlnaXRzIG9mIHhjIGNhbiBiZSBpZ25vcmVkLlxyXG4gICAgICBmb3IgKGEgPSAwOyBiOykge1xyXG4gICAgICAgIGEgPSAoeGNbLS1iXSA9IHhjW2JdICsgeWNbYl0gKyBhKSAvIEJBU0UgfCAwO1xyXG4gICAgICAgIHhjW2JdID0gQkFTRSA9PT0geGNbYl0gPyAwIDogeGNbYl0gJSBCQVNFO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYSkge1xyXG4gICAgICAgIHhjID0gW2FdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgKyt5ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgemVybywgYXMgK3ggKyAreSAhPSAwICYmIC14ICsgLXkgIT0gMFxyXG4gICAgICAvLyB5ZSA9IE1BWF9FWFAgKyAxIHBvc3NpYmxlXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgeGMsIHllKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBJZiBzZCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2ZcclxuICAgICAqIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgKiBJZiBzZCBpcyB0cnVlIGluY2x1ZGUgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zIGluIHRoZSBjb3VudC5cclxuICAgICAqXHJcbiAgICAgKiBPdGhlcndpc2UsIGlmIHNkIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2Ygc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogc2Qge251bWJlcnxib29sZWFufSBudW1iZXI6IHNpZ25pZmljYW50IGRpZ2l0czogaW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICBib29sZWFuOiB3aGV0aGVyIHRvIGNvdW50IGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvczogdHJ1ZSBvciBmYWxzZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3NkfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC5wcmVjaXNpb24gPSBQLnNkID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgICB2YXIgYywgbiwgdixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChzZCAhPSBudWxsICYmIHNkICE9PSAhIXNkKSB7XHJcbiAgICAgICAgaW50Q2hlY2soc2QsIDEsIE1BWCk7XHJcbiAgICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIHNkLCBybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgICAgdiA9IGMubGVuZ3RoIC0gMTtcclxuICAgICAgbiA9IHYgKiBMT0dfQkFTRSArIDE7XHJcblxyXG4gICAgICBpZiAodiA9IGNbdl0pIHtcclxuXHJcbiAgICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBlbGVtZW50LlxyXG4gICAgICAgIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50LlxyXG4gICAgICAgIGZvciAodiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIG4rKyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzZCAmJiB4LmUgKyAxID4gbikgbiA9IHguZSArIDE7XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBzaGlmdGVkIGJ5IGsgcGxhY2VzXHJcbiAgICAgKiAocG93ZXJzIG9mIDEwKS4gU2hpZnQgdG8gdGhlIHJpZ2h0IGlmIG4gPiAwLCBhbmQgdG8gdGhlIGxlZnQgaWYgbiA8IDAuXHJcbiAgICAgKlxyXG4gICAgICogayB7bnVtYmVyfSBJbnRlZ2VyLCAtTUFYX1NBRkVfSU5URUdFUiB0byBNQVhfU0FGRV9JTlRFR0VSIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2t9J1xyXG4gICAgICovXHJcbiAgICBQLnNoaWZ0ZWRCeSA9IGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgIGludENoZWNrKGssIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKTtcclxuICAgICAgcmV0dXJuIHRoaXMudGltZXMoJzFlJyArIGspO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBzcXJ0KC1uKSA9ICBOXHJcbiAgICAgKiAgc3FydChOKSA9ICBOXHJcbiAgICAgKiAgc3FydCgtSSkgPSAgTlxyXG4gICAgICogIHNxcnQoSSkgPSAgSVxyXG4gICAgICogIHNxcnQoMCkgPSAgMFxyXG4gICAgICogIHNxcnQoLTApID0gLTBcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsXHJcbiAgICAgKiByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5zcXVhcmVSb290ID0gUC5zcXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgbSwgbiwgciwgcmVwLCB0LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGMgPSB4LmMsXHJcbiAgICAgICAgcyA9IHgucyxcclxuICAgICAgICBlID0geC5lLFxyXG4gICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMgKyA0LFxyXG4gICAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKCcwLjUnKTtcclxuXHJcbiAgICAgIC8vIE5lZ2F0aXZlL05hTi9JbmZpbml0eS96ZXJvP1xyXG4gICAgICBpZiAocyAhPT0gMSB8fCAhYyB8fCAhY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKCFzIHx8IHMgPCAwICYmICghYyB8fCBjWzBdKSA/IE5hTiA6IGMgPyB4IDogMSAvIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJbml0aWFsIGVzdGltYXRlLlxyXG4gICAgICBzID0gTWF0aC5zcXJ0KCt2YWx1ZU9mKHgpKTtcclxuXHJcbiAgICAgIC8vIE1hdGguc3FydCB1bmRlcmZsb3cvb3ZlcmZsb3c/XHJcbiAgICAgIC8vIFBhc3MgeCB0byBNYXRoLnNxcnQgYXMgaW50ZWdlciwgdGhlbiBhZGp1c3QgdGhlIGV4cG9uZW50IG9mIHRoZSByZXN1bHQuXHJcbiAgICAgIGlmIChzID09IDAgfHwgcyA9PSAxIC8gMCkge1xyXG4gICAgICAgIG4gPSBjb2VmZlRvU3RyaW5nKGMpO1xyXG4gICAgICAgIGlmICgobi5sZW5ndGggKyBlKSAlIDIgPT0gMCkgbiArPSAnMCc7XHJcbiAgICAgICAgcyA9IE1hdGguc3FydCgrbik7XHJcbiAgICAgICAgZSA9IGJpdEZsb29yKChlICsgMSkgLyAyKSAtIChlIDwgMCB8fCBlICUgMik7XHJcblxyXG4gICAgICAgIGlmIChzID09IDEgLyAwKSB7XHJcbiAgICAgICAgICBuID0gJzFlJyArIGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcclxuICAgICAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZignZScpICsgMSkgKyBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIobik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIocyArICcnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgZm9yIHplcm8uXHJcbiAgICAgIC8vIHIgY291bGQgYmUgemVybyBpZiBNSU5fRVhQIGlzIGNoYW5nZWQgYWZ0ZXIgdGhlIHRoaXMgdmFsdWUgd2FzIGNyZWF0ZWQuXHJcbiAgICAgIC8vIFRoaXMgd291bGQgY2F1c2UgYSBkaXZpc2lvbiBieSB6ZXJvICh4L3QpIGFuZCBoZW5jZSBJbmZpbml0eSBiZWxvdywgd2hpY2ggd291bGQgY2F1c2VcclxuICAgICAgLy8gY29lZmZUb1N0cmluZyB0byB0aHJvdy5cclxuICAgICAgaWYgKHIuY1swXSkge1xyXG4gICAgICAgIGUgPSByLmU7XHJcbiAgICAgICAgcyA9IGUgKyBkcDtcclxuICAgICAgICBpZiAocyA8IDMpIHMgPSAwO1xyXG5cclxuICAgICAgICAvLyBOZXd0b24tUmFwaHNvbiBpdGVyYXRpb24uXHJcbiAgICAgICAgZm9yICg7IDspIHtcclxuICAgICAgICAgIHQgPSByO1xyXG4gICAgICAgICAgciA9IGhhbGYudGltZXModC5wbHVzKGRpdih4LCB0LCBkcCwgMSkpKTtcclxuXHJcbiAgICAgICAgICBpZiAoY29lZmZUb1N0cmluZyh0LmMpLnNsaWNlKDAsIHMpID09PSAobiA9IGNvZWZmVG9TdHJpbmcoci5jKSkuc2xpY2UoMCwgcykpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBleHBvbmVudCBvZiByIG1heSBoZXJlIGJlIG9uZSBsZXNzIHRoYW4gdGhlIGZpbmFsIHJlc3VsdCBleHBvbmVudCxcclxuICAgICAgICAgICAgLy8gZS5nIDAuMDAwOTk5OSAoZS00KSAtLT4gMC4wMDEgKGUtMyksIHNvIGFkanVzdCBzIHNvIHRoZSByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgLy8gYXJlIGluZGV4ZWQgY29ycmVjdGx5LlxyXG4gICAgICAgICAgICBpZiAoci5lIDwgZSkgLS1zO1xyXG4gICAgICAgICAgICBuID0gbi5zbGljZShzIC0gMywgcyArIDEpO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIDR0aCByb3VuZGluZyBkaWdpdCBtYXkgYmUgaW4gZXJyb3IgYnkgLTEgc28gaWYgdGhlIDQgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAgIC8vIGFyZSA5OTk5IG9yIDQ5OTkgKGkuZS4gYXBwcm9hY2hpbmcgYSByb3VuZGluZyBib3VuZGFyeSkgY29udGludWUgdGhlXHJcbiAgICAgICAgICAgIC8vIGl0ZXJhdGlvbi5cclxuICAgICAgICAgICAgaWYgKG4gPT0gJzk5OTknIHx8ICFyZXAgJiYgbiA9PSAnNDk5OScpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gT24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBvbmx5LCBjaGVjayB0byBzZWUgaWYgcm91bmRpbmcgdXAgZ2l2ZXMgdGhlXHJcbiAgICAgICAgICAgICAgLy8gZXhhY3QgcmVzdWx0IGFzIHRoZSBuaW5lcyBtYXkgaW5maW5pdGVseSByZXBlYXQuXHJcbiAgICAgICAgICAgICAgaWYgKCFyZXApIHtcclxuICAgICAgICAgICAgICAgIHJvdW5kKHQsIHQuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHQudGltZXModCkuZXEoeCkpIHtcclxuICAgICAgICAgICAgICAgICAgciA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgZHAgKz0gNDtcclxuICAgICAgICAgICAgICBzICs9IDQ7XHJcbiAgICAgICAgICAgICAgcmVwID0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgcm91bmRpbmcgZGlnaXRzIGFyZSBudWxsLCAwezAsNH0gb3IgNTB7MCwzfSwgY2hlY2sgZm9yIGV4YWN0XHJcbiAgICAgICAgICAgICAgLy8gcmVzdWx0LiBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1Jykge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgICAgIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMSk7XHJcbiAgICAgICAgICAgICAgICBtID0gIXIudGltZXMocikuZXEoeCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMSwgUk9VTkRJTkdfTU9ERSwgbSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZXhwb25lbnRpYWwgbm90YXRpb24gYW5kXHJcbiAgICAgKiByb3VuZGVkIHVzaW5nIFJPVU5ESU5HX01PREUgdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvRXhwb25lbnRpYWwgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgZHArKztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRpbmdcclxuICAgICAqIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBhcyB3aXRoIEphdmFTY3JpcHQncyBudW1iZXIgdHlwZSwgKC0wKS50b0ZpeGVkKDApIGlzICcwJyxcclxuICAgICAqIGJ1dCBlLmcuICgtMC4wMDAwMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b0ZpeGVkID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGRwID0gZHAgKyB0aGlzLmUgKyAxO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGVkXHJcbiAgICAgKiB1c2luZyBybSBvciBST1VORElOR19NT0RFIHRvIGRwIGRlY2ltYWwgcGxhY2VzLCBhbmQgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgcHJvcGVydGllc1xyXG4gICAgICogb2YgdGhlIGZvcm1hdCBvciBGT1JNQVQgb2JqZWN0IChzZWUgQmlnTnVtYmVyLnNldCkuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGZvcm1hdHRpbmcgb2JqZWN0IG1heSBjb250YWluIHNvbWUgb3IgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIHNob3duIGJlbG93LlxyXG4gICAgICpcclxuICAgICAqIEZPUk1BVCA9IHtcclxuICAgICAqICAgcHJlZml4OiAnJyxcclxuICAgICAqICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICogICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgKiAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgICAqICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgKiAgIHN1ZmZpeDogJydcclxuICAgICAqIH07XHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICogW2Zvcm1hdF0ge29iamVjdH0gRm9ybWF0dGluZyBvcHRpb25zLiBTZWUgRk9STUFUIHBiamVjdCBhYm92ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCBub3QgYW4gb2JqZWN0OiB7Zm9ybWF0fSdcclxuICAgICAqL1xyXG4gICAgUC50b0Zvcm1hdCA9IGZ1bmN0aW9uIChkcCwgcm0sIGZvcm1hdCkge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGRwICE9IG51bGwgJiYgcm0gJiYgdHlwZW9mIHJtID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBybTtcclxuICAgICAgICAgIHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2UgaWYgKGRwICYmIHR5cGVvZiBkcCA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgZm9ybWF0ID0gZHA7XHJcbiAgICAgICAgICBkcCA9IHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZm9ybWF0ID0gRk9STUFUO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm9ybWF0ICE9ICdvYmplY3QnKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCBub3QgYW4gb2JqZWN0OiAnICsgZm9ybWF0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RyID0geC50b0ZpeGVkKGRwLCBybSk7XHJcblxyXG4gICAgICBpZiAoeC5jKSB7XHJcbiAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJy4nKSxcclxuICAgICAgICAgIGcxID0gK2Zvcm1hdC5ncm91cFNpemUsXHJcbiAgICAgICAgICBnMiA9ICtmb3JtYXQuc2Vjb25kYXJ5R3JvdXBTaXplLFxyXG4gICAgICAgICAgZ3JvdXBTZXBhcmF0b3IgPSBmb3JtYXQuZ3JvdXBTZXBhcmF0b3IgfHwgJycsXHJcbiAgICAgICAgICBpbnRQYXJ0ID0gYXJyWzBdLFxyXG4gICAgICAgICAgZnJhY3Rpb25QYXJ0ID0gYXJyWzFdLFxyXG4gICAgICAgICAgaXNOZWcgPSB4LnMgPCAwLFxyXG4gICAgICAgICAgaW50RGlnaXRzID0gaXNOZWcgPyBpbnRQYXJ0LnNsaWNlKDEpIDogaW50UGFydCxcclxuICAgICAgICAgIGxlbiA9IGludERpZ2l0cy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmIChnMikgaSA9IGcxLCBnMSA9IGcyLCBnMiA9IGksIGxlbiAtPSBpO1xyXG5cclxuICAgICAgICBpZiAoZzEgPiAwICYmIGxlbiA+IDApIHtcclxuICAgICAgICAgIGkgPSBsZW4gJSBnMSB8fCBnMTtcclxuICAgICAgICAgIGludFBhcnQgPSBpbnREaWdpdHMuc3Vic3RyKDAsIGkpO1xyXG4gICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkgKz0gZzEpIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc3Vic3RyKGksIGcxKTtcclxuICAgICAgICAgIGlmIChnMiA+IDApIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc2xpY2UoaSk7XHJcbiAgICAgICAgICBpZiAoaXNOZWcpIGludFBhcnQgPSAnLScgKyBpbnRQYXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gZnJhY3Rpb25QYXJ0XHJcbiAgICAgICAgID8gaW50UGFydCArIChmb3JtYXQuZGVjaW1hbFNlcGFyYXRvciB8fCAnJykgKyAoKGcyID0gK2Zvcm1hdC5mcmFjdGlvbkdyb3VwU2l6ZSlcclxuICAgICAgICAgID8gZnJhY3Rpb25QYXJ0LnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXGR7JyArIGcyICsgJ31cXFxcQicsICdnJyksXHJcbiAgICAgICAgICAgJyQmJyArIChmb3JtYXQuZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB8fCAnJykpXHJcbiAgICAgICAgICA6IGZyYWN0aW9uUGFydClcclxuICAgICAgICAgOiBpbnRQYXJ0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gKGZvcm1hdC5wcmVmaXggfHwgJycpICsgc3RyICsgKGZvcm1hdC5zdWZmaXggfHwgJycpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiB0d28gQmlnTnVtYmVycyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGFzIGEgc2ltcGxlXHJcbiAgICAgKiBmcmFjdGlvbiB3aXRoIGFuIGludGVnZXIgbnVtZXJhdG9yIGFuZCBhbiBpbnRlZ2VyIGRlbm9taW5hdG9yLlxyXG4gICAgICogVGhlIGRlbm9taW5hdG9yIHdpbGwgYmUgYSBwb3NpdGl2ZSBub24temVybyB2YWx1ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNwZWNpZmllZFxyXG4gICAgICogbWF4aW11bSBkZW5vbWluYXRvci4gSWYgYSBtYXhpbXVtIGRlbm9taW5hdG9yIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBkZW5vbWluYXRvciB3aWxsIGJlXHJcbiAgICAgKiB0aGUgbG93ZXN0IHZhbHVlIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIG51bWJlciBleGFjdGx5LlxyXG4gICAgICpcclxuICAgICAqIFttZF0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBJbnRlZ2VyID49IDEsIG9yIEluZmluaXR5LiBUaGUgbWF4aW11bSBkZW5vbWluYXRvci5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX0gOiB7bWR9J1xyXG4gICAgICovXHJcbiAgICBQLnRvRnJhY3Rpb24gPSBmdW5jdGlvbiAobWQpIHtcclxuICAgICAgdmFyIGQsIGQwLCBkMSwgZDIsIGUsIGV4cCwgbiwgbjAsIG4xLCBxLCByLCBzLFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIHhjID0geC5jO1xyXG5cclxuICAgICAgaWYgKG1kICE9IG51bGwpIHtcclxuICAgICAgICBuID0gbmV3IEJpZ051bWJlcihtZCk7XHJcblxyXG4gICAgICAgIC8vIFRocm93IGlmIG1kIGlzIGxlc3MgdGhhbiBvbmUgb3IgaXMgbm90IGFuIGludGVnZXIsIHVubGVzcyBpdCBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIW4uaXNJbnRlZ2VyKCkgJiYgKG4uYyB8fCBuLnMgIT09IDEpIHx8IG4ubHQoT05FKSkge1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50ICcgK1xyXG4gICAgICAgICAgICAgIChuLmlzSW50ZWdlcigpID8gJ291dCBvZiByYW5nZTogJyA6ICdub3QgYW4gaW50ZWdlcjogJykgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICgheGMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG5cclxuICAgICAgZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgbjEgPSBkMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgZDEgPSBuMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgcyA9IGNvZWZmVG9TdHJpbmcoeGMpO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGluaXRpYWwgZGVub21pbmF0b3IuXHJcbiAgICAgIC8vIGQgaXMgYSBwb3dlciBvZiAxMCBhbmQgdGhlIG1pbmltdW0gbWF4IGRlbm9taW5hdG9yIHRoYXQgc3BlY2lmaWVzIHRoZSB2YWx1ZSBleGFjdGx5LlxyXG4gICAgICBlID0gZC5lID0gcy5sZW5ndGggLSB4LmUgLSAxO1xyXG4gICAgICBkLmNbMF0gPSBQT1dTX1RFTlsoZXhwID0gZSAlIExPR19CQVNFKSA8IDAgPyBMT0dfQkFTRSArIGV4cCA6IGV4cF07XHJcbiAgICAgIG1kID0gIW1kIHx8IG4uY29tcGFyZWRUbyhkKSA+IDAgPyAoZSA+IDAgPyBkIDogbjEpIDogbjtcclxuXHJcbiAgICAgIGV4cCA9IE1BWF9FWFA7XHJcbiAgICAgIE1BWF9FWFAgPSAxIC8gMDtcclxuICAgICAgbiA9IG5ldyBCaWdOdW1iZXIocyk7XHJcblxyXG4gICAgICAvLyBuMCA9IGQxID0gMFxyXG4gICAgICBuMC5jWzBdID0gMDtcclxuXHJcbiAgICAgIGZvciAoOyA7KSAge1xyXG4gICAgICAgIHEgPSBkaXYobiwgZCwgMCwgMSk7XHJcbiAgICAgICAgZDIgPSBkMC5wbHVzKHEudGltZXMoZDEpKTtcclxuICAgICAgICBpZiAoZDIuY29tcGFyZWRUbyhtZCkgPT0gMSkgYnJlYWs7XHJcbiAgICAgICAgZDAgPSBkMTtcclxuICAgICAgICBkMSA9IGQyO1xyXG4gICAgICAgIG4xID0gbjAucGx1cyhxLnRpbWVzKGQyID0gbjEpKTtcclxuICAgICAgICBuMCA9IGQyO1xyXG4gICAgICAgIGQgPSBuLm1pbnVzKHEudGltZXMoZDIgPSBkKSk7XHJcbiAgICAgICAgbiA9IGQyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkMiA9IGRpdihtZC5taW51cyhkMCksIGQxLCAwLCAxKTtcclxuICAgICAgbjAgPSBuMC5wbHVzKGQyLnRpbWVzKG4xKSk7XHJcbiAgICAgIGQwID0gZDAucGx1cyhkMi50aW1lcyhkMSkpO1xyXG4gICAgICBuMC5zID0gbjEucyA9IHgucztcclxuICAgICAgZSA9IGUgKiAyO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGZyYWN0aW9uIGlzIGNsb3NlciB0byB4LCBuMC9kMCBvciBuMS9kMVxyXG4gICAgICByID0gZGl2KG4xLCBkMSwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkuY29tcGFyZWRUbyhcclxuICAgICAgICAgIGRpdihuMCwgZDAsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpKSA8IDEgPyBbbjEsIGQxXSA6IFtuMCwgZDBdO1xyXG5cclxuICAgICAgTUFYX0VYUCA9IGV4cDtcclxuXHJcbiAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgY29udmVydGVkIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cclxuICAgICAqL1xyXG4gICAgUC50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICt2YWx1ZU9mKHRoaXMpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtIG9yIFJPVU5ESU5HX01PREUuIElmIHNkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0c1xyXG4gICAgICogbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlciBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiwgdGhlbiB1c2VcclxuICAgICAqIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICAgIGlmIChzZCAhPSBudWxsKSBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBzZCwgcm0sIDIpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGJhc2UgYiwgb3IgYmFzZSAxMCBpZiBiIGlzXHJcbiAgICAgKiBvbWl0dGVkLiBJZiBhIGJhc2UgaXMgc3BlY2lmaWVkLCBpbmNsdWRpbmcgYmFzZSAxMCwgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZFxyXG4gICAgICogUk9VTkRJTkdfTU9ERS4gSWYgYSBiYXNlIGlzIG5vdCBzcGVjaWZpZWQsIGFuZCB0aGlzIEJpZ051bWJlciBoYXMgYSBwb3NpdGl2ZSBleHBvbmVudFxyXG4gICAgICogdGhhdCBpcyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gVE9fRVhQX1BPUywgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW5cclxuICAgICAqIFRPX0VYUF9ORUcsIHJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBbYl0ge251bWJlcn0gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAqL1xyXG4gICAgUC50b1N0cmluZyA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgbiA9IHRoaXMsXHJcbiAgICAgICAgcyA9IG4ucyxcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgLy8gSW5maW5pdHkgb3IgTmFOP1xyXG4gICAgICBpZiAoZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgICBzdHIgPSAnSW5maW5pdHknO1xyXG4gICAgICAgICAgaWYgKHMgPCAwKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHN0ciA9ICdOYU4nO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcblxyXG4gICAgICAgIGlmIChiID09IG51bGwpIHtcclxuICAgICAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBlKVxyXG4gICAgICAgICAgIDogdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG4gICAgICAgICAgc3RyID0gY29udmVydEJhc2UodG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKSwgMTAsIGIsIHMsIHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHMgPCAwICYmIG4uY1swXSkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc3RyO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhcyB0b1N0cmluZywgYnV0IGRvIG5vdCBhY2NlcHQgYSBiYXNlIGFyZ3VtZW50LCBhbmQgaW5jbHVkZSB0aGUgbWludXMgc2lnbiBmb3JcclxuICAgICAqIG5lZ2F0aXZlIHplcm8uXHJcbiAgICAgKi9cclxuICAgIFAudmFsdWVPZiA9IFAudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdmFsdWVPZih0aGlzKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIFAuX2lzQmlnTnVtYmVyID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcpIHtcclxuICAgICAgUFtTeW1ib2wudG9TdHJpbmdUYWddID0gJ0JpZ051bWJlcic7XHJcbiAgICAgIC8vIE5vZGUuanMgdjEwLjEyLjArXHJcbiAgICAgIFBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gPSBQLnZhbHVlT2Y7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbmZpZ09iamVjdCAhPSBudWxsKSBCaWdOdW1iZXIuc2V0KGNvbmZpZ09iamVjdCk7XHJcblxyXG4gICAgcmV0dXJuIEJpZ051bWJlcjtcclxuICB9XHJcblxyXG5cclxuICAvLyBQUklWQVRFIEhFTFBFUiBGVU5DVElPTlNcclxuXHJcblxyXG4gIGZ1bmN0aW9uIGJpdEZsb29yKG4pIHtcclxuICAgIHZhciBpID0gbiB8IDA7XHJcbiAgICByZXR1cm4gbiA+IDAgfHwgbiA9PT0gaSA/IGkgOiBpIC0gMTtcclxuICB9XHJcblxyXG5cclxuICAvLyBSZXR1cm4gYSBjb2VmZmljaWVudCBhcnJheSBhcyBhIHN0cmluZyBvZiBiYXNlIDEwIGRpZ2l0cy5cclxuICBmdW5jdGlvbiBjb2VmZlRvU3RyaW5nKGEpIHtcclxuICAgIHZhciBzLCB6LFxyXG4gICAgICBpID0gMSxcclxuICAgICAgaiA9IGEubGVuZ3RoLFxyXG4gICAgICByID0gYVswXSArICcnO1xyXG5cclxuICAgIGZvciAoOyBpIDwgajspIHtcclxuICAgICAgcyA9IGFbaSsrXSArICcnO1xyXG4gICAgICB6ID0gTE9HX0JBU0UgLSBzLmxlbmd0aDtcclxuICAgICAgZm9yICg7IHotLTsgcyA9ICcwJyArIHMpO1xyXG4gICAgICByICs9IHM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yIChqID0gci5sZW5ndGg7IHIuY2hhckNvZGVBdCgtLWopID09PSA0ODspO1xyXG5cclxuICAgIHJldHVybiByLnNsaWNlKDAsIGogKyAxIHx8IDEpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIENvbXBhcmUgdGhlIHZhbHVlIG9mIEJpZ051bWJlcnMgeCBhbmQgeS5cclxuICBmdW5jdGlvbiBjb21wYXJlKHgsIHkpIHtcclxuICAgIHZhciBhLCBiLFxyXG4gICAgICB4YyA9IHguYyxcclxuICAgICAgeWMgPSB5LmMsXHJcbiAgICAgIGkgPSB4LnMsXHJcbiAgICAgIGogPSB5LnMsXHJcbiAgICAgIGsgPSB4LmUsXHJcbiAgICAgIGwgPSB5LmU7XHJcblxyXG4gICAgLy8gRWl0aGVyIE5hTj9cclxuICAgIGlmICghaSB8fCAhaikgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgYSA9IHhjICYmICF4Y1swXTtcclxuICAgIGIgPSB5YyAmJiAheWNbMF07XHJcblxyXG4gICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICBpZiAoYSB8fCBiKSByZXR1cm4gYSA/IGIgPyAwIDogLWogOiBpO1xyXG5cclxuICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgIGlmIChpICE9IGopIHJldHVybiBpO1xyXG5cclxuICAgIGEgPSBpIDwgMDtcclxuICAgIGIgPSBrID09IGw7XHJcblxyXG4gICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBiID8gMCA6ICF4YyBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBleHBvbmVudHMuXHJcbiAgICBpZiAoIWIpIHJldHVybiBrID4gbCBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgaiA9IChrID0geGMubGVuZ3RoKSA8IChsID0geWMubGVuZ3RoKSA/IGsgOiBsO1xyXG5cclxuICAgIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgajsgaSsrKSBpZiAoeGNbaV0gIT0geWNbaV0pIHJldHVybiB4Y1tpXSA+IHljW2ldIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICAvLyBDb21wYXJlIGxlbmd0aHMuXHJcbiAgICByZXR1cm4gayA9PSBsID8gMCA6IGsgPiBsIF4gYSA/IDEgOiAtMTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIENoZWNrIHRoYXQgbiBpcyBhIHByaW1pdGl2ZSBudW1iZXIsIGFuIGludGVnZXIsIGFuZCBpbiByYW5nZSwgb3RoZXJ3aXNlIHRocm93LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGludENoZWNrKG4sIG1pbiwgbWF4LCBuYW1lKSB7XHJcbiAgICBpZiAobiA8IG1pbiB8fCBuID4gbWF4IHx8IG4gIT09IChuIDwgMCA/IG1hdGhjZWlsKG4pIDogbWF0aGZsb29yKG4pKSkge1xyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgKGJpZ251bWJlckVycm9yICsgKG5hbWUgfHwgJ0FyZ3VtZW50JykgKyAodHlwZW9mIG4gPT0gJ251bWJlcidcclxuICAgICAgICAgPyBuIDwgbWluIHx8IG4gPiBtYXggPyAnIG91dCBvZiByYW5nZTogJyA6ICcgbm90IGFuIGludGVnZXI6ICdcclxuICAgICAgICAgOiAnIG5vdCBhIHByaW1pdGl2ZSBudW1iZXI6ICcpICsgU3RyaW5nKG4pKTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvLyBBc3N1bWVzIGZpbml0ZSBuLlxyXG4gIGZ1bmN0aW9uIGlzT2RkKG4pIHtcclxuICAgIHZhciBrID0gbi5jLmxlbmd0aCAtIDE7XHJcbiAgICByZXR1cm4gYml0Rmxvb3Iobi5lIC8gTE9HX0JBU0UpID09IGsgJiYgbi5jW2tdICUgMiAhPSAwO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHRvRXhwb25lbnRpYWwoc3RyLCBlKSB7XHJcbiAgICByZXR1cm4gKHN0ci5sZW5ndGggPiAxID8gc3RyLmNoYXJBdCgwKSArICcuJyArIHN0ci5zbGljZSgxKSA6IHN0cikgK1xyXG4gICAgIChlIDwgMCA/ICdlJyA6ICdlKycpICsgZTtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCB6KSB7XHJcbiAgICB2YXIgbGVuLCB6cztcclxuXHJcbiAgICAvLyBOZWdhdGl2ZSBleHBvbmVudD9cclxuICAgIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcy5cclxuICAgICAgZm9yICh6cyA9IHogKyAnLic7ICsrZTsgenMgKz0geik7XHJcbiAgICAgIHN0ciA9IHpzICsgc3RyO1xyXG5cclxuICAgIC8vIFBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gQXBwZW5kIHplcm9zLlxyXG4gICAgICBpZiAoKytlID4gbGVuKSB7XHJcbiAgICAgICAgZm9yICh6cyA9IHosIGUgLT0gbGVuOyAtLWU7IHpzICs9IHopO1xyXG4gICAgICAgIHN0ciArPSB6cztcclxuICAgICAgfSBlbHNlIGlmIChlIDwgbGVuKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIGUpICsgJy4nICsgc3RyLnNsaWNlKGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0cjtcclxuICB9XHJcblxyXG5cclxuICAvLyBFWFBPUlRcclxuXHJcblxyXG4gIEJpZ051bWJlciA9IGNsb25lKCk7XHJcbiAgQmlnTnVtYmVyWydkZWZhdWx0J10gPSBCaWdOdW1iZXIuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xyXG5cclxuICAvLyBBTUQuXHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gQmlnTnVtYmVyOyB9KTtcclxuXHJcbiAgLy8gTm9kZS5qcyBhbmQgb3RoZXIgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cy5cclxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gQmlnTnVtYmVyO1xyXG5cclxuICAvLyBCcm93c2VyLlxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoIWdsb2JhbE9iamVjdCkge1xyXG4gICAgICBnbG9iYWxPYmplY3QgPSB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmID8gc2VsZiA6IHdpbmRvdztcclxuICAgIH1cclxuXHJcbiAgICBnbG9iYWxPYmplY3QuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xyXG4gIH1cclxufSkodGhpcyk7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQSxXQVVBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bignumber.js/bignumber.js\n");

/***/ }),

/***/ "./node_modules/for-each/index.js":
/*!****************************************!*\
  !*** ./node_modules/for-each/index.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isCallable = __webpack_require__(/*! is-callable */ \"./node_modules/is-callable/index.js\");\n\nvar toStr = Object.prototype.toString;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar forEachArray = function forEachArray(array, iterator, receiver) {\n    for (var i = 0, len = array.length; i < len; i++) {\n        if (hasOwnProperty.call(array, i)) {\n            if (receiver == null) {\n                iterator(array[i], i, array);\n            } else {\n                iterator.call(receiver, array[i], i, array);\n            }\n        }\n    }\n};\n\nvar forEachString = function forEachString(string, iterator, receiver) {\n    for (var i = 0, len = string.length; i < len; i++) {\n        // no such thing as a sparse string.\n        if (receiver == null) {\n            iterator(string.charAt(i), i, string);\n        } else {\n            iterator.call(receiver, string.charAt(i), i, string);\n        }\n    }\n};\n\nvar forEachObject = function forEachObject(object, iterator, receiver) {\n    for (var k in object) {\n        if (hasOwnProperty.call(object, k)) {\n            if (receiver == null) {\n                iterator(object[k], k, object);\n            } else {\n                iterator.call(receiver, object[k], k, object);\n            }\n        }\n    }\n};\n\nvar forEach = function forEach(list, iterator, thisArg) {\n    if (!isCallable(iterator)) {\n        throw new TypeError('iterator must be a function');\n    }\n\n    var receiver;\n    if (arguments.length >= 3) {\n        receiver = thisArg;\n    }\n\n    if (toStr.call(list) === '[object Array]') {\n        forEachArray(list, iterator, receiver);\n    } else if (typeof list === 'string') {\n        forEachString(list, iterator, receiver);\n    } else {\n        forEachObject(list, iterator, receiver);\n    }\n};\n\nmodule.exports = forEach;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZm9yLWVhY2gvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZm9yLWVhY2gvaW5kZXguanM/ZDAyNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnaXMtY2FsbGFibGUnKTtcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmb3JFYWNoQXJyYXkgPSBmdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaSkpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IoYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoU3RyaW5nID0gZnVuY3Rpb24gZm9yRWFjaFN0cmluZyhzdHJpbmcsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXG4gICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihzdHJpbmcuY2hhckF0KGkpLCBpLCBzdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoT2JqZWN0ID0gZnVuY3Rpb24gZm9yRWFjaE9iamVjdChvYmplY3QsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGsgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgaykpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iob2JqZWN0W2tdLCBrLCBvYmplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKHJlY2VpdmVyLCBvYmplY3Rba10sIGssIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2gobGlzdCwgaXRlcmF0b3IsIHRoaXNBcmcpIHtcbiAgICBpZiAoIWlzQ2FsbGFibGUoaXRlcmF0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHZhciByZWNlaXZlcjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIHJlY2VpdmVyID0gdGhpc0FyZztcbiAgICB9XG5cbiAgICBpZiAodG9TdHIuY2FsbChsaXN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICBmb3JFYWNoQXJyYXkobGlzdCwgaXRlcmF0b3IsIHJlY2VpdmVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBmb3JFYWNoU3RyaW5nKGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yRWFjaE9iamVjdChsaXN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/for-each/index.js\n");

/***/ }),

/***/ "./node_modules/global/window.js":
/*!***************************************!*\
  !*** ./node_modules/global/window.js ***!
  \***************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2xvYmFsL3dpbmRvdy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbG9iYWwvd2luZG93LmpzP2JlMDkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHdpbjtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW4gPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW4gPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICB3aW4gPSBzZWxmO1xufSBlbHNlIHtcbiAgICB3aW4gPSB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3aW47XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/global/window.js\n");

/***/ }),

/***/ "./node_modules/html5-fs/src/api.js":
/*!******************************************!*\
  !*** ./node_modules/html5-fs/src/api.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/html5-fs/src/utils.js\")\n  , pathm = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\")\n  , fs = __webpack_require__(/*! ./fileSystem */ \"./node_modules/html5-fs/src/fileSystem.js\");\n\nvar wrapSuccess = utils.wrapSuccess\n  , wrapFail = utils.wrapFail;\n\nexports.getFsInstance = fs.getInstance;\n\nexports.appendFile = function(path, data, callback) {\n  fs.writeFile(path, data, callback, true);\n};\n\n\nexports.writeFile = function(path, data, callback) {\n  fs.writeFile(path, data, callback, false);\n};\n\n\nexports.readFile = function(path, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {\n      encoding: 'utf8'\n    };\n  }\n\n  var success = wrapSuccess(callback)\n    , fail = wrapFail(callback);\n\n  fs.getFile(path, function(err, fileEntry) {\n    fileEntry.file(function(file) {\n      var reader = new FileReader();\n\n      reader.onloadend = function(evt) {\n        success(evt.target.result);\n      };\n\n      reader.onerror = function(err) {\n        fail(err);\n      };\n\n      if (opts.encoding === 'utf8') {\n        reader.readAsText(file);\n      } else {\n        reader.readAsDataURL(file);\n      }\n    }, fail);\n  });\n};\n\n\nexports.unlink = function(path, callback) {\n  var success = wrapSuccess(callback)\n    , fail = wrapFail(callback);\n\n  fs.getFile(path, function(err, file) {\n    if (err) {\n      fail(err);\n    } else {\n      file.remove(success, fail);\n    }\n  });\n};\n\n\nexports.readdir = function(path, callback) {\n  var success = wrapSuccess(callback)\n    , fail = wrapFail(callback);\n\n  fs.getDirectory(path, function(err, dirEntry) {\n    if (err) {\n      fail(err);\n    } else {\n      var directoryReader = dirEntry.createReader();\n      directoryReader.readEntries(success, fail);\n    }\n  });\n};\n\n\nexports.mkdir = function(path, callback) {\n  var newFolderName = pathm.basename(path)\n    , basePath = pathm.dirname(path)\n    , success = utils.wrapSuccess(callback)\n    , fail = utils.wrapFail(callback)\n    , opts = {\n      create: true,\n      exclusive: true\n    };\n\n  if (basePath === '.') {\n    fs.getDirectory(newFolderName, opts, callback);\n  } else {\n    fs.getDirectory(basePath, function (err, dir) {\n      if (err) {\n        callback(err, null);\n      } else {\n        dir.getDirectory(newFolderName, opts, success, fail);\n      }\n    });\n  }\n};\n\n\n/**\n * Remove a directory.\n * The FileSystem API expects directories to be empty but returns a\n * non-informative error on Android and possibly iOS so we check here\n * to ensure users know why directory deletes might fail.\n * @param  {String}   path\n * @param  {Function} callback\n */\nexports.rmdir = function(path, callback) {\n  var success = wrapSuccess(callback)\n    , fail = wrapFail(callback);\n\n  this.readdir(path, function(err, list) {\n    if (err) {\n      fail(err);\n    } else if (list && list.length > 0) {\n      fail('ENOTEMPTY: Directory must be empty');\n    } else {\n      fs.getDirectory(path, function(err, dirEntry) {\n        if (err) {\n          fail(err);\n        } else {\n          dirEntry.remove(success, fail);\n        }\n      });\n    }\n  });\n};\n\n\nexports.exists = function(path, callback) {\n  var fail = wrapFail(callback);\n\n  fs.getFile(path, {\n    // Don't create the file, just look for it\n    create: false\n  }, function(err) {\n    // See https://www.chromestatus.com/features/6687420359639040.\n    if (err &&\n      ((window.FileError && err.code === 1) ||\n      (err.name === 'NotFoundError'))) { // NOT FOUND\n      // If the file isn't found we don't want an error, pass false!\n      callback(false);\n    } else if (err) {\n      // An actual error occured, pass it along\n      fail(err);\n    } else {\n      callback(true);\n    }\n  });\n};\n\n\nexports.stat = function(path, callback) {\n  var success = wrapSuccess(callback)\n    , fail = wrapFail(callback)\n    , fn = fs.getFile;\n\n  // TODO: Perhaps check for folder AND file instead, use whichever exists\n  if (utils.isDirectory(path)) {\n    fn = fs.getDirectory;\n  }\n\n  fn(path, function(err, res) {\n    if (err) {\n      fail(err);\n    } else {\n      res.getMetadata(success, fail);\n    }\n  });\n};\n\n\n/**\n * Initialise the file system component for use.\n * @param {Number}     [quota]\n * @param {Function}   callback\n */\nexports.init = function(bytes, callback) {\n  fs.init(bytes, function(err) {\n    if (err) {\n      callback(err, null);\n    } else {\n      fs.getInstance(function(err /*, instance */) {\n        callback(err, null);\n      });\n    }\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtZnMvc3JjL2FwaS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sNS1mcy9zcmMvYXBpLmpzPzhjNGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJylcbiAgLCBwYXRobSA9IHJlcXVpcmUoJ3BhdGgnKVxuICAsIGZzID0gcmVxdWlyZSgnLi9maWxlU3lzdGVtJyk7XG5cbnZhciB3cmFwU3VjY2VzcyA9IHV0aWxzLndyYXBTdWNjZXNzXG4gICwgd3JhcEZhaWwgPSB1dGlscy53cmFwRmFpbDtcblxuZXhwb3J0cy5nZXRGc0luc3RhbmNlID0gZnMuZ2V0SW5zdGFuY2U7XG5cbmV4cG9ydHMuYXBwZW5kRmlsZSA9IGZ1bmN0aW9uKHBhdGgsIGRhdGEsIGNhbGxiYWNrKSB7XG4gIGZzLndyaXRlRmlsZShwYXRoLCBkYXRhLCBjYWxsYmFjaywgdHJ1ZSk7XG59O1xuXG5cbmV4cG9ydHMud3JpdGVGaWxlID0gZnVuY3Rpb24ocGF0aCwgZGF0YSwgY2FsbGJhY2spIHtcbiAgZnMud3JpdGVGaWxlKHBhdGgsIGRhdGEsIGNhbGxiYWNrLCBmYWxzZSk7XG59O1xuXG5cbmV4cG9ydHMucmVhZEZpbGUgPSBmdW5jdGlvbihwYXRoLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHtcbiAgICAgIGVuY29kaW5nOiAndXRmOCdcbiAgICB9O1xuICB9XG5cbiAgdmFyIHN1Y2Nlc3MgPSB3cmFwU3VjY2VzcyhjYWxsYmFjaylcbiAgICAsIGZhaWwgPSB3cmFwRmFpbChjYWxsYmFjayk7XG5cbiAgZnMuZ2V0RmlsZShwYXRoLCBmdW5jdGlvbihlcnIsIGZpbGVFbnRyeSkge1xuICAgIGZpbGVFbnRyeS5maWxlKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHN1Y2Nlc3MoZXZ0LnRhcmdldC5yZXN1bHQpO1xuICAgICAgfTtcblxuICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgZmFpbChlcnIpO1xuICAgICAgfTtcblxuICAgICAgaWYgKG9wdHMuZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgICAgfVxuICAgIH0sIGZhaWwpO1xuICB9KTtcbn07XG5cblxuZXhwb3J0cy51bmxpbmsgPSBmdW5jdGlvbihwYXRoLCBjYWxsYmFjaykge1xuICB2YXIgc3VjY2VzcyA9IHdyYXBTdWNjZXNzKGNhbGxiYWNrKVxuICAgICwgZmFpbCA9IHdyYXBGYWlsKGNhbGxiYWNrKTtcblxuICBmcy5nZXRGaWxlKHBhdGgsIGZ1bmN0aW9uKGVyciwgZmlsZSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGZhaWwoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlsZS5yZW1vdmUoc3VjY2VzcywgZmFpbCk7XG4gICAgfVxuICB9KTtcbn07XG5cblxuZXhwb3J0cy5yZWFkZGlyID0gZnVuY3Rpb24ocGF0aCwgY2FsbGJhY2spIHtcbiAgdmFyIHN1Y2Nlc3MgPSB3cmFwU3VjY2VzcyhjYWxsYmFjaylcbiAgICAsIGZhaWwgPSB3cmFwRmFpbChjYWxsYmFjayk7XG5cbiAgZnMuZ2V0RGlyZWN0b3J5KHBhdGgsIGZ1bmN0aW9uKGVyciwgZGlyRW50cnkpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBmYWlsKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaXJlY3RvcnlSZWFkZXIgPSBkaXJFbnRyeS5jcmVhdGVSZWFkZXIoKTtcbiAgICAgIGRpcmVjdG9yeVJlYWRlci5yZWFkRW50cmllcyhzdWNjZXNzLCBmYWlsKTtcbiAgICB9XG4gIH0pO1xufTtcblxuXG5leHBvcnRzLm1rZGlyID0gZnVuY3Rpb24ocGF0aCwgY2FsbGJhY2spIHtcbiAgdmFyIG5ld0ZvbGRlck5hbWUgPSBwYXRobS5iYXNlbmFtZShwYXRoKVxuICAgICwgYmFzZVBhdGggPSBwYXRobS5kaXJuYW1lKHBhdGgpXG4gICAgLCBzdWNjZXNzID0gdXRpbHMud3JhcFN1Y2Nlc3MoY2FsbGJhY2spXG4gICAgLCBmYWlsID0gdXRpbHMud3JhcEZhaWwoY2FsbGJhY2spXG4gICAgLCBvcHRzID0ge1xuICAgICAgY3JlYXRlOiB0cnVlLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlXG4gICAgfTtcblxuICBpZiAoYmFzZVBhdGggPT09ICcuJykge1xuICAgIGZzLmdldERpcmVjdG9yeShuZXdGb2xkZXJOYW1lLCBvcHRzLCBjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgZnMuZ2V0RGlyZWN0b3J5KGJhc2VQYXRoLCBmdW5jdGlvbiAoZXJyLCBkaXIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpci5nZXREaXJlY3RvcnkobmV3Rm9sZGVyTmFtZSwgb3B0cywgc3VjY2VzcywgZmFpbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZW1vdmUgYSBkaXJlY3RvcnkuXG4gKiBUaGUgRmlsZVN5c3RlbSBBUEkgZXhwZWN0cyBkaXJlY3RvcmllcyB0byBiZSBlbXB0eSBidXQgcmV0dXJucyBhXG4gKiBub24taW5mb3JtYXRpdmUgZXJyb3Igb24gQW5kcm9pZCBhbmQgcG9zc2libHkgaU9TIHNvIHdlIGNoZWNrIGhlcmVcbiAqIHRvIGVuc3VyZSB1c2VycyBrbm93IHdoeSBkaXJlY3RvcnkgZGVsZXRlcyBtaWdodCBmYWlsLlxuICogQHBhcmFtICB7U3RyaW5nfSAgIHBhdGhcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5leHBvcnRzLnJtZGlyID0gZnVuY3Rpb24ocGF0aCwgY2FsbGJhY2spIHtcbiAgdmFyIHN1Y2Nlc3MgPSB3cmFwU3VjY2VzcyhjYWxsYmFjaylcbiAgICAsIGZhaWwgPSB3cmFwRmFpbChjYWxsYmFjayk7XG5cbiAgdGhpcy5yZWFkZGlyKHBhdGgsIGZ1bmN0aW9uKGVyciwgbGlzdCkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGZhaWwoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGxpc3QgJiYgbGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICBmYWlsKCdFTk9URU1QVFk6IERpcmVjdG9yeSBtdXN0IGJlIGVtcHR5Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZzLmdldERpcmVjdG9yeShwYXRoLCBmdW5jdGlvbihlcnIsIGRpckVudHJ5KSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBmYWlsKGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlyRW50cnkucmVtb3ZlKHN1Y2Nlc3MsIGZhaWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxuXG5leHBvcnRzLmV4aXN0cyA9IGZ1bmN0aW9uKHBhdGgsIGNhbGxiYWNrKSB7XG4gIHZhciBmYWlsID0gd3JhcEZhaWwoY2FsbGJhY2spO1xuXG4gIGZzLmdldEZpbGUocGF0aCwge1xuICAgIC8vIERvbid0IGNyZWF0ZSB0aGUgZmlsZSwganVzdCBsb29rIGZvciBpdFxuICAgIGNyZWF0ZTogZmFsc2VcbiAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgLy8gU2VlIGh0dHBzOi8vd3d3LmNocm9tZXN0YXR1cy5jb20vZmVhdHVyZXMvNjY4NzQyMDM1OTYzOTA0MC5cbiAgICBpZiAoZXJyICYmXG4gICAgICAoKHdpbmRvdy5GaWxlRXJyb3IgJiYgZXJyLmNvZGUgPT09IDEpIHx8XG4gICAgICAoZXJyLm5hbWUgPT09ICdOb3RGb3VuZEVycm9yJykpKSB7IC8vIE5PVCBGT1VORFxuICAgICAgLy8gSWYgdGhlIGZpbGUgaXNuJ3QgZm91bmQgd2UgZG9uJ3Qgd2FudCBhbiBlcnJvciwgcGFzcyBmYWxzZSFcbiAgICAgIGNhbGxiYWNrKGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgLy8gQW4gYWN0dWFsIGVycm9yIG9jY3VyZWQsIHBhc3MgaXQgYWxvbmdcbiAgICAgIGZhaWwoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgfVxuICB9KTtcbn07XG5cblxuZXhwb3J0cy5zdGF0ID0gZnVuY3Rpb24ocGF0aCwgY2FsbGJhY2spIHtcbiAgdmFyIHN1Y2Nlc3MgPSB3cmFwU3VjY2VzcyhjYWxsYmFjaylcbiAgICAsIGZhaWwgPSB3cmFwRmFpbChjYWxsYmFjaylcbiAgICAsIGZuID0gZnMuZ2V0RmlsZTtcblxuICAvLyBUT0RPOiBQZXJoYXBzIGNoZWNrIGZvciBmb2xkZXIgQU5EIGZpbGUgaW5zdGVhZCwgdXNlIHdoaWNoZXZlciBleGlzdHNcbiAgaWYgKHV0aWxzLmlzRGlyZWN0b3J5KHBhdGgpKSB7XG4gICAgZm4gPSBmcy5nZXREaXJlY3Rvcnk7XG4gIH1cblxuICBmbihwYXRoLCBmdW5jdGlvbihlcnIsIHJlcykge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGZhaWwoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzLmdldE1ldGFkYXRhKHN1Y2Nlc3MsIGZhaWwpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5cbi8qKlxuICogSW5pdGlhbGlzZSB0aGUgZmlsZSBzeXN0ZW0gY29tcG9uZW50IGZvciB1c2UuXG4gKiBAcGFyYW0ge051bWJlcn0gICAgIFtxdW90YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259ICAgY2FsbGJhY2tcbiAqL1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oYnl0ZXMsIGNhbGxiYWNrKSB7XG4gIGZzLmluaXQoYnl0ZXMsIGZ1bmN0aW9uKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZzLmdldEluc3RhbmNlKGZ1bmN0aW9uKGVyciAvKiwgaW5zdGFuY2UgKi8pIHtcbiAgICAgICAgY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/html5-fs/src/api.js\n");

/***/ }),

/***/ "./node_modules/html5-fs/src/fileSystem.js":
/*!*************************************************!*\
  !*** ./node_modules/html5-fs/src/fileSystem.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/html5-fs/src/utils.js\")\n  , pathm = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n\nvar DEFAULT_QUOTA = (10 * 1024 * 1024); // 10MB\n\nvar fileSystem = null;\n\n/**\n * Get a FileSystem instance.\n * @param {Function} callback\n */\nexports.getInstance = function(callback) {\n  if (fileSystem) {\n    callback(null, fileSystem);\n  } else {\n    init(null, callback);\n  }\n};\n\n\n/**\n * Initialises access to browser File System\n * @param {Number}      bytes\n * @param {Function}    callback\n */\nvar init = exports.init = function(bytes, callback) {\n  requestQuota(bytes, function(err, grantedBytes) {\n    if (err) {\n      return callback(err, null);\n    } else {\n      requestFileSystem(grantedBytes, function(instance) {\n        fileSystem = instance;\n        callback(null, grantedBytes);\n      }, function(err) {\n        callback(err, null);\n      });\n    }\n  });\n};\n\n\n/**\n * Write data to a file optionally appending it.\n * @param {String}      path\n * @param {Mixed}       data\n * @param {Function}    callback\n * @param {Boolean}     append\n */\nexports.writeFile = function(path, data, callback, append) {\n  var fail = utils.wrapFail(callback)\n    , success = utils.wrapSuccess(callback);\n\n  this.getFile(path, {\n    create: true,\n    exclusive: false\n  }, function(err, file) {\n    if (err) {\n      return callback(err, null);\n    } else {\n      file.createWriter(function(writer) {\n        writer.onwrite = function(/*evt*/) {\n          success(file.toURL());\n        };\n\n        writer.onerror = function(evt) {\n          fail(evt.target.error);\n        };\n\n        if (append === true) {\n          writer.seek(writer.length);\n        }\n\n        if (utils.isMobile()) {\n          writer.write(data);\n        } else {\n          writer.write(new Blob([data]));\n        }\n      }, fail);\n    }\n  });\n};\n\n\n/**\n * Get a directory specified by path.\n * By default if the dir does not exist it is not created.\n * @param {String}      path\n * @param {Object}      [opts]\n * @param {Function}    callback\n */\nexports.getDirectory = function(path, opts, callback) {\n  if (!callback) {\n    callback = opts;\n    opts = {\n      create: false\n    };\n  }\n\n  var success = utils.wrapSuccess(callback)\n    , fail = utils.wrapFail(callback);\n\n  fileSystem.root.getDirectory(path, opts, success, fail);\n};\n\n\n/**\n * Get a file at a specified path.\n * By default if the file does not exist it is not created.\n * @param {String}      path\n * @param {Object}      [opts]\n * @param {Function}    callback\n */\nexports.getFile = function(path, opts, callback) {\n  if (!callback) {\n    callback = opts;\n    opts = {\n      create: false\n    };\n  }\n\n  var fileName = pathm.basename(path)\n    , basePath = pathm.dirname(path)\n    , success = utils.wrapSuccess(callback)\n    , fail = utils.wrapFail(callback);\n\n  function doGet (dirRef) {\n    dirRef.getFile(fileName, opts, success, fail);\n  }\n\n  if (basePath === '.') {\n    // File is in root directory\n    doGet(fileSystem.root);\n  } else {\n    // Need to get container directory ref for the requested file\n    this.getDirectory(basePath, opts, function (err, dir) {\n      if (err) {\n        callback(err, null);\n      } else {\n        doGet(dir);\n      }\n    });\n  }\n};\n\n\n/**\n * Request access to the file system.\n * This is called only after quota is granted.\n * @param {Number}       bytes\n * @param {Function}     success\n * @param {Function}     fail\n */\nfunction requestFileSystem(bytes, success, fail) {\n  // These are in order of preference due to some being deprecated\n  if (window.navigator.webkitRequestFileSystem) {\n    window.navigator.webkitRequestFileSystem(bytes, success, fail);\n  } else if (window.requestFileSystem) {\n    window.requestFileSystem(\n      window.LocalFileSystem.PERSISTENT,\n      bytes,\n      success,\n      fail\n    );\n  } else if (window.webkitRequestFileSystem) {\n    window.webkitRequestFileSystem(\n      window.PERSISTENT,\n      bytes,\n      success,\n      fail\n    );\n  } else {\n    fail('NO_SUPPORT');\n  }\n}\n\n\n/**\n * Request a quota from the FileSystem.\n * @param {Number}     bytes\n * @param {Function}   callback\n */\nfunction requestQuota(quota, callback) {\n  // Allow user overide the default quota\n  quota = quota || DEFAULT_QUOTA;\n\n  function success(bytes) {\n    callback(null, bytes);\n  }\n\n  function fail(err) {\n    callback(err, null);\n  }\n\n  // These are in order of preference due to some being deprecated\n  if (navigator.webkitPersistentStorage &&\n      navigator.webkitPersistentStorage.requestQuota) {\n    navigator.webkitPersistentStorage.requestQuota(quota, success, fail);\n  } else if (window.webkitStorageInfo &&\n      window.webkitStorageInfo.requestQuota) {\n    window.webkitStorageInfo.requestQuota(\n      window.PERSISTENT,\n      quota,\n      success,\n      fail\n    );\n  } else if (window.requestFileSystem) {\n    // PhoneGap apps should request a 0 quota\n    if (utils.isPhoneGap() === true) {\n      quota = 0;\n    }\n\n    success(quota);\n  } else {\n    fail('NO_SUPPORT');\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtZnMvc3JjL2ZpbGVTeXN0ZW0uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbDUtZnMvc3JjL2ZpbGVTeXN0ZW0uanM/MTZiNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuICAsIHBhdGhtID0gcmVxdWlyZSgncGF0aCcpO1xuXG52YXIgREVGQVVMVF9RVU9UQSA9ICgxMCAqIDEwMjQgKiAxMDI0KTsgLy8gMTBNQlxuXG52YXIgZmlsZVN5c3RlbSA9IG51bGw7XG5cbi8qKlxuICogR2V0IGEgRmlsZVN5c3RlbSBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbmV4cG9ydHMuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICBpZiAoZmlsZVN5c3RlbSkge1xuICAgIGNhbGxiYWNrKG51bGwsIGZpbGVTeXN0ZW0pO1xuICB9IGVsc2Uge1xuICAgIGluaXQobnVsbCwgY2FsbGJhY2spO1xuICB9XG59O1xuXG5cbi8qKlxuICogSW5pdGlhbGlzZXMgYWNjZXNzIHRvIGJyb3dzZXIgRmlsZSBTeXN0ZW1cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgIGJ5dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICBjYWxsYmFja1xuICovXG52YXIgaW5pdCA9IGV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKGJ5dGVzLCBjYWxsYmFjaykge1xuICByZXF1ZXN0UXVvdGEoYnl0ZXMsIGZ1bmN0aW9uKGVyciwgZ3JhbnRlZEJ5dGVzKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVlc3RGaWxlU3lzdGVtKGdyYW50ZWRCeXRlcywgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgICAgICAgZmlsZVN5c3RlbSA9IGluc3RhbmNlO1xuICAgICAgICBjYWxsYmFjayhudWxsLCBncmFudGVkQnl0ZXMpO1xuICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxuXG4vKipcbiAqIFdyaXRlIGRhdGEgdG8gYSBmaWxlIG9wdGlvbmFsbHkgYXBwZW5kaW5nIGl0LlxuICogQHBhcmFtIHtTdHJpbmd9ICAgICAgcGF0aFxuICogQHBhcmFtIHtNaXhlZH0gICAgICAgZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gICAgY2FsbGJhY2tcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgIGFwcGVuZFxuICovXG5leHBvcnRzLndyaXRlRmlsZSA9IGZ1bmN0aW9uKHBhdGgsIGRhdGEsIGNhbGxiYWNrLCBhcHBlbmQpIHtcbiAgdmFyIGZhaWwgPSB1dGlscy53cmFwRmFpbChjYWxsYmFjaylcbiAgICAsIHN1Y2Nlc3MgPSB1dGlscy53cmFwU3VjY2VzcyhjYWxsYmFjayk7XG5cbiAgdGhpcy5nZXRGaWxlKHBhdGgsIHtcbiAgICBjcmVhdGU6IHRydWUsXG4gICAgZXhjbHVzaXZlOiBmYWxzZVxuICB9LCBmdW5jdGlvbihlcnIsIGZpbGUpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlsZS5jcmVhdGVXcml0ZXIoZnVuY3Rpb24od3JpdGVyKSB7XG4gICAgICAgIHdyaXRlci5vbndyaXRlID0gZnVuY3Rpb24oLypldnQqLykge1xuICAgICAgICAgIHN1Y2Nlc3MoZmlsZS50b1VSTCgpKTtcbiAgICAgICAgfTtcblxuICAgICAgICB3cml0ZXIub25lcnJvciA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgIGZhaWwoZXZ0LnRhcmdldC5lcnJvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGFwcGVuZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHdyaXRlci5zZWVrKHdyaXRlci5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzTW9iaWxlKCkpIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUoZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKG5ldyBCbG9iKFtkYXRhXSkpO1xuICAgICAgICB9XG4gICAgICB9LCBmYWlsKTtcbiAgICB9XG4gIH0pO1xufTtcblxuXG4vKipcbiAqIEdldCBhIGRpcmVjdG9yeSBzcGVjaWZpZWQgYnkgcGF0aC5cbiAqIEJ5IGRlZmF1bHQgaWYgdGhlIGRpciBkb2VzIG5vdCBleGlzdCBpdCBpcyBub3QgY3JlYXRlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSAgICAgIHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgIFtvcHRzXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gICAgY2FsbGJhY2tcbiAqL1xuZXhwb3J0cy5nZXREaXJlY3RvcnkgPSBmdW5jdGlvbihwYXRoLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7XG4gICAgICBjcmVhdGU6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIHZhciBzdWNjZXNzID0gdXRpbHMud3JhcFN1Y2Nlc3MoY2FsbGJhY2spXG4gICAgLCBmYWlsID0gdXRpbHMud3JhcEZhaWwoY2FsbGJhY2spO1xuXG4gIGZpbGVTeXN0ZW0ucm9vdC5nZXREaXJlY3RvcnkocGF0aCwgb3B0cywgc3VjY2VzcywgZmFpbCk7XG59O1xuXG5cbi8qKlxuICogR2V0IGEgZmlsZSBhdCBhIHNwZWNpZmllZCBwYXRoLlxuICogQnkgZGVmYXVsdCBpZiB0aGUgZmlsZSBkb2VzIG5vdCBleGlzdCBpdCBpcyBub3QgY3JlYXRlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSAgICAgIHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgIFtvcHRzXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gICAgY2FsbGJhY2tcbiAqL1xuZXhwb3J0cy5nZXRGaWxlID0gZnVuY3Rpb24ocGF0aCwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge1xuICAgICAgY3JlYXRlOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICB2YXIgZmlsZU5hbWUgPSBwYXRobS5iYXNlbmFtZShwYXRoKVxuICAgICwgYmFzZVBhdGggPSBwYXRobS5kaXJuYW1lKHBhdGgpXG4gICAgLCBzdWNjZXNzID0gdXRpbHMud3JhcFN1Y2Nlc3MoY2FsbGJhY2spXG4gICAgLCBmYWlsID0gdXRpbHMud3JhcEZhaWwoY2FsbGJhY2spO1xuXG4gIGZ1bmN0aW9uIGRvR2V0IChkaXJSZWYpIHtcbiAgICBkaXJSZWYuZ2V0RmlsZShmaWxlTmFtZSwgb3B0cywgc3VjY2VzcywgZmFpbCk7XG4gIH1cblxuICBpZiAoYmFzZVBhdGggPT09ICcuJykge1xuICAgIC8vIEZpbGUgaXMgaW4gcm9vdCBkaXJlY3RvcnlcbiAgICBkb0dldChmaWxlU3lzdGVtLnJvb3QpO1xuICB9IGVsc2Uge1xuICAgIC8vIE5lZWQgdG8gZ2V0IGNvbnRhaW5lciBkaXJlY3RvcnkgcmVmIGZvciB0aGUgcmVxdWVzdGVkIGZpbGVcbiAgICB0aGlzLmdldERpcmVjdG9yeShiYXNlUGF0aCwgb3B0cywgZnVuY3Rpb24gKGVyciwgZGlyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb0dldChkaXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmVxdWVzdCBhY2Nlc3MgdG8gdGhlIGZpbGUgc3lzdGVtLlxuICogVGhpcyBpcyBjYWxsZWQgb25seSBhZnRlciBxdW90YSBpcyBncmFudGVkLlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgIGJ5dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICAgc3VjY2Vzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gICAgIGZhaWxcbiAqL1xuZnVuY3Rpb24gcmVxdWVzdEZpbGVTeXN0ZW0oYnl0ZXMsIHN1Y2Nlc3MsIGZhaWwpIHtcbiAgLy8gVGhlc2UgYXJlIGluIG9yZGVyIG9mIHByZWZlcmVuY2UgZHVlIHRvIHNvbWUgYmVpbmcgZGVwcmVjYXRlZFxuICBpZiAod2luZG93Lm5hdmlnYXRvci53ZWJraXRSZXF1ZXN0RmlsZVN5c3RlbSkge1xuICAgIHdpbmRvdy5uYXZpZ2F0b3Iud2Via2l0UmVxdWVzdEZpbGVTeXN0ZW0oYnl0ZXMsIHN1Y2Nlc3MsIGZhaWwpO1xuICB9IGVsc2UgaWYgKHdpbmRvdy5yZXF1ZXN0RmlsZVN5c3RlbSkge1xuICAgIHdpbmRvdy5yZXF1ZXN0RmlsZVN5c3RlbShcbiAgICAgIHdpbmRvdy5Mb2NhbEZpbGVTeXN0ZW0uUEVSU0lTVEVOVCxcbiAgICAgIGJ5dGVzLFxuICAgICAgc3VjY2VzcyxcbiAgICAgIGZhaWxcbiAgICApO1xuICB9IGVsc2UgaWYgKHdpbmRvdy53ZWJraXRSZXF1ZXN0RmlsZVN5c3RlbSkge1xuICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0RmlsZVN5c3RlbShcbiAgICAgIHdpbmRvdy5QRVJTSVNURU5ULFxuICAgICAgYnl0ZXMsXG4gICAgICBzdWNjZXNzLFxuICAgICAgZmFpbFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgZmFpbCgnTk9fU1VQUE9SVCcpO1xuICB9XG59XG5cblxuLyoqXG4gKiBSZXF1ZXN0IGEgcXVvdGEgZnJvbSB0aGUgRmlsZVN5c3RlbS5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgYnl0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259ICAgY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gcmVxdWVzdFF1b3RhKHF1b3RhLCBjYWxsYmFjaykge1xuICAvLyBBbGxvdyB1c2VyIG92ZXJpZGUgdGhlIGRlZmF1bHQgcXVvdGFcbiAgcXVvdGEgPSBxdW90YSB8fCBERUZBVUxUX1FVT1RBO1xuXG4gIGZ1bmN0aW9uIHN1Y2Nlc3MoYnl0ZXMpIHtcbiAgICBjYWxsYmFjayhudWxsLCBieXRlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBmYWlsKGVycikge1xuICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gIH1cblxuICAvLyBUaGVzZSBhcmUgaW4gb3JkZXIgb2YgcHJlZmVyZW5jZSBkdWUgdG8gc29tZSBiZWluZyBkZXByZWNhdGVkXG4gIGlmIChuYXZpZ2F0b3Iud2Via2l0UGVyc2lzdGVudFN0b3JhZ2UgJiZcbiAgICAgIG5hdmlnYXRvci53ZWJraXRQZXJzaXN0ZW50U3RvcmFnZS5yZXF1ZXN0UXVvdGEpIHtcbiAgICBuYXZpZ2F0b3Iud2Via2l0UGVyc2lzdGVudFN0b3JhZ2UucmVxdWVzdFF1b3RhKHF1b3RhLCBzdWNjZXNzLCBmYWlsKTtcbiAgfSBlbHNlIGlmICh3aW5kb3cud2Via2l0U3RvcmFnZUluZm8gJiZcbiAgICAgIHdpbmRvdy53ZWJraXRTdG9yYWdlSW5mby5yZXF1ZXN0UXVvdGEpIHtcbiAgICB3aW5kb3cud2Via2l0U3RvcmFnZUluZm8ucmVxdWVzdFF1b3RhKFxuICAgICAgd2luZG93LlBFUlNJU1RFTlQsXG4gICAgICBxdW90YSxcbiAgICAgIHN1Y2Nlc3MsXG4gICAgICBmYWlsXG4gICAgKTtcbiAgfSBlbHNlIGlmICh3aW5kb3cucmVxdWVzdEZpbGVTeXN0ZW0pIHtcbiAgICAvLyBQaG9uZUdhcCBhcHBzIHNob3VsZCByZXF1ZXN0IGEgMCBxdW90YVxuICAgIGlmICh1dGlscy5pc1Bob25lR2FwKCkgPT09IHRydWUpIHtcbiAgICAgIHF1b3RhID0gMDtcbiAgICB9XG5cbiAgICBzdWNjZXNzKHF1b3RhKTtcbiAgfSBlbHNlIHtcbiAgICBmYWlsKCdOT19TVVBQT1JUJyk7XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/html5-fs/src/fileSystem.js\n");

/***/ }),

/***/ "./node_modules/html5-fs/src/utils.js":
/*!********************************************!*\
  !*** ./node_modules/html5-fs/src/utils.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Detect is the device a mobile device.\n * @return {Boolean}\n */\nexports.isMobile = function() {\n  var ua = window.navigator.userAgent;\n  return (ua.match(/Android|iPad|iPhone|iPod|Windows Phone/) !== null);\n};\n\n\n/**\n * Determine if this is a PhoneGap application.\n * @return {Boolean}\n */\nexports.isPhoneGap = function() {\n  // TODO: Improve this...\n  var proto = window.location.protocol;\n  return (this.isMobile() && proto.indexOf('file') !== -1);\n};\n\n\n/**\n * Determine if FileSystem is supported.\n * @return {Boolean}\n */\nexports.supportsFileSystem = function() {\n  if (this.isPhoneGap() === true) {\n    return true;\n  }\n\n  // TODO: Test this works, Opera (WebKit) and Chrome\n  return window.navigator.userAgent.match(/Chrome|Opera/);\n};\n\n\n/**\n * Wrap a callback for use as a success callback.\n * @param    {Function} callback\n * @return   {Function}\n */\nexports.wrapSuccess = function(callback) {\n  return function() {\n    var args = [null].concat(Array.prototype.slice.call(arguments));\n\n    callback.apply(callback, args);\n  };\n};\n\n\n/**\n * Wrap a callback for use as a failure callback.\n * @param    {Function} callback\n * @return   {Function}\n */\nexports.wrapFail = function(callback) {\n  return function() {\n    var args = Array.prototype.slice.call(arguments)\n      , e = args[0];\n\n    callback.apply(callback, [e, null]);\n  };\n};\n\n\n/**\n * Check is provided path a directory.\n * @param  {String} path\n * @return {Boolean}\n */\nexports.isDirectory = function(path) {\n  return (path.lastIndexOf('/') === (path.length - 1));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbDUtZnMvc3JjL3V0aWxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWw1LWZzL3NyYy91dGlscy5qcz80MDE2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlY3QgaXMgdGhlIGRldmljZSBhIG1vYmlsZSBkZXZpY2UuXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzTW9iaWxlID0gZnVuY3Rpb24oKSB7XG4gIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuICByZXR1cm4gKHVhLm1hdGNoKC9BbmRyb2lkfGlQYWR8aVBob25lfGlQb2R8V2luZG93cyBQaG9uZS8pICE9PSBudWxsKTtcbn07XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhpcyBpcyBhIFBob25lR2FwIGFwcGxpY2F0aW9uLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1Bob25lR2FwID0gZnVuY3Rpb24oKSB7XG4gIC8vIFRPRE86IEltcHJvdmUgdGhpcy4uLlxuICB2YXIgcHJvdG8gPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7XG4gIHJldHVybiAodGhpcy5pc01vYmlsZSgpICYmIHByb3RvLmluZGV4T2YoJ2ZpbGUnKSAhPT0gLTEpO1xufTtcblxuXG4vKipcbiAqIERldGVybWluZSBpZiBGaWxlU3lzdGVtIGlzIHN1cHBvcnRlZC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuc3VwcG9ydHNGaWxlU3lzdGVtID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlzUGhvbmVHYXAoKSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gVE9ETzogVGVzdCB0aGlzIHdvcmtzLCBPcGVyYSAoV2ViS2l0KSBhbmQgQ2hyb21lXG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lfE9wZXJhLyk7XG59O1xuXG5cbi8qKlxuICogV3JhcCBhIGNhbGxiYWNrIGZvciB1c2UgYXMgYSBzdWNjZXNzIGNhbGxiYWNrLlxuICogQHBhcmFtICAgIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4gICB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydHMud3JhcFN1Y2Nlc3MgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBbbnVsbF0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuXG4gICAgY2FsbGJhY2suYXBwbHkoY2FsbGJhY2ssIGFyZ3MpO1xuICB9O1xufTtcblxuXG4vKipcbiAqIFdyYXAgYSBjYWxsYmFjayBmb3IgdXNlIGFzIGEgZmFpbHVyZSBjYWxsYmFjay5cbiAqIEBwYXJhbSAgICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuICAge0Z1bmN0aW9ufVxuICovXG5leHBvcnRzLndyYXBGYWlsID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgICAgLCBlID0gYXJnc1swXTtcblxuICAgIGNhbGxiYWNrLmFwcGx5KGNhbGxiYWNrLCBbZSwgbnVsbF0pO1xuICB9O1xufTtcblxuXG4vKipcbiAqIENoZWNrIGlzIHByb3ZpZGVkIHBhdGggYSBkaXJlY3RvcnkuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNEaXJlY3RvcnkgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiAocGF0aC5sYXN0SW5kZXhPZignLycpID09PSAocGF0aC5sZW5ndGggLSAxKSk7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/html5-fs/src/utils.js\n");

/***/ }),

/***/ "./node_modules/is-callable/index.js":
/*!*******************************************!*\
  !*** ./node_modules/is-callable/index.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar fnToStr = Function.prototype.toString;\n\nvar constructorRegex = /^\\s*class\\b/;\nvar isES6ClassFn = function isES6ClassFunction(value) {\n\ttry {\n\t\tvar fnStr = fnToStr.call(value);\n\t\treturn constructorRegex.test(fnStr);\n\t} catch (e) {\n\t\treturn false; // not a function\n\t}\n};\n\nvar tryFunctionObject = function tryFunctionToStr(value) {\n\ttry {\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tfnToStr.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar fnClass = '[object Function]';\nvar genClass = '[object GeneratorFunction]';\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nmodule.exports = function isCallable(value) {\n\tif (!value) { return false; }\n\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\tif (typeof value === 'function' && !value.prototype) { return true; }\n\tif (hasToStringTag) { return tryFunctionObject(value); }\n\tif (isES6ClassFn(value)) { return false; }\n\tvar strClass = toStr.call(value);\n\treturn strClass === fnClass || strClass === genClass;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaXMtY2FsbGFibGUvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXMtY2FsbGFibGUvaW5kZXguanM/MjFkMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG52YXIgY29uc3RydWN0b3JSZWdleCA9IC9eXFxzKmNsYXNzXFxiLztcbnZhciBpc0VTNkNsYXNzRm4gPSBmdW5jdGlvbiBpc0VTNkNsYXNzRnVuY3Rpb24odmFsdWUpIHtcblx0dHJ5IHtcblx0XHR2YXIgZm5TdHIgPSBmblRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiBjb25zdHJ1Y3RvclJlZ2V4LnRlc3QoZm5TdHIpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlOyAvLyBub3QgYSBmdW5jdGlvblxuXHR9XG59O1xuXG52YXIgdHJ5RnVuY3Rpb25PYmplY3QgPSBmdW5jdGlvbiB0cnlGdW5jdGlvblRvU3RyKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0aWYgKGlzRVM2Q2xhc3NGbih2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm5Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZm5DbGFzcyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG52YXIgZ2VuQ2xhc3MgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbGxhYmxlKHZhbHVlKSB7XG5cdGlmICghdmFsdWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhdmFsdWUucHJvdG90eXBlKSB7IHJldHVybiB0cnVlOyB9XG5cdGlmIChoYXNUb1N0cmluZ1RhZykgeyByZXR1cm4gdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpOyB9XG5cdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHR2YXIgc3RyQ2xhc3MgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0cmV0dXJuIHN0ckNsYXNzID09PSBmbkNsYXNzIHx8IHN0ckNsYXNzID09PSBnZW5DbGFzcztcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/is-callable/index.js\n");

/***/ }),

/***/ "./node_modules/is-function/index.js":
/*!*******************************************!*\
  !*** ./node_modules/is-function/index.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = isFunction\n\nvar toString = Object.prototype.toString\n\nfunction isFunction (fn) {\n  var string = toString.call(fn)\n  return string === '[object Function]' ||\n    (typeof fn === 'function' && string !== '[object RegExp]') ||\n    (typeof window !== 'undefined' &&\n     // IE8 and below\n     (fn === window.setTimeout ||\n      fn === window.alert ||\n      fn === window.confirm ||\n      fn === window.prompt))\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaXMtZnVuY3Rpb24vaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXMtZnVuY3Rpb24vaW5kZXguanM/ODM2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb25cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uIChmbikge1xuICB2YXIgc3RyaW5nID0gdG9TdHJpbmcuY2FsbChmbilcbiAgcmV0dXJuIHN0cmluZyA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJyB8fFxuICAgICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgJiYgc3RyaW5nICE9PSAnW29iamVjdCBSZWdFeHBdJykgfHxcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgLy8gSUU4IGFuZCBiZWxvd1xuICAgICAoZm4gPT09IHdpbmRvdy5zZXRUaW1lb3V0IHx8XG4gICAgICBmbiA9PT0gd2luZG93LmFsZXJ0IHx8XG4gICAgICBmbiA9PT0gd2luZG93LmNvbmZpcm0gfHxcbiAgICAgIGZuID09PSB3aW5kb3cucHJvbXB0KSlcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/is-function/index.js\n");

/***/ }),

/***/ "./node_modules/parse-headers/parse-headers.js":
/*!*****************************************************!*\
  !*** ./node_modules/parse-headers/parse-headers.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var trim = __webpack_require__(/*! trim */ \"./node_modules/trim/index.js\")\n  , forEach = __webpack_require__(/*! for-each */ \"./node_modules/for-each/index.js\")\n  , isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === '[object Array]';\n    }\n\nmodule.exports = function (headers) {\n  if (!headers)\n    return {}\n\n  var result = {}\n\n  forEach(\n      trim(headers).split('\\n')\n    , function (row) {\n        var index = row.indexOf(':')\n          , key = trim(row.slice(0, index)).toLowerCase()\n          , value = trim(row.slice(index + 1))\n\n        if (typeof(result[key]) === 'undefined') {\n          result[key] = value\n        } else if (isArray(result[key])) {\n          result[key].push(value)\n        } else {\n          result[key] = [ result[key], value ]\n        }\n      }\n  )\n\n  return result\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGFyc2UtaGVhZGVycy9wYXJzZS1oZWFkZXJzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvcGFyc2UtaGVhZGVycy5qcz82NDQ0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB0cmltID0gcmVxdWlyZSgndHJpbScpXG4gICwgZm9yRWFjaCA9IHJlcXVpcmUoJ2Zvci1lYWNoJylcbiAgLCBpc0FycmF5ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gIGlmICghaGVhZGVycylcbiAgICByZXR1cm4ge31cblxuICB2YXIgcmVzdWx0ID0ge31cblxuICBmb3JFYWNoKFxuICAgICAgdHJpbShoZWFkZXJzKS5zcGxpdCgnXFxuJylcbiAgICAsIGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcm93LmluZGV4T2YoJzonKVxuICAgICAgICAgICwga2V5ID0gdHJpbShyb3cuc2xpY2UoMCwgaW5kZXgpKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgLCB2YWx1ZSA9IHRyaW0ocm93LnNsaWNlKGluZGV4ICsgMSkpXG5cbiAgICAgICAgaWYgKHR5cGVvZihyZXN1bHRba2V5XSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZVxuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkocmVzdWx0W2tleV0pKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IFsgcmVzdWx0W2tleV0sIHZhbHVlIF1cbiAgICAgICAgfVxuICAgICAgfVxuICApXG5cbiAgcmV0dXJuIHJlc3VsdFxufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/parse-headers/parse-headers.js\n");

/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcz9kZjdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/path-browserify/index.js\n");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz9mMjhjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzPzYwMTciXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/setimmediate/setImmediate.js\n");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzPzUxMTgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/timers-browserify/main.js\n");

/***/ }),

/***/ "./node_modules/trim/index.js":
/*!************************************!*\
  !*** ./node_modules/trim/index.js ***!
  \************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("\nexports = module.exports = trim;\n\nfunction trim(str){\n  return str.replace(/^\\s*|\\s*$/g, '');\n}\n\nexports.left = function(str){\n  return str.replace(/^\\s*/, '');\n};\n\nexports.right = function(str){\n  return str.replace(/\\s*$/, '');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHJpbS9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90cmltL2luZGV4LmpzPzQ2YzEiXSwic291cmNlc0NvbnRlbnQiOlsiXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0cmltO1xuXG5mdW5jdGlvbiB0cmltKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpO1xufVxuXG5leHBvcnRzLmxlZnQgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpO1xufTtcblxuZXhwb3J0cy5yaWdodCA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/trim/index.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL21vZHVsZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanM/Y2VkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/module.js\n");

/***/ }),

/***/ "./node_modules/xhr/index.js":
/*!***********************************!*\
  !*** ./node_modules/xhr/index.js ***!
  \***********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar window = __webpack_require__(/*! global/window */ \"./node_modules/global/window.js\")\nvar isFunction = __webpack_require__(/*! is-function */ \"./node_modules/is-function/index.js\")\nvar parseHeaders = __webpack_require__(/*! parse-headers */ \"./node_modules/parse-headers/parse-headers.js\")\nvar xtend = __webpack_require__(/*! xtend */ \"./node_modules/xtend/immutable.js\")\n\nmodule.exports = createXHR\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = createXHR;\ncreateXHR.XMLHttpRequest = window.XMLHttpRequest || noop\ncreateXHR.XDomainRequest = \"withCredentials\" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest\n\nforEachArray([\"get\", \"put\", \"post\", \"patch\", \"head\", \"delete\"], function(method) {\n    createXHR[method === \"delete\" ? \"del\" : method] = function(uri, options, callback) {\n        options = initParams(uri, options, callback)\n        options.method = method.toUpperCase()\n        return _createXHR(options)\n    }\n})\n\nfunction forEachArray(array, iterator) {\n    for (var i = 0; i < array.length; i++) {\n        iterator(array[i])\n    }\n}\n\nfunction isEmpty(obj){\n    for(var i in obj){\n        if(obj.hasOwnProperty(i)) return false\n    }\n    return true\n}\n\nfunction initParams(uri, options, callback) {\n    var params = uri\n\n    if (isFunction(options)) {\n        callback = options\n        if (typeof uri === \"string\") {\n            params = {uri:uri}\n        }\n    } else {\n        params = xtend(options, {uri: uri})\n    }\n\n    params.callback = callback\n    return params\n}\n\nfunction createXHR(uri, options, callback) {\n    options = initParams(uri, options, callback)\n    return _createXHR(options)\n}\n\nfunction _createXHR(options) {\n    if(typeof options.callback === \"undefined\"){\n        throw new Error(\"callback argument missing\")\n    }\n\n    var called = false\n    var callback = function cbOnce(err, response, body){\n        if(!called){\n            called = true\n            options.callback(err, response, body)\n        }\n    }\n\n    function readystatechange() {\n        if (xhr.readyState === 4) {\n            setTimeout(loadFunc, 0)\n        }\n    }\n\n    function getBody() {\n        // Chrome with requestType=blob throws errors arround when even testing access to responseText\n        var body = undefined\n\n        if (xhr.response) {\n            body = xhr.response\n        } else {\n            body = xhr.responseText || getXml(xhr)\n        }\n\n        if (isJson) {\n            try {\n                body = JSON.parse(body)\n            } catch (e) {}\n        }\n\n        return body\n    }\n\n    function errorFunc(evt) {\n        clearTimeout(timeoutTimer)\n        if(!(evt instanceof Error)){\n            evt = new Error(\"\" + (evt || \"Unknown XMLHttpRequest Error\") )\n        }\n        evt.statusCode = 0\n        return callback(evt, failureResponse)\n    }\n\n    // will load the data & process the response in a special response object\n    function loadFunc() {\n        if (aborted) return\n        var status\n        clearTimeout(timeoutTimer)\n        if(options.useXDR && xhr.status===undefined) {\n            //IE8 CORS GET successful response doesn't have a status field, but body is fine\n            status = 200\n        } else {\n            status = (xhr.status === 1223 ? 204 : xhr.status)\n        }\n        var response = failureResponse\n        var err = null\n\n        if (status !== 0){\n            response = {\n                body: getBody(),\n                statusCode: status,\n                method: method,\n                headers: {},\n                url: uri,\n                rawRequest: xhr\n            }\n            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE\n                response.headers = parseHeaders(xhr.getAllResponseHeaders())\n            }\n        } else {\n            err = new Error(\"Internal XMLHttpRequest Error\")\n        }\n        return callback(err, response, response.body)\n    }\n\n    var xhr = options.xhr || null\n\n    if (!xhr) {\n        if (options.cors || options.useXDR) {\n            xhr = new createXHR.XDomainRequest()\n        }else{\n            xhr = new createXHR.XMLHttpRequest()\n        }\n    }\n\n    var key\n    var aborted\n    var uri = xhr.url = options.uri || options.url\n    var method = xhr.method = options.method || \"GET\"\n    var body = options.body || options.data\n    var headers = xhr.headers = options.headers || {}\n    var sync = !!options.sync\n    var isJson = false\n    var timeoutTimer\n    var failureResponse = {\n        body: undefined,\n        headers: {},\n        statusCode: 0,\n        method: method,\n        url: uri,\n        rawRequest: xhr\n    }\n\n    if (\"json\" in options && options.json !== false) {\n        isJson = true\n        headers[\"accept\"] || headers[\"Accept\"] || (headers[\"Accept\"] = \"application/json\") //Don't override existing accept header declared by user\n        if (method !== \"GET\" && method !== \"HEAD\") {\n            headers[\"content-type\"] || headers[\"Content-Type\"] || (headers[\"Content-Type\"] = \"application/json\") //Don't override existing accept header declared by user\n            body = JSON.stringify(options.json === true ? body : options.json)\n        }\n    }\n\n    xhr.onreadystatechange = readystatechange\n    xhr.onload = loadFunc\n    xhr.onerror = errorFunc\n    // IE9 must have onprogress be set to a unique function.\n    xhr.onprogress = function () {\n        // IE must die\n    }\n    xhr.onabort = function(){\n        aborted = true;\n    }\n    xhr.ontimeout = errorFunc\n    xhr.open(method, uri, !sync, options.username, options.password)\n    //has to be after open\n    if(!sync) {\n        xhr.withCredentials = !!options.withCredentials\n    }\n    // Cannot set timeout with sync request\n    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly\n    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent\n    if (!sync && options.timeout > 0 ) {\n        timeoutTimer = setTimeout(function(){\n            if (aborted) return\n            aborted = true//IE9 may still call readystatechange\n            xhr.abort(\"timeout\")\n            var e = new Error(\"XMLHttpRequest timeout\")\n            e.code = \"ETIMEDOUT\"\n            errorFunc(e)\n        }, options.timeout )\n    }\n\n    if (xhr.setRequestHeader) {\n        for(key in headers){\n            if(headers.hasOwnProperty(key)){\n                xhr.setRequestHeader(key, headers[key])\n            }\n        }\n    } else if (options.headers && !isEmpty(options.headers)) {\n        throw new Error(\"Headers cannot be set on an XDomainRequest object\")\n    }\n\n    if (\"responseType\" in options) {\n        xhr.responseType = options.responseType\n    }\n\n    if (\"beforeSend\" in options &&\n        typeof options.beforeSend === \"function\"\n    ) {\n        options.beforeSend(xhr)\n    }\n\n    // Microsoft Edge browser sends \"undefined\" when send is called with undefined value.\n    // XMLHttpRequest spec says to pass null as body to indicate no body\n    // See https://github.com/naugtur/xhr/issues/100.\n    xhr.send(body || null)\n\n    return xhr\n\n\n}\n\nfunction getXml(xhr) {\n    // xhr.responseXML will throw Exception \"InvalidStateError\" or \"DOMException\"\n    // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.\n    try {\n        if (xhr.responseType === \"document\") {\n            return xhr.responseXML\n        }\n        var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === \"parsererror\"\n        if (xhr.responseType === \"\" && !firefoxBugTakenEffect) {\n            return xhr.responseXML\n        }\n    } catch (e) {}\n\n    return null\n}\n\nfunction noop() {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveGhyL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3hoci9pbmRleC5qcz9lZWM3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIHdpbmRvdyA9IHJlcXVpcmUoXCJnbG9iYWwvd2luZG93XCIpXG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoXCJpcy1mdW5jdGlvblwiKVxudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoXCJwYXJzZS1oZWFkZXJzXCIpXG52YXIgeHRlbmQgPSByZXF1aXJlKFwieHRlbmRcIilcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVYSFJcbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZVhIUjtcbmNyZWF0ZVhIUi5YTUxIdHRwUmVxdWVzdCA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCB8fCBub29wXG5jcmVhdGVYSFIuWERvbWFpblJlcXVlc3QgPSBcIndpdGhDcmVkZW50aWFsc1wiIGluIChuZXcgY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0KCkpID8gY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0IDogd2luZG93LlhEb21haW5SZXF1ZXN0XG5cbmZvckVhY2hBcnJheShbXCJnZXRcIiwgXCJwdXRcIiwgXCJwb3N0XCIsIFwicGF0Y2hcIiwgXCJoZWFkXCIsIFwiZGVsZXRlXCJdLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICBjcmVhdGVYSFJbbWV0aG9kID09PSBcImRlbGV0ZVwiID8gXCJkZWxcIiA6IG1ldGhvZF0gPSBmdW5jdGlvbih1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0UGFyYW1zKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgICAgIG9wdGlvbnMubWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVYSFIob3B0aW9ucylcbiAgICB9XG59KVxuXG5mdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRvcihhcnJheVtpXSlcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHkob2JqKXtcbiAgICBmb3IodmFyIGkgaW4gb2JqKXtcbiAgICAgICAgaWYob2JqLmhhc093blByb3BlcnR5KGkpKSByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHBhcmFtcyA9IHVyaVxuXG4gICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucykpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICAgIGlmICh0eXBlb2YgdXJpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7dXJpOnVyaX1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtcyA9IHh0ZW5kKG9wdGlvbnMsIHt1cmk6IHVyaX0pXG4gICAgfVxuXG4gICAgcGFyYW1zLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICByZXR1cm4gcGFyYW1zXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVhIUih1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgb3B0aW9ucyA9IGluaXRQYXJhbXModXJpLCBvcHRpb25zLCBjYWxsYmFjaylcbiAgICByZXR1cm4gX2NyZWF0ZVhIUihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlWEhSKG9wdGlvbnMpIHtcbiAgICBpZih0eXBlb2Ygb3B0aW9ucy5jYWxsYmFjayA9PT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbGxiYWNrIGFyZ3VtZW50IG1pc3NpbmdcIilcbiAgICB9XG5cbiAgICB2YXIgY2FsbGVkID0gZmFsc2VcbiAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYk9uY2UoZXJyLCByZXNwb25zZSwgYm9keSl7XG4gICAgICAgIGlmKCFjYWxsZWQpe1xuICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZVxuICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhlcnIsIHJlc3BvbnNlLCBib2R5KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGxvYWRGdW5jLCAwKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Qm9keSgpIHtcbiAgICAgICAgLy8gQ2hyb21lIHdpdGggcmVxdWVzdFR5cGU9YmxvYiB0aHJvd3MgZXJyb3JzIGFycm91bmQgd2hlbiBldmVuIHRlc3RpbmcgYWNjZXNzIHRvIHJlc3BvbnNlVGV4dFxuICAgICAgICB2YXIgYm9keSA9IHVuZGVmaW5lZFxuXG4gICAgICAgIGlmICh4aHIucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2VUZXh0IHx8IGdldFhtbCh4aHIpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNKc29uKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvZHlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvckZ1bmMoZXZ0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0VGltZXIpXG4gICAgICAgIGlmKCEoZXZ0IGluc3RhbmNlb2YgRXJyb3IpKXtcbiAgICAgICAgICAgIGV2dCA9IG5ldyBFcnJvcihcIlwiICsgKGV2dCB8fCBcIlVua25vd24gWE1MSHR0cFJlcXVlc3QgRXJyb3JcIikgKVxuICAgICAgICB9XG4gICAgICAgIGV2dC5zdGF0dXNDb2RlID0gMFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXZ0LCBmYWlsdXJlUmVzcG9uc2UpXG4gICAgfVxuXG4gICAgLy8gd2lsbCBsb2FkIHRoZSBkYXRhICYgcHJvY2VzcyB0aGUgcmVzcG9uc2UgaW4gYSBzcGVjaWFsIHJlc3BvbnNlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGxvYWRGdW5jKCkge1xuICAgICAgICBpZiAoYWJvcnRlZCkgcmV0dXJuXG4gICAgICAgIHZhciBzdGF0dXNcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcilcbiAgICAgICAgaWYob3B0aW9ucy51c2VYRFIgJiYgeGhyLnN0YXR1cz09PXVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy9JRTggQ09SUyBHRVQgc3VjY2Vzc2Z1bCByZXNwb25zZSBkb2Vzbid0IGhhdmUgYSBzdGF0dXMgZmllbGQsIGJ1dCBib2R5IGlzIGZpbmVcbiAgICAgICAgICAgIHN0YXR1cyA9IDIwMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdHVzID0gKHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzKVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXNwb25zZSA9IGZhaWx1cmVSZXNwb25zZVxuICAgICAgICB2YXIgZXJyID0gbnVsbFxuXG4gICAgICAgIGlmIChzdGF0dXMgIT09IDApe1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgYm9keTogZ2V0Qm9keSgpLFxuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IHN0YXR1cyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICB1cmw6IHVyaSxcbiAgICAgICAgICAgICAgICByYXdSZXF1ZXN0OiB4aHJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMpeyAvL3JlbWVtYmVyIHhociBjYW4gaW4gZmFjdCBiZSBYRFIgZm9yIENPUlMgaW4gSUVcbiAgICAgICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzID0gcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVyciA9IG5ldyBFcnJvcihcIkludGVybmFsIFhNTEh0dHBSZXF1ZXN0IEVycm9yXCIpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgcmVzcG9uc2UsIHJlc3BvbnNlLmJvZHkpXG4gICAgfVxuXG4gICAgdmFyIHhociA9IG9wdGlvbnMueGhyIHx8IG51bGxcblxuICAgIGlmICgheGhyKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNvcnMgfHwgb3B0aW9ucy51c2VYRFIpIHtcbiAgICAgICAgICAgIHhociA9IG5ldyBjcmVhdGVYSFIuWERvbWFpblJlcXVlc3QoKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHhociA9IG5ldyBjcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleVxuICAgIHZhciBhYm9ydGVkXG4gICAgdmFyIHVyaSA9IHhoci51cmwgPSBvcHRpb25zLnVyaSB8fCBvcHRpb25zLnVybFxuICAgIHZhciBtZXRob2QgPSB4aHIubWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIlxuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5IHx8IG9wdGlvbnMuZGF0YVxuICAgIHZhciBoZWFkZXJzID0geGhyLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge31cbiAgICB2YXIgc3luYyA9ICEhb3B0aW9ucy5zeW5jXG4gICAgdmFyIGlzSnNvbiA9IGZhbHNlXG4gICAgdmFyIHRpbWVvdXRUaW1lclxuICAgIHZhciBmYWlsdXJlUmVzcG9uc2UgPSB7XG4gICAgICAgIGJvZHk6IHVuZGVmaW5lZCxcbiAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgIHN0YXR1c0NvZGU6IDAsXG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICB1cmw6IHVyaSxcbiAgICAgICAgcmF3UmVxdWVzdDogeGhyXG4gICAgfVxuXG4gICAgaWYgKFwianNvblwiIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5qc29uICE9PSBmYWxzZSkge1xuICAgICAgICBpc0pzb24gPSB0cnVlXG4gICAgICAgIGhlYWRlcnNbXCJhY2NlcHRcIl0gfHwgaGVhZGVyc1tcIkFjY2VwdFwiXSB8fCAoaGVhZGVyc1tcIkFjY2VwdFwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiKSAvL0Rvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGFjY2VwdCBoZWFkZXIgZGVjbGFyZWQgYnkgdXNlclxuICAgICAgICBpZiAobWV0aG9kICE9PSBcIkdFVFwiICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gfHwgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSB8fCAoaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiKSAvL0Rvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGFjY2VwdCBoZWFkZXIgZGVjbGFyZWQgYnkgdXNlclxuICAgICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuanNvbiA9PT0gdHJ1ZSA/IGJvZHkgOiBvcHRpb25zLmpzb24pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gcmVhZHlzdGF0ZWNoYW5nZVxuICAgIHhoci5vbmxvYWQgPSBsb2FkRnVuY1xuICAgIHhoci5vbmVycm9yID0gZXJyb3JGdW5jXG4gICAgLy8gSUU5IG11c3QgaGF2ZSBvbnByb2dyZXNzIGJlIHNldCB0byBhIHVuaXF1ZSBmdW5jdGlvbi5cbiAgICB4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSUUgbXVzdCBkaWVcbiAgICB9XG4gICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbigpe1xuICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgeGhyLm9udGltZW91dCA9IGVycm9yRnVuY1xuICAgIHhoci5vcGVuKG1ldGhvZCwgdXJpLCAhc3luYywgb3B0aW9ucy51c2VybmFtZSwgb3B0aW9ucy5wYXNzd29yZClcbiAgICAvL2hhcyB0byBiZSBhZnRlciBvcGVuXG4gICAgaWYoIXN5bmMpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9ICEhb3B0aW9ucy53aXRoQ3JlZGVudGlhbHNcbiAgICB9XG4gICAgLy8gQ2Fubm90IHNldCB0aW1lb3V0IHdpdGggc3luYyByZXF1ZXN0XG4gICAgLy8gbm90IHNldHRpbmcgdGltZW91dCBvbiB0aGUgeGhyIG9iamVjdCwgYmVjYXVzZSBvZiBvbGQgd2Via2l0cyBldGMuIG5vdCBoYW5kbGluZyB0aGF0IGNvcnJlY3RseVxuICAgIC8vIGJvdGggbnBtJ3MgcmVxdWVzdCBhbmQganF1ZXJ5IDEueCB1c2UgdGhpcyBraW5kIG9mIHRpbWVvdXQsIHNvIHRoaXMgaXMgYmVpbmcgY29uc2lzdGVudFxuICAgIGlmICghc3luYyAmJiBvcHRpb25zLnRpbWVvdXQgPiAwICkge1xuICAgICAgICB0aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAoYWJvcnRlZCkgcmV0dXJuXG4gICAgICAgICAgICBhYm9ydGVkID0gdHJ1ZS8vSUU5IG1heSBzdGlsbCBjYWxsIHJlYWR5c3RhdGVjaGFuZ2VcbiAgICAgICAgICAgIHhoci5hYm9ydChcInRpbWVvdXRcIilcbiAgICAgICAgICAgIHZhciBlID0gbmV3IEVycm9yKFwiWE1MSHR0cFJlcXVlc3QgdGltZW91dFwiKVxuICAgICAgICAgICAgZS5jb2RlID0gXCJFVElNRURPVVRcIlxuICAgICAgICAgICAgZXJyb3JGdW5jKGUpXG4gICAgICAgIH0sIG9wdGlvbnMudGltZW91dCApXG4gICAgfVxuXG4gICAgaWYgKHhoci5zZXRSZXF1ZXN0SGVhZGVyKSB7XG4gICAgICAgIGZvcihrZXkgaW4gaGVhZGVycyl7XG4gICAgICAgICAgICBpZihoZWFkZXJzLmhhc093blByb3BlcnR5KGtleSkpe1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgaGVhZGVyc1trZXldKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmhlYWRlcnMgJiYgIWlzRW1wdHkob3B0aW9ucy5oZWFkZXJzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIZWFkZXJzIGNhbm5vdCBiZSBzZXQgb24gYW4gWERvbWFpblJlcXVlc3Qgb2JqZWN0XCIpXG4gICAgfVxuXG4gICAgaWYgKFwicmVzcG9uc2VUeXBlXCIgaW4gb3B0aW9ucykge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGVcbiAgICB9XG5cbiAgICBpZiAoXCJiZWZvcmVTZW5kXCIgaW4gb3B0aW9ucyAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5iZWZvcmVTZW5kID09PSBcImZ1bmN0aW9uXCJcbiAgICApIHtcbiAgICAgICAgb3B0aW9ucy5iZWZvcmVTZW5kKHhocilcbiAgICB9XG5cbiAgICAvLyBNaWNyb3NvZnQgRWRnZSBicm93c2VyIHNlbmRzIFwidW5kZWZpbmVkXCIgd2hlbiBzZW5kIGlzIGNhbGxlZCB3aXRoIHVuZGVmaW5lZCB2YWx1ZS5cbiAgICAvLyBYTUxIdHRwUmVxdWVzdCBzcGVjIHNheXMgdG8gcGFzcyBudWxsIGFzIGJvZHkgdG8gaW5kaWNhdGUgbm8gYm9keVxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbmF1Z3R1ci94aHIvaXNzdWVzLzEwMC5cbiAgICB4aHIuc2VuZChib2R5IHx8IG51bGwpXG5cbiAgICByZXR1cm4geGhyXG5cblxufVxuXG5mdW5jdGlvbiBnZXRYbWwoeGhyKSB7XG4gICAgLy8geGhyLnJlc3BvbnNlWE1MIHdpbGwgdGhyb3cgRXhjZXB0aW9uIFwiSW52YWxpZFN0YXRlRXJyb3JcIiBvciBcIkRPTUV4Y2VwdGlvblwiXG4gICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9yZXNwb25zZVhNTC5cbiAgICB0cnkge1xuICAgICAgICBpZiAoeGhyLnJlc3BvbnNlVHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlWE1MXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpcmVmb3hCdWdUYWtlbkVmZmVjdCA9IHhoci5yZXNwb25zZVhNTCAmJiB4aHIucmVzcG9uc2VYTUwuZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lID09PSBcInBhcnNlcmVycm9yXCJcbiAgICAgICAgaWYgKHhoci5yZXNwb25zZVR5cGUgPT09IFwiXCIgJiYgIWZpcmVmb3hCdWdUYWtlbkVmZmVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVhNTFxuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/xhr/index.js\n");

/***/ }),

/***/ "./node_modules/xtend/immutable.js":
/*!*****************************************!*\
  !*** ./node_modules/xtend/immutable.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveHRlbmQvaW1tdXRhYmxlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZW5kL2ltbXV0YWJsZS5qcz81M2E4Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICB2YXIgdGFyZ2V0ID0ge31cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/xtend/immutable.js\n");

/***/ })

/******/ });